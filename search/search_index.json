{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>x_xy</code> - Documentation Home","text":"<p>This is the documentation for the <code>x_xy</code> software library.</p> <p> </p>"},{"location":"#x_xy_v2-a-tiny-kinematic-tree-simulator","title":"<code>x_xy_v2</code> -- A tiny Kinematic Tree Simulator","text":""},{"location":"#installation","title":"Installation","text":"<p>Supports <code>Python=3.10</code> and <code>Python=3.11</code>.</p> <p>Install with <code>pip</code> using</p> <p><code>pip install git+https://github.com/SimiPixel/x_xy_v2.git</code></p> <p>Additionally, - <code>render.py</code> requires a vispy backend (e.g. <code>pip install pyqt6</code>).</p> <pre><code>Note 1: On a headless node with a Nvidia GPU it works without any backend.\n\nNote 2: More info: https://vispy.org/installation.html\n</code></pre> <p>Typically, this will install <code>jax</code> as cpu-only version. CUDA version can be installed with <pre><code>pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n</code></pre></p>"},{"location":"#publications","title":"Publications","text":"<p>The following publications utilize this software library, and refer to it as the Random Chain Motion Generator (RCMG) (more specifically the function <code>x_xy.build_generator</code>):</p> <ul> <li>RNN-based Observability Analysis for Magnetometer-Free Sparse Inertial Motion Tracking</li> <li>Plug-and-Play Sparse Inertial Motion Tracking With Sim-to-Real Transfer</li> </ul>"},{"location":"#contact","title":"Contact","text":"<p>Simon Bachhuber (simon.bachhuber@fau.de)</p>"},{"location":"api/dyn_sim/","title":"Dynamic Simulation","text":""},{"location":"api/dyn_sim/#x_xy.algorithms.step","title":"<code>step(sys, state, taus=None, n_substeps=1)</code>","text":"Source code in <code>x_xy/algorithms/dynamics.py</code> <pre><code>def step(\n    sys: base.System,\n    state: base.State,\n    taus: Optional[jax.Array] = None,\n    n_substeps: int = 1,\n) -&gt; base.State:\n    assert sys.q_size() == state.q.size\n    if taus is None:\n        taus = jnp.zeros_like(state.qd)\n    assert sys.qd_size() == state.qd.size == taus.size\n    assert (\n        sys.integration_method.lower() == \"semi_implicit_euler\"\n    ), \"Currently, nothing else then `semi_implicit_euler` implemented.\"\n\n    sys = sys.replace(dt=sys.dt / n_substeps)\n\n    for _ in range(n_substeps):\n        # update kinematics before stepping; this means that the `x` in `state`\n        # will lag one step behind but otherwise we would have to return\n        # the system object which would be awkward\n        sys, state = forward_kinematics(sys, state)\n        state = _integration_methods[sys.integration_method.lower()](sys, state, taus)\n\n    return state\n</code></pre>"},{"location":"api/dyn_sim/#x_xy.algorithms.pd_control","title":"<code>pd_control(P, D)</code>","text":"<p>Computes tau using a PD controller. Returns a pair of (init, apply) functions.</p> <p>NOTE: Gains around ~10_000 are good for spherical joints, everything else ~250-300 works just fine. Damping should be about 2500 for spherical joints, and about 25 for everything else.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>Array</code> <p>jax.Array of P gains. Shape: (sys_init.qd_size())</p> required <code>D</code> <code>Array</code> <p>jax.Array of D gains. Shape: (sys_init.qd_size()) where <code>sys_init</code> is the system that recorded the reference trajectory <code>q_ref</code></p> required <p>Pair of (init, apply) functions</p> Name Type Description <code>init</code> <p>(sys, q_ref) -&gt; controller_state</p> <code>apply</code> <p>(controller_state, sys, state) -&gt; controller_state, tau</p> Example <p>gains = jnp.array([250.0] * sys1.qd_size()) controller = pd_control(gains, gains) q_ref = rcmg(sys1) cs = controller.init(sys1, q_ref) for t in range(1000):     cs, tau = controller.apply(cs, sys2, state)     state = dynamics.step(sys2, state, tau)</p> Source code in <code>x_xy/algorithms/control.py</code> <pre><code>def pd_control(P: jax.Array, D: jax.Array):\n\"\"\"Computes tau using a PD controller. Returns a pair of (init, apply) functions.\n\n    NOTE: Gains around ~10_000 are good for spherical joints, everything else ~250-300\n    works just fine. Damping should be about 2500 for spherical joints, and\n    about 25 for everything else.\n\n    Args:\n        P: jax.Array of P gains. Shape: (sys_init.qd_size())\n        D: jax.Array of D gains. Shape: (sys_init.qd_size()) where `sys_init` is the\n            system that recorded the reference trajectory `q_ref`\n\n    Returns: Pair of (init, apply) functions\n        init: (sys, q_ref) -&gt; controller_state\n        apply: (controller_state, sys, state) -&gt; controller_state, tau\n\n    Example:\n        &gt;&gt;&gt; gains = jnp.array([250.0] * sys1.qd_size())\n        &gt;&gt;&gt; controller = pd_control(gains, gains)\n        &gt;&gt;&gt; q_ref = rcmg(sys1)\n        &gt;&gt;&gt; cs = controller.init(sys1, q_ref)\n        &gt;&gt;&gt; for t in range(1000):\n        &gt;&gt;&gt;     cs, tau = controller.apply(cs, sys2, state)\n        &gt;&gt;&gt;     state = dynamics.step(sys2, state, tau)\n    \"\"\"\n\n    def init(sys: base.System, q_ref: jax.Array) -&gt; dict:\n        q_qd_ref = {}\n        P_as_dict = {}\n        D_as_dict = {}\n\n        def f(_, __, q_ref_link, name, typ, P_link, D_link):\n            q_ref_link = q_ref_link.T\n\n            if typ == \"free\":\n                dq = _derivative_quaternion(q_ref_link[:, :4], sys.dt)\n                qd_ref = jnp.hstack((dq, _derivative(q_ref_link[:, 4:], sys.dt)))\n            elif typ == \"spherical\":\n                qd_ref = _derivative_quaternion(q_ref_link, sys.dt)\n            else:\n                qd_ref = _derivative(q_ref_link, sys.dt)\n            q_qd_ref[name] = (q_ref_link, qd_ref)\n            P_as_dict[name] = P_link\n            D_as_dict[name] = D_link\n\n        scan_sys(sys, f, \"qlldd\", q_ref.T, sys.link_names, sys.link_types, P, D)\n        return PDControllerState(0, q_qd_ref, P_as_dict, D_as_dict)\n\n    def apply(\n        controller_state: PDControllerState, sys: base.System, state: base.State\n    ) -&gt; jax.Array:\n        taus = jnp.zeros((sys.qd_size()))\n        q_qd_ref = jax.tree_map(\n            lambda arr: jax.lax.dynamic_index_in_dim(\n                arr, controller_state.i, keepdims=False\n            ),\n            controller_state.q_qd_ref,\n        )\n\n        def f(_, idx_map, idx, name, typ, q_curr, qd_curr):\n            nonlocal taus\n\n            if name not in controller_state.q_qd_ref:\n                return\n\n            q_ref, qd_ref = q_qd_ref[name]\n            if typ == \"free\":\n                P_term = jnp.concatenate(\n                    (\n                        _p_control_quaternion(q_curr[:4], q_ref[:4]),\n                        q_ref[4:] - q_curr[4:],\n                    )\n                )\n            elif typ == \"spherical\":\n                P_term = _p_control_quaternion(q_curr, q_ref)\n            elif typ in [\"rx\", \"ry\", \"rz\"]:\n                # q_ref comes from rcmg. Thus, it is already wrapped\n                # TODO: Currently state.q is not wrapped. Change that?\n                P_term = maths.wrap_to_pi(q_ref - maths.wrap_to_pi(q_curr))\n            elif typ in [\"px\", \"py\", \"pz\"]:\n                P_term = q_ref - q_curr\n            elif typ == \"frozen\":\n                return\n            else:\n                raise NotImplementedError(\n                    f\"pd control of joint type {typ} is not yet implemented.\"\n                )\n\n            D_term = qd_ref - qd_curr\n\n            P_link = controller_state.P_gains[name]\n            D_link = controller_state.D_gains[name]\n\n            tau = P_link * P_term + D_link * D_term\n            taus = taus.at[idx_map[\"d\"](idx)].set(tau)\n\n        scan_sys(\n            sys,\n            f,\n            \"lllqd\",\n            list(range(sys.num_links())),\n            sys.link_names,\n            sys.link_types,\n            state.q,\n            state.qd,\n        )\n\n        return controller_state.replace(i=controller_state.i + 1), taus\n\n    return SimpleNamespace(init=init, apply=apply)\n</code></pre>"},{"location":"api/exp_data/","title":"exp_data","text":""},{"location":"api/exp_data/#x_xy.subpkgs.exp_data.exp_data.load_data","title":"<code>load_data(exp_id, motion_start, motion_stop=None, left_padd=0.0, right_padd=0.0, start_for_start=True, stop_for_stop=True)</code>","text":"Source code in <code>x_xy/subpkgs/exp_data/exp_data.py</code> <pre><code>def load_data(\n    exp_id: str,\n    motion_start: str,\n    motion_stop: Optional[str] = None,\n    left_padd: float = 0.0,\n    right_padd: float = 0.0,\n    start_for_start: bool = True,\n    stop_for_stop: bool = True,\n) -&gt; dict:\n    trial_data = joblib.load(_load_file_path(exp_id, \"joblib\"))\n\n    timings = _read_yaml(exp_id)[\"timings\"]\n\n    if motion_stop is None:\n        motion_stop = motion_start\n\n    motions = list(timings.keys())\n    assert motions.index(motion_start) &lt;= motions.index(\n        motion_stop\n    ), f\"starting point motion {motion_start} is after the stopping \"\n    \"point motion {motion_stop}\"\n\n    if motion_start == motion_stop:\n        assert start_for_start and stop_for_stop, \"Empty sequence, stop &lt;= start\"\n\n    t1 = timings[motion_start][\"start\" if start_for_start else \"stop\"] - left_padd\n    # ensure that t1 &gt;= 0\n    t1 = max(t1, 0.0)\n    t2 = timings[motion_stop][\"stop\" if stop_for_stop else \"start\"] + right_padd\n\n    return _crop_sequence(trial_data, 1 / HZ, t1=t1, t2=t2)\n</code></pre>"},{"location":"api/exp_data/#x_xy.subpkgs.exp_data.exp_data.load_sys","title":"<code>load_sys(exp_id, preprocess_sys=None, morph_yaml_key=None, delete_after_morph=None, replace_rxyz_with_rr=False)</code>","text":"Source code in <code>x_xy/subpkgs/exp_data/exp_data.py</code> <pre><code>def load_sys(\n    exp_id: str,\n    preprocess_sys: Optional[Callable] = None,\n    morph_yaml_key: Optional[str] = None,\n    delete_after_morph: Optional[list[str]] = None,\n    replace_rxyz_with_rr: bool = False,\n) -&gt; x_xy.base.System:\n    xml_path = _load_file_path(exp_id, \"xml\")\n    sys = x_xy.io.load_sys_from_xml(xml_path)\n\n    if preprocess_sys is not None:\n        sys = preprocess_sys(sys)\n\n    if replace_rxyz_with_rr:\n        sys = _replace_rxyz_with_rr(sys)\n\n    if morph_yaml_key is not None:\n        new_parents = _read_yaml(exp_id)[\"morph\"][morph_yaml_key]\n        sys = sys_composer.morph_system(sys, new_parents)\n\n    if delete_after_morph is not None:\n        sys = sys_composer.delete_subsystem(sys, delete_after_morph)\n\n    return sys\n</code></pre>"},{"location":"api/kin_sim/","title":"Kinematic Simulation","text":""},{"location":"api/kin_sim/#x_xy.algorithms.generator.build_generator","title":"<code>build_generator(sys, config=RCMG_Config(), setup_fn=lambda , : sys, finalize_fn=lambda , , , : (q, x), randomize_positions=False)</code>","text":"Source code in <code>x_xy/algorithms/generator.py</code> <pre><code>def build_generator(\n    sys: base.System,\n    config: RCMG_Config = RCMG_Config(),\n    setup_fn: SETUP_FN = lambda key, sys: sys,\n    finalize_fn: FINALIZE_FN = lambda key, q, x, sys: (q, x),\n    randomize_positions: bool = False,\n) -&gt; Generator:\n    if config.cor:\n        for i, p in enumerate(sys.link_parents):\n            link_type = sys.link_types[i]\n            if p == -1:\n                assert link_type == \"free\"\n            if link_type == \"free\":\n                assert p == -1\n        sys = sys.replace(\n            link_types=[\"cor\" if typ == \"free\" else typ for typ in sys.link_types]\n        )\n\n    def generator(key: jax.random.PRNGKey) -&gt; PyTree:\n        nonlocal sys\n\n        # modify system - use `pos_min/max` from xml\n        if randomize_positions:\n            key, consume = jax.random.split(key)\n            sys_mod1 = _setup_fn_randomize_positions(consume, sys)\n        else:\n            sys_mod1 = sys\n\n        # modify system - use custom logic\n        key_start, consume = jax.random.split(key)\n        sys_mod2 = setup_fn(consume, sys_mod1)\n\n        # build generalized coordintes vector `q`\n        q_list = []\n\n        def draw_q(key, __, link_type, joint_params):\n            if key is None:\n                key = key_start\n            key, key_t, key_value = jax.random.split(key, 3)\n            draw_fn = _joint_types[link_type].rcmg_draw_fn\n            if draw_fn is None:\n                raise Exception(f\"The joint type {link_type} has no draw fn specified.\")\n            q_link = draw_fn(config, key_t, key_value, joint_params)\n            # even revolute and prismatic joints must be 2d arrays\n            q_link = q_link if q_link.ndim == 2 else q_link[:, None]\n            q_list.append(q_link)\n            return key\n\n        keys = scan_sys(sys_mod2, draw_q, \"ll\", sys.link_types, sys.links.joint_params)\n        # stack of keys; only the last key is unused\n        key = keys[-1]\n\n        q = jnp.concatenate(q_list, axis=1)\n\n        # do forward kinematics\n        x, _ = jax.vmap(forward_kinematics_transforms, (None, 0))(sys_mod2, q)\n\n        return finalize_fn(key, q, x, sys_mod2)\n\n    return generator\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.jcalc.RCMG_Config","title":"<code>RCMG_Config</code>  <code>dataclass</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>@dataclass\nclass RCMG_Config:\n    T: float = 60.0  # length of random motion\n    Ts: float = 0.01  # sampling rate\n    t_min: float = 0.05  # min time between two generated angles\n    t_max: float | TimeDependentFloat = 0.30  # max time ..\n\n    dang_min: float | TimeDependentFloat = 0.1  # minimum angular velocity in rad/s\n    dang_max: float | TimeDependentFloat = 3.0  # maximum angular velocity in rad/s\n\n    # minimum angular velocity of euler angles used for `free and spherical joints`\n    dang_min_free_spherical: float | TimeDependentFloat = 0.1\n    dang_max_free_spherical: float | TimeDependentFloat = 3.0\n\n    # max min allowed actual delta values in radians\n    delta_ang_min: float | TimeDependentFloat = 0.0\n    delta_ang_max: float | TimeDependentFloat = 2 * jnp.pi\n    delta_ang_min_free_spherical: float | TimeDependentFloat = 0.0\n    delta_ang_max_free_spherical: float | TimeDependentFloat = 2 * jnp.pi\n\n    dpos_min: float | TimeDependentFloat = 0.001  # speed of translation\n    dpos_max: float | TimeDependentFloat = 0.7\n    pos_min: float | TimeDependentFloat = -2.5\n    pos_max: float | TimeDependentFloat = +2.5\n\n    # used by both `random_angle_*` and `random_pos_*`\n    # only used if `randomized_interpolation` is set\n    cdf_bins_min: int = 5\n    # by default equal to `cdf_bins_min`\n    cdf_bins_max: Optional[int] = None\n\n    # flags\n    randomized_interpolation_angle: bool = False\n    randomized_interpolation_position: bool = False\n    interpolation_method: str = \"cosine\"\n    range_of_motion_hinge: bool = True\n    range_of_motion_hinge_method: str = \"uniform\"\n\n    # initial value of joints\n    ang0_min: float = -jnp.pi\n    ang0_max: float = jnp.pi\n    pos0_min: float = 0.0\n    pos0_max: float = 0.0\n\n    # cor (center of rotation) custom fields\n    cor: bool = False\n    cor_t_min: float = 0.2\n    cor_t_max: float | TimeDependentFloat = 2.0\n    cor_dpos_min: float | TimeDependentFloat = 0.00001\n    cor_dpos_max: float | TimeDependentFloat = 0.5\n    cor_pos_min: float | TimeDependentFloat = -0.4\n    cor_pos_max: float | TimeDependentFloat = 0.4\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.jcalc.concat_configs","title":"<code>concat_configs(configs, boundaries)</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>def concat_configs(configs: list[RCMG_Config], boundaries: list[float]) -&gt; RCMG_Config:\n    assert len(configs) == (\n        len(boundaries) + 1\n    ), \"length of `boundaries` should be one less than length of `configs`\"\n    boundaries = jnp.array(boundaries, dtype=float)\n\n    def new_value(field: str):\n        scalar_options = jnp.array([getattr(c, field) for c in configs])\n\n        def scalar(t):\n            return jax.lax.dynamic_index_in_dim(\n                scalar_options, _find_interval(t, boundaries), keepdims=False\n            )\n\n        return scalar\n\n    hints = get_type_hints(RCMG_Config())\n    attrs = RCMG_Config().__dict__\n    is_time_dependent_field = lambda key: hints[key] == (float | TimeDependentFloat)\n    time_dependent_fields = [key for key in attrs if is_time_dependent_field(key)]\n    time_independent_fields = [key for key in attrs if not is_time_dependent_field(key)]\n\n    for time_dep_field in time_independent_fields:\n        field_values = set([getattr(config, time_dep_field) for config in configs])\n        assert (\n            len(field_values) == 1\n        ), f\"RCMG_Config.{time_dep_field}={field_values}. Should be one unique value..\"\n\n    changes = {field: new_value(field) for field in time_dependent_fields}\n    return replace(configs[0], **changes)\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.batch_generator","title":"<code>batch_generator(generators, batchsizes=1, stochastic=False)</code>","text":"<p>Create a large generator by stacking multiple generators lazily. NOTE: If <code>stochastic</code> then <code>batchsizes</code> must be a single integer.</p> Source code in <code>x_xy/algorithms/generator.py</code> <pre><code>def batch_generator(\n    generators: Generator | list[Generator],\n    batchsizes: int | list[int] = 1,\n    stochastic: bool = False,\n) -&gt; Generator:\n\"\"\"Create a large generator by stacking multiple generators lazily.\n    NOTE: If `stochastic` then `batchsizes` must be a single integer.\n    \"\"\"\n    if not isinstance(generators, list):\n        # test if generator is already batched, then this is a no-op\n        key = jax.random.PRNGKey(0)\n        X, y = generators(key)\n        if tree_utils.tree_ndim(X) &gt; 2:\n            return generators\n\n    generators = utils.to_list(generators)\n\n    if stochastic:\n        assert isinstance(batchsizes, int)\n        bs_total = batchsizes\n        pmap, vmap = utils.distribute_batchsize(bs_total)\n    else:\n        batchsizes = utils.to_list(batchsizes)\n        assert len(generators) == len(batchsizes)\n\n        batch_arr_nonstoch = _build_batch_matrix(batchsizes)\n        bs_total = len(batch_arr_nonstoch)\n        pmap, vmap = utils.distribute_batchsize(bs_total)\n        batch_arr_nonstoch = batch_arr_nonstoch.reshape((pmap, vmap))\n\n    pmap_trafo = jax.pmap\n    # single GPU node, then do jit + vmap instead of pmap\n    # this allows e.g. better NAN debugging capabilities\n    if pmap == 1:\n        pmap_trafo = lambda f: jax.jit(jax.vmap(f))\n\n    @pmap_trafo\n    @jax.vmap\n    def _generator(key, which_gen: int):\n        return jax.lax.switch(which_gen, generators, key)\n\n    def generator(key):\n        if stochastic:\n            key, consume = jax.random.split(key)\n            batch_arr = jax.random.choice(\n                consume, jnp.arange(len(generators)), shape=(pmap, vmap)\n            )\n        else:\n            batch_arr = batch_arr_nonstoch\n\n        pmap_vmap_keys = jax.random.split(key, bs_total).reshape((pmap, vmap, 2))\n        data = _generator(pmap_vmap_keys, batch_arr)\n\n        # merge pmap and vmap axis\n        data = utils.merge_batchsize(data, pmap, vmap)\n\n        return data\n\n    return generator\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.offline_generator","title":"<code>offline_generator(generators, sizes, batchsize, shuffle=True, drop_last=True, seed=1, store_on_cpu=True)</code>","text":"<p>Eagerly create a large precomputed generator by calling multiple generators and stacking their output.</p> Source code in <code>x_xy/algorithms/generator.py</code> <pre><code>def offline_generator(\n    generators: Generator | list[Generator],\n    sizes: int | list[int],\n    batchsize: int,\n    shuffle: bool = True,\n    drop_last: bool = True,\n    seed: int = 1,\n    store_on_cpu: bool = True,\n) -&gt; OfflineGenerator:\n\"\"\"Eagerly create a large precomputed generator by calling multiple generators\n    and stacking their output.\"\"\"\n    assert drop_last, \"Not `drop_last` is currently not implemented.\"\n    generators, sizes = utils.to_list(generators), utils.to_list(sizes)\n    assert len(generators) == len(sizes)\n\n    key = jax.random.PRNGKey(seed)\n    data = []\n    for gen, size in tqdm(zip(generators, sizes), desc=\"offline generator\"):\n        key, consume = jax.random.split(key)\n        sample = batch_generator(gen, size)(consume)\n        if store_on_cpu:\n            sample = jax.device_put(sample, jax.devices(\"cpu\")[0])\n        data.extend([jax.tree_map(lambda a: a[i], sample) for i in range(size)])\n\n    N, i = len(data) // batchsize, 0\n    random.seed(seed)\n\n    def generator(key: jax.Array):\n        nonlocal i\n        del key\n        if shuffle and i == 0:\n            random.shuffle(data)\n\n        start, stop = i * batchsize, (i + 1) * batchsize\n        batch = tree_batch(data[start:stop], backend=\"jax\")\n        i = (i + 1) % N\n        return batch\n\n    return generator\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.forward_kinematics","title":"<code>forward_kinematics(sys, state)</code>","text":"<p>Perform forward kinematics in system. - Updates <code>transform</code> and <code>transform2</code> in <code>sys</code> - Updates <code>x</code> in <code>state</code></p> Source code in <code>x_xy/algorithms/kinematics.py</code> <pre><code>def forward_kinematics(\n    sys: base.System, state: base.State\n) -&gt; Tuple[base.System, base.State]:\n\"\"\"Perform forward kinematics in system.\n    - Updates `transform` and `transform2` in `sys`\n    - Updates `x` in `state`\n    \"\"\"\n    x, sys = forward_kinematics_transforms(sys, state.q)\n    state = state.replace(x=x)\n    return sys, state\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.make_normalizer_from_generator","title":"<code>make_normalizer_from_generator(generator, approx_with_large_batchsize=512)</code>","text":"<p><code>generator</code> is expected to return <code>X, y</code>. Then, this function returns a pure function that normalizes <code>X</code>.</p> Source code in <code>x_xy/algorithms/generator.py</code> <pre><code>def make_normalizer_from_generator(\n    generator: Generator, approx_with_large_batchsize: int = 512\n) -&gt; Normalizer:\n\"\"\"`generator` is expected to return `X, y`. Then, this function returns a pure\n    function that normalizes `X`.\"\"\"\n    # batch it if it isn't already\n    generator = batch_generator(generator)\n\n    # probe generator for its batchsize\n    X, _ = generator(KEY)\n    bs = tree_utils.tree_shape(X)\n\n    # how often do we have to query the generator\n    number_of_gen_calls = math.ceil(approx_with_large_batchsize / bs)\n\n    Xs, key = [], KEY\n    for _ in range(number_of_gen_calls):\n        key, consume = jax.random.split(key)\n        Xs.append(generator(consume)[0])\n    Xs = tree_utils.tree_batch(Xs, True, \"jax\")\n    # permute 0-th axis, since batchsize of generator might be larger than\n    # `approx_with_large_batchsize`, then we would not get a representative\n    # subsample otherwise\n    Xs = jax.tree_map(lambda arr: jax.random.permutation(KEY_PERMUTATION, arr), Xs)\n    Xs = tree_utils.tree_slice(Xs, start=0, slice_size=approx_with_large_batchsize)\n\n    # obtain statistics\n    mean = jax.tree_map(lambda arr: jnp.mean(arr, axis=(0, 1)), Xs)\n    std = jax.tree_map(lambda arr: jnp.std(arr, axis=(0, 1)), Xs)\n\n    eps = 1e-8\n\n    def normalizer(X):\n        return jax.tree_map(lambda a, b, c: (a - b) / (c + eps), X, mean, std)\n\n    return normalizer\n</code></pre>"},{"location":"api/maths/","title":"x_xy.maths","text":""},{"location":"api/maths/#x_xy.maths.quat.quat_mul","title":"<code>quat_mul(u, v)</code>","text":"<p>Multiplies two quaternions.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4),(4)-&gt;(4)\")\ndef quat_mul(u: jnp.ndarray, v: jnp.ndarray) -&gt; jnp.ndarray:\n    \"Multiplies two quaternions.\"\n    q = jnp.array(\n        [\n            u[0] * v[0] - u[1] * v[1] - u[2] * v[2] - u[3] * v[3],\n            u[0] * v[1] + u[1] * v[0] + u[2] * v[3] - u[3] * v[2],\n            u[0] * v[2] - u[1] * v[3] + u[2] * v[0] + u[3] * v[1],\n            u[0] * v[3] + u[1] * v[2] - u[2] * v[1] + u[3] * v[0],\n        ]\n    )\n    return q\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_inv","title":"<code>quat_inv(q)</code>","text":"<p>Calculates the inverse of quaternion q.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_inv(q: jnp.ndarray) -&gt; jnp.ndarray:\n    \"Calculates the inverse of quaternion q.\"\n    return q * jnp.array([1.0, -1, -1, -1])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_random","title":"<code>quat_random(key, batch_shape=(), maxval=jnp.pi)</code>","text":"<p>Provides a random unit quaternion, sampled uniformly</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_random(\n    key: jrand.PRNGKey, batch_shape: tuple = (), maxval: float = jnp.pi\n) -&gt; jax.Array:\n\"\"\"Provides a random *unit* quaternion, sampled uniformly\"\"\"\n    shape = batch_shape + (4,)\n    qs = safe_normalize(jrand.normal(key, shape))\n\n    def _scale_angle():\n        axis, angle = quat_to_rot_axis(qs)\n        angle_scaled = angle * maxval / jnp.pi\n        return quat_rot_axis(axis, angle_scaled)\n\n    return jax.lax.cond(maxval == jnp.pi, lambda: qs, _scale_angle)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_rot_axis","title":"<code>quat_rot_axis(axis, angle)</code>","text":"<p>Construct a unit quaternion that describes rotating around <code>axis</code> by <code>angle</code> (radians).</p> <p>This is the interpretation of rotating the vector and not the frame. For the interpretation of rotating the frame and not the vector, you should use angle -&gt; -angle. NOTE: Usually, we actually want the second interpretation. Think about it, we use quaternions to re-express vectors in other frames. But the vectors stay the same. We only transform them to a common frames.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3),()-&gt;(4)\")\ndef quat_rot_axis(axis: jnp.ndarray, angle: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Construct a *unit* quaternion that describes rotating around\n    `axis` by `angle` (radians).\n\n    This is the interpretation of rotating the vector and *not*\n    the frame.\n    For the interpretation of rotating the frame and *not* the\n    vector, you should use angle -&gt; -angle.\n    NOTE: Usually, we actually want the second interpretation. Think about it,\n    we use quaternions to re-express vectors in other frames. But the\n    vectors stay the same. We only transform them to a common frames.\n    \"\"\"\n    assert axis.shape == (3,)\n    assert angle.shape == ()\n\n    axis = safe_normalize(axis)\n    # NOTE: CONVENTION\n    # 23.04.23\n    # this fixes the issue of prismatic joints being inverted w.r.t.\n    # gravity vector.\n    # The reason is that it inverts the way how revolute joints behave\n    # Such that prismatic joints work by inverting gravity\n    angle *= -1.0\n    s, c = jnp.sin(angle / 2), jnp.cos(angle / 2)\n    return jnp.array([c, *(axis * s)])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_rot_axis","title":"<code>quat_to_rot_axis(q)</code>","text":"<p>Extract unit-axis and angle from quaternion <code>q</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3),()\")\ndef quat_to_rot_axis(q):\n    \"Extract unit-axis and angle from quaternion `q`.\"\n    angle = quat_angle(q)\n    # NOTE: CONVENTION\n    angle *= -1.0\n    axis = safe_normalize(q[1:])\n    return axis, angle\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_euler","title":"<code>quat_euler(angles, intrinsic=True, convention='zyx')</code>","text":"<p>Construct a unit quaternion from Euler angles (radians).</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_euler(angles, intrinsic=True, convention=\"zyx\"):\n    \"Construct a *unit* quaternion from Euler angles (radians).\"\n\n    @partial(jnp.vectorize, signature=\"(3)-&gt;(4)\")\n    def _quat_euler(angles):\n        xunit = jnp.array([1.0, 0.0, 0.0])\n        yunit = jnp.array([0.0, 1.0, 0.0])\n        zunit = jnp.array([0.0, 0.0, 1.0])\n\n        axes_map = {\n            \"x\": xunit,\n            \"y\": yunit,\n            \"z\": zunit,\n        }\n\n        q1 = quat_rot_axis(axes_map[convention[0]], angles[0])\n        q2 = quat_rot_axis(axes_map[convention[1]], angles[1])\n        q3 = quat_rot_axis(axes_map[convention[2]], angles[2])\n\n        if intrinsic:\n            return quat_mul(q3, quat_mul(q2, q1))\n        else:\n            return quat_mul(q1, quat_mul(q2, q3))\n\n    return _quat_euler(angles)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_euler","title":"<code>quat_to_euler(q)</code>","text":"<p>Converts quaternions to euler rotations in radians.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3)\")\ndef quat_to_euler(q: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts quaternions to euler rotations in radians.\"\"\"\n    # this follows the Tait-Bryan intrinsic rotation formalism: x-y'-z''\n\n    # NOTE: CONVENTION\n    q = quat_inv(q)\n\n    z = jnp.arctan2(\n        -2 * q[1] * q[2] + 2 * q[0] * q[3],\n        q[1] * q[1] + q[0] * q[0] - q[3] * q[3] - q[2] * q[2],\n    )\n    # TODO: Investigate why quaternions go so big we need to clip.\n    y = safe_arcsin(jnp.clip(2 * q[1] * q[3] + 2 * q[0] * q[2], -1.0, 1.0))\n    x = jnp.arctan2(\n        -2 * q[2] * q[3] + 2 * q[0] * q[1],\n        q[3] * q[3] - q[2] * q[2] - q[1] * q[1] + q[0] * q[0],\n    )\n\n    return jnp.array([x, y, z])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_from_3x3","title":"<code>quat_from_3x3(m)</code>","text":"<p>Converts 3x3 rotation matrix to unit quaternion.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3,3)-&gt;(4)\")\ndef quat_from_3x3(m: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts 3x3 rotation matrix to *unit* quaternion.\"\"\"\n    w = jnp.sqrt(1 + m[0, 0] + m[1, 1] + m[2, 2]) / 2.0\n    x = (m[2][1] - m[1][2]) / (w * 4)\n    y = (m[0][2] - m[2][0]) / (w * 4)\n    z = (m[1][0] - m[0][1]) / (w * 4)\n    return jnp.array([w, x, y, z])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_3x3","title":"<code>quat_to_3x3(q)</code>","text":"<p>Converts unit quaternion to 3x3 rotation matrix.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3,3)\")\ndef quat_to_3x3(q: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts *unit* quaternion to 3x3 rotation matrix.\"\"\"\n    d = jnp.dot(q, q)\n    w, x, y, z = q\n    s = 2 / d\n    xs, ys, zs = x * s, y * s, z * s\n    wx, wy, wz = w * xs, w * ys, w * zs\n    xx, xy, xz = x * xs, x * ys, x * zs\n    yy, yz, zz = y * ys, y * zs, z * zs\n\n    return jnp.array(\n        [\n            jnp.array([1 - (yy + zz), xy - wz, xz + wy]),\n            jnp.array([xy + wz, 1 - (xx + zz), yz - wx]),\n            jnp.array([xz - wy, yz + wx, 1 - (xx + yy)]),\n        ]\n    )\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.rotate","title":"<code>rotate(vector, quat)</code>","text":"<p>Rotates a vector <code>vector</code> by a unit quaternion <code>quat</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3),(4)-&gt;(3)\")\ndef rotate(vector: jnp.ndarray, quat: jnp.ndarray):\n\"\"\"Rotates a vector `vector` by a *unit* quaternion `quat`.\"\"\"\n    qvec = jnp.array([0, *vector])\n    return rotate_quat(qvec, quat)[1:4]\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.rotate_quat","title":"<code>rotate_quat(q, quat)</code>","text":"<p>Rotate quaternion <code>q</code> by <code>quat</code></p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def rotate_quat(q: jax.Array, quat: jax.Array):\n    \"Rotate quaternion `q` by `quat`\"\n    return quat_mul(quat, quat_mul(q, quat_inv(quat)))\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.angle_error","title":"<code>angle_error(q, qhat)</code>","text":"<p>Angle in radians between <code>q</code> and <code>qhat</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def angle_error(q, qhat):\n    \"Angle in radians between `q` and `qhat`.\"\n    return jnp.abs(quat_angle(quat_mul(quat_inv(q), qhat)))\n</code></pre>"},{"location":"api/maths/#x_xy.maths.safe.safe_normalize","title":"<code>safe_normalize(x)</code>","text":"<p>Execution- and Grad-safe for x=0.0. Normalizes along last axis.</p> Source code in <code>x_xy/maths/safe.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(k)-&gt;(k)\")\ndef safe_normalize(x):\n\"\"\"Execution- and Grad-safe for x=0.0. Normalizes along last axis.\"\"\"\n    assert x.ndim == 1\n\n    is_zero = jnp.allclose(x, 0.0)\n    return jax.lax.cond(\n        is_zero,\n        lambda x: jnp.zeros_like(x),\n        lambda x: x / jnp.where(is_zero, 1.0, safe_norm(x)),\n        x,\n    )\n</code></pre>"},{"location":"api/maths/#x_xy.maths.basic.wrap_to_pi","title":"<code>wrap_to_pi(phi)</code>","text":"<p>Wraps angle <code>phi</code> (radians) to interval [-pi, pi].</p> Source code in <code>x_xy/maths/basic.py</code> <pre><code>def wrap_to_pi(phi):\n    \"Wraps angle `phi` (radians) to interval [-pi, pi].\"\n    return (phi + jnp.pi) % (2 * jnp.pi) - jnp.pi\n</code></pre>"},{"location":"api/register/","title":"Register New Joint Types","text":""},{"location":"api/register/#x_xy.algorithms.jcalc.register_new_joint_type","title":"<code>register_new_joint_type(joint_type, joint_model, q_width, qd_width=None)</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>def register_new_joint_type(\n    joint_type: str,\n    joint_model: JointModel,\n    q_width: int,\n    qd_width: Optional[int] = None,\n):\n    if qd_width is None:\n        qd_width = q_width\n\n    assert len(joint_model.motion) == qd_width\n    assert joint_type not in _joint_types, \"already exists\"\n    _joint_types.update({joint_type: joint_model})\n    base.Q_WIDTHS.update({joint_type: q_width})\n    base.QD_WIDTHS.update({joint_type: qd_width})\n</code></pre>"},{"location":"api/register/#x_xy.algorithms.jcalc.JointModel","title":"<code>JointModel</code>  <code>dataclass</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>@dataclass\nclass JointModel:\n    # (q, params) -&gt; Transform\n    transform: Callable[[jax.Array, jax.Array], base.Transform]\n    # len(motion) == len(qd)\n    motion: list[base.Motion] = field(default_factory=lambda: [])\n    # (config, key_t, key_value, params) -&gt; jax.Array\n    rcmg_draw_fn: Optional[DRAW_FN] = None\n</code></pre>"},{"location":"api/register/#x_xy.base.update_n_joint_params","title":"<code>update_n_joint_params(n_joint_params)</code>","text":"Source code in <code>x_xy/base.py</code> <pre><code>def update_n_joint_params(n_joint_params: int) -&gt; None:\n    global _N_JOINT_PARAMS\n    _N_JOINT_PARAMS = n_joint_params\n</code></pre>"},{"location":"api/rendering/","title":"Rendering","text":""},{"location":"api/rendering/#x_xy.render.render.render_frames","title":"<code>render_frames(sys, xs, show_pbar=True, **kwargs)</code>","text":"<p>Render frames from system and trajectory of maximal coordinates <code>xs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System to render.</p> required <code>xs</code> <code>Transform | list[Transform]</code> <p>Single or time-series</p> required <code>show_pbar</code> <code>bool</code> <p>Whether or not to show a progress bar.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>list[np.ndarray]: Stacked rendered frames. Length == len(xs).</p> Source code in <code>x_xy/render/render.py</code> <pre><code>def render_frames(\n    sys: base.System,\n    xs: base.Transform | list[base.Transform],\n    show_pbar: bool = True,\n    **kwargs,\n) -&gt; list[np.ndarray]:\n\"\"\"Render frames from system and trajectory of maximal coordinates `xs`.\n\n    Args:\n        sys (base.System): System to render.\n        xs (base.Transform | list[base.Transform]): Single or time-series\n        of maximal coordinates `xs`.\n        show_pbar (bool, optional): Whether or not to show a progress bar.\n        Defaults to True.\n\n    Returns:\n        list[np.ndarray]: Stacked rendered frames. Length == len(xs).\n    \"\"\"\n    xs = x_xy.utils.to_list(xs)\n\n    n_links = sys.num_links()\n\n    def data_check(x):\n        assert (\n            x.pos.ndim == x.rot.ndim == 2\n        ), f\"Expected shape = (n_links, 3/4). Got pos.shape{x.pos.shape}, \"\n        \"rot.shape={x.rot.shape}\"\n        assert (\n            x.pos.shape[0] == x.rot.shape[0] == n_links\n        ), \"Number of links does not match\"\n\n    for x in xs:\n        data_check(x)\n\n    scene = _init_vispy_scene(sys, **kwargs)\n    frames = []\n    for x in tqdm.tqdm(xs, \"Rendering frames..\", disable=not show_pbar):\n        scene.update(x)\n        frames.append(scene.render())\n    return frames\n</code></pre>"},{"location":"api/rendering/#x_xy.render.render.probe","title":"<code>probe(sys, **kwargs)</code>","text":"Source code in <code>x_xy/render/render.py</code> <pre><code>def probe(sys, **kwargs):\n    state = base.State.create(sys)\n    _, state = x_xy.forward_kinematics(sys, state)\n    return gui(sys, state.x, **kwargs)\n</code></pre>"},{"location":"api/rendering/#x_xy.render.render.gui","title":"<code>gui(sys, x, fps=50, show_fps=False, **kwargs)</code>","text":"<p>Open an interactive Window that plays back the pre-computed trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>scene</code> <code>VispyScene</code> <p>Scene used for rendering.</p> required <code>x</code> <code>Transform</code> <p>Pre-computed trajectory.</p> required <code>timestep</code> <code>float</code> <p>Timedelta between Transforms.</p> required <code>fps</code> <code>int</code> <p>Frame-rate. Defaults to 50.</p> <code>50</code> Source code in <code>x_xy/render/render.py</code> <pre><code>def gui(\n    sys: base.System,\n    x: base.Transform,\n    fps: int = 50,\n    show_fps: bool = False,\n    **kwargs,\n):\n\"\"\"Open an interactive Window that plays back the pre-computed trajectory.\n\n    Args:\n        scene (VispyScene): Scene used for rendering.\n        x (base.Transform): Pre-computed trajectory.\n        timestep (float): Timedelta between Transforms.\n        fps (int, optional): Frame-rate. Defaults to 50.\n    \"\"\"\n    if tree_utils.tree_ndim(x) == 2:\n        x = x.batch()\n\n    window = Window(sys, x, fps, show_fps, **kwargs)\n    window.open()\n    return window._scene.canvas\n</code></pre>"},{"location":"api/rendering/#x_xy.render.render.animate","title":"<code>animate(path, sys, xs, fps=50, fmt=None, verbose=True, show_pbar=True, **kwargs)</code>","text":"<p>Make animation from system and trajectory of maximal coordinates. <code>xs</code> is either a single base.Transform object for images or a Sequence of base.Transform objects for a video format. The desired output format can be either inferred implicitely from the extension of <code>path</code> or set explicitely using the <code>fmt</code> parameter. Mismatch between the two is an error.</p> Source code in <code>x_xy/render/render.py</code> <pre><code>def animate(\n    path: Union[str, Path],\n    sys: base.System,\n    xs: base.Transform | Sequence[base.Transform],\n    fps: int = 50,\n    fmt: Optional[str] = None,\n    verbose: bool = True,\n    show_pbar: bool = True,\n    **kwargs,\n):\n\"\"\"\n    Make animation from system and trajectory of maximal coordinates. `xs` is either\n    a single base.Transform object for images or a Sequence of base.Transform objects\n    for a video format. The desired output format can be either inferred implicitely\n    from the extension of `path` or set explicitely using the `fmt` parameter. Mismatch\n    between the two is an error.\n    \"\"\"\n    path = Path(path)\n    file_fmt = _infer_extension_from_path(path)\n\n    if file_fmt is not None and fmt is not None:\n        assert (\n            file_fmt == fmt.lower()\n        ), f\"\"\"The chosen filename `{path.name}` and required fmt `{fmt}`\n        are inconsistent.\"\"\"\n    elif file_fmt is None and fmt is not None:\n        path = path.with_suffix(\".\" + fmt)\n    elif fmt is None and file_fmt is not None:\n        fmt = file_fmt\n    else:\n        raise ValueError(\"neither fmt nor path extension given, can't infer format\")\n\n    scene = _init_vispy_scene(sys, **kwargs)\n\n    n_links = sys.num_links()\n\n    def data_check(x):\n        assert (\n            x.pos.ndim == x.rot.ndim == 2\n        ), f\"Expected shape = (n_links, 3/4). Got pos.shape{x.pos.shape}, \"\n        \"rot.shape={x.rot.shape}\"\n        assert (\n            x.pos.shape[0] == x.rot.shape[0] == n_links\n        ), \"Number of links does not match\"\n\n    if fmt in [\"jpg\", \"png\"]:\n        # image fmts\n\n        if isinstance(xs, base.Transform):\n            x = xs\n        else:\n            x = xs[0]\n\n        data_check(x)\n\n        _animate_image(path, x, scene, fmt=fmt, verbose=verbose)\n\n    elif fmt in [\"mp4\", \"gif\"]:\n        # video fmts\n\n        if isinstance(xs, base.Transform):\n            xs = [xs]\n        else:\n            xs = list(xs)\n\n        for x in xs:\n            data_check(x)\n\n        N = len(xs)\n        _, step = _parse_timestep(sys.dt, fps, N)\n\n        _animate_video(\n            path, xs, scene, fps, N, step, show_pbar=show_pbar, fmt=fmt, verbose=verbose\n        )\n    else:\n        raise ValueError(f\"fmt {fmt} is not implement\")\n</code></pre>"},{"location":"api/sensors/","title":"Sensors","text":""},{"location":"api/sensors/#x_xy.algorithms.sensors.imu","title":"<code>imu(xs, gravity, dt, key=None, noisy=False, smoothen_degree=None, delay=None, random_s2s_ori=None, quasi_physical=False)</code>","text":"<p>Simulates a 6D IMU, <code>xs</code> should be Transforms from eps-to-imu. NOTE: <code>smoothen_degree</code> is used as window size for moving average. NOTE: If <code>smoothen_degree</code> is given, and <code>delay</code> is not, then delay is chosen such moving average window is delayed to just be causal.</p> Source code in <code>x_xy/algorithms/sensors.py</code> <pre><code>def imu(\n    xs: base.Transform,\n    gravity: jax.Array,\n    dt: float,\n    key: Optional[jax.random.PRNGKey] = None,\n    noisy: bool = False,\n    smoothen_degree: Optional[int] = None,\n    delay: Optional[int] = None,\n    random_s2s_ori: Optional[float] = None,\n    quasi_physical: bool = False,\n) -&gt; dict:\n\"\"\"Simulates a 6D IMU, `xs` should be Transforms from eps-to-imu.\n    NOTE: `smoothen_degree` is used as window size for moving average.\n    NOTE: If `smoothen_degree` is given, and `delay` is not, then delay is chosen\n    such moving average window is delayed to just be causal.\n    \"\"\"\n    assert xs.ndim() == 2\n\n    if random_s2s_ori is not None:\n        assert key is not None, \"`random_s2s_ori` requires a random seed via `key`\"\n        # `xs` are now from eps-to-segment, so add another final rotation from\n        # segment-to-sensor where this transform is only rotational\n        key, consume = jax.random.split(key)\n        xs_s2s = base.Transform.create(\n            rot=maths.quat_random(consume, maxval=random_s2s_ori)\n        )\n        xs = jax.vmap(algebra.transform_mul, in_axes=(None, 0))(xs_s2s, xs)\n\n    if quasi_physical:\n        xs = _quasi_physical_simulation(xs, dt)\n\n    measurements = {\"acc\": accelerometer(xs, gravity, dt), \"gyr\": gyroscope(xs.rot, dt)}\n\n    if smoothen_degree is not None:\n        measurements = jax.tree_map(\n            lambda arr: moving_average(arr, smoothen_degree),\n            measurements,\n        )\n\n        # if you low-pass filter the imu measurements through a moving average which\n        # effectively uses future values, then it also makes sense to delay the imu\n        # measurements by this amount such that no future information is used\n        if delay is None:\n            half_window = (smoothen_degree - 1) // 2\n            delay = half_window\n\n    if delay is not None and delay &gt; 0:\n        measurements = jax.tree_map(\n            lambda arr: (jnp.pad(arr, ((delay, 0), (0, 0)))[:-delay]), measurements\n        )\n\n    if noisy:\n        assert key is not None, \"For noisy sensors random seed `key` must be provided.\"\n        measurements = add_noise_bias(key, measurements)\n\n    return measurements\n</code></pre>"},{"location":"api/sensors/#x_xy.algorithms.sensors.rel_pose","title":"<code>rel_pose(sys_scan, xs, sys_xs=None)</code>","text":"<p>Relative pose of the entire system. <code>sys_scan</code> defines the parent-child ordering, relative pose is from child to parent in local coordinates. Bodies that connect to the base are skipped (that would be absolute pose).</p> <p>Parameters:</p> Name Type Description Default <code>sys_scan</code> <code>System</code> <p>System defining parent-child ordering.</p> required <code>xs</code> <code>Transform</code> <p>Body transforms from base to body.</p> required <code>sys_xs</code> <code>System</code> <p>System that defines the stacking order of <code>xs</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Child-to-parent quaternions</p> Source code in <code>x_xy/algorithms/sensors.py</code> <pre><code>def rel_pose(\n    sys_scan: base.System, xs: base.Transform, sys_xs: Optional[base.System] = None\n) -&gt; dict:\n\"\"\"Relative pose of the entire system. `sys_scan` defines the parent-child ordering,\n    relative pose is from child to parent in local coordinates. Bodies that connect\n    to the base are skipped (that would be absolute pose).\n\n    Args:\n        sys_scan (base.System): System defining parent-child ordering.\n        xs (base.Transform): Body transforms from base to body.\n        sys_xs (base.System): System that defines the stacking order of `xs`.\n\n    Returns:\n        dict: Child-to-parent quaternions\n    \"\"\"\n    if sys_xs is None:\n        sys_xs = sys_scan\n\n    if xs.pos.ndim == 3:\n        # swap (n_timesteps, n_links) axes\n        xs = xs.transpose([1, 0, 2])\n\n    assert xs.batch_dim() == sys_xs.num_links()\n\n    qrel = lambda q1, q2: maths.quat_mul(q1, maths.quat_inv(q2))\n\n    y = {}\n\n    def pose_child_to_parent(_, __, name_i: str, p: int):\n        # body connects to base\n        if p == -1:\n            return\n\n        name_p = sys_scan.idx_to_name(p)\n\n        # find the transforms of those named bodies\n        i = sys_xs.name_to_idx(name_i)\n        p = sys_xs.name_to_idx(name_p)\n\n        # get those transforms\n        q1, q2 = xs.take(p).rot, xs.take(i).rot\n\n        y[name_i] = qrel(q1, q2)\n\n    scan_sys(\n        sys_scan, pose_child_to_parent, \"ll\", sys_scan.link_names, sys_scan.link_parents\n    )\n\n    return y\n</code></pre>"},{"location":"api/sim2real/","title":"sim2real","text":""},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.xs_from_raw","title":"<code>xs_from_raw(sys, link_name_pos_rot, t1=0.0, t2=None, eps_frame=None, qinv=True)</code>","text":"<p>Build time-series of maximal coordinates <code>xs</code> from raw position and quaternion trajectory data. This function scans through each link (as defined by <code>sys</code>), looks for the raw data in <code>link_name_pos_rot</code> using the <code>link_name</code> as identifier. It inverts the quaternion if <code>qinv</code>. Then, it creates a <code>Transform</code> that transforms from epsilon (as defined by <code>eps_frame</code>) to the link for each timestep. Finally, it stacks all transforms in order as defined by <code>sys</code> along the 1-th axis. The 0-th axis is time axis.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System which defines ordering of returned <code>xs</code></p> required <code>link_name_pos_rot</code> <code>dict</code> <p>Dictonary of <code>link_name</code> -&gt; {'pos': ..., 'quat': ...}. Obtained, e.g., using <code>process_omc</code>.</p> required <code>t1</code> <code>float</code> <p>Crop time left. Defaults to 0.0.</p> <code>0.0</code> <code>t2</code> <code>Optional[float]</code> <p>Crop time right. Defaults to None.</p> <code>None</code> <code>eps_frame</code> <code>str</code> <p>Move into this segment's frame at time zero as eps frame. Defaults to <code>None</code>. If <code>None</code>: Use root-frame as eps-frame. If 'none': Don't move into a specific eps-frame.</p> <code>None</code> <p>Returns:</p> Type Description <code>Transform</code> <p>x_xy.base.Transform: Time-series of eps-to-link transformations</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def xs_from_raw(\n    sys: x_xy.base.System,\n    link_name_pos_rot: dict,\n    t1: float = 0.0,\n    t2: Optional[float] = None,\n    eps_frame: Optional[str] = None,\n    qinv: bool = True,\n) -&gt; x_xy.base.Transform:\n\"\"\"Build time-series of maximal coordinates `xs` from raw position and\n    quaternion trajectory data. This function scans through each link (as\n    defined by `sys`), looks for the raw data in `link_name_pos_rot` using\n    the `link_name` as identifier. It inverts the quaternion if `qinv`.\n    Then, it creates a `Transform` that transforms from epsilon (as defined\n    by `eps_frame`) to the link for each timestep. Finally, it stacks all\n    transforms in order as defined by `sys` along the 1-th axis. The 0-th\n    axis is time axis.\n\n    Args:\n        sys (x_xy.base.System): System which defines ordering of returned `xs`\n        link_name_pos_rot (dict): Dictonary of `link_name` -&gt;\n            {'pos': ..., 'quat': ...}. Obtained, e.g., using `process_omc`.\n        t1 (float, optional): Crop time left. Defaults to 0.0.\n        t2 (Optional[float], optional): Crop time right. Defaults to None.\n        eps_frame (str, optional): Move into this segment's frame at time zero as\n            eps frame. Defaults to `None`.\n            If `None`: Use root-frame as eps-frame.\n            If 'none': Don't move into a specific eps-frame.\n\n    Returns:\n        x_xy.base.Transform: Time-series of eps-to-link transformations\n    \"\"\"\n\n    if eps_frame == \"none\":\n        warnings.warn(\n            \"`eps_frame` set to `none` might lead to problems with artificial IMUs,\"\n            \" since the gravity vector is assumed to be in positive z-axis in eps-frame\"\n        )\n\n    link_name_pos_rot = _crop_sequence(link_name_pos_rot, sys.dt, t1, t2)\n\n    # determine `eps_frame` transform\n    if eps_frame != \"none\":\n        if eps_frame is None:\n            connect_to_base = []\n            # find link and link name that connects to world\n            for link_name, link_parent in zip(sys.link_names, sys.link_parents):\n                if link_parent == -1:\n                    connect_to_base.append(link_name)\n            assert len(connect_to_base) == 1, (\n                f\"Ambiguous `eps-frame` since multiple links ({connect_to_base})\"\n                \" connect to base.\"\n            )\n            eps_frame = connect_to_base[0]\n        eps = link_name_pos_rot[eps_frame]\n        q_eps = eps[\"quat\"][0]\n        if qinv:\n            q_eps = x_xy.maths.quat_inv(q_eps)\n        t_eps = x_xy.base.Transform(eps[\"pos\"][0], q_eps)\n    else:\n        t_eps = x_xy.base.Transform.zero()\n\n    # build `xs` from optical motion capture data\n    xs = []\n\n    def f(_, __, link_name: str):\n        q, pos = (\n            link_name_pos_rot[link_name][\"quat\"],\n            link_name_pos_rot[link_name][\"pos\"],\n        )\n        if qinv:\n            q = x_xy.maths.quat_inv(q)\n        t = x_xy.base.Transform(pos, q)\n        t = x_xy.algebra.transform_mul(t, x_xy.algebra.transform_inv(t_eps))\n        xs.append(t)\n\n    scan_sys(sys, f, \"l\", sys.link_names)\n\n    # stack and permute such that time-axis is 0-th axis\n    xs = xs[0].batch(*xs[1:])\n    xs = xs.transpose((1, 0, 2))\n    return xs\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.match_xs","title":"<code>match_xs(sys, xs, sys_xs)</code>","text":"<p>Match tranforms <code>xs</code> to subsystem <code>sys</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Smaller system. Every link in <code>sys</code> must be in <code>sys_xs</code>.</p> required <code>xs</code> <code>Transform</code> <p>Transforms of larger system.</p> required <code>sys_xs</code> <code>Transform</code> <p>Larger system.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Transforms of smaller system.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def match_xs(sys: System, xs: Transform, sys_xs: System) -&gt; Transform:\n\"\"\"Match tranforms `xs` to subsystem `sys`.\n\n    Args:\n        sys (System): Smaller system. Every link in `sys` must be in `sys_xs`.\n        xs (Transform): Transforms of larger system.\n        sys_xs (Transform): Larger system.\n\n    Returns:\n        Transform: Transforms of smaller system.\n    \"\"\"\n    _checks_time_series_of_xs(sys_xs, xs)\n\n    # disable warnings temporarily because otherwise it will warn because of the usage\n    # of `eps_frame` = 'none'\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        xs_small = xs_from_raw(\n            sys,\n            {\n                name: {\n                    \"pos\": xs.pos[:, sys_xs.name_to_idx(name)],\n                    \"quat\": xs.rot[:, sys_xs.name_to_idx(name)],\n                }\n                for name in sys_xs.link_names\n            },\n            eps_frame=\"none\",\n            qinv=False,\n        )\n    return xs_small\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.unzip_xs","title":"<code>unzip_xs(sys, xs)</code>","text":"<p>Split eps-to-link transforms into parent-to-child pure translational <code>transform1</code> and pure rotational <code>transform2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Defines scan.tree</p> required <code>xs</code> <code>Transform</code> <p>Eps-to-link transforms</p> required <p>Returns:</p> Type Description <code>Tuple[Transform, Transform]</code> <p>Tuple[Transform, Transform]: transform1, transform2</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def unzip_xs(sys: System, xs: Transform) -&gt; Tuple[Transform, Transform]:\n\"\"\"Split eps-to-link transforms into parent-to-child pure\n    translational `transform1` and pure rotational `transform2`.\n\n    Args:\n        sys (System): Defines scan.tree\n        xs (Transform): Eps-to-link transforms\n\n    Returns:\n        Tuple[Transform, Transform]: transform1, transform2\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    @jax.vmap\n    def _unzip_xs(xs):\n        def f(_, __, i: int, p: int):\n            if p == -1:\n                x_parent_to_link = xs[i]\n            else:\n                x_parent_to_link = algebra.transform_mul(\n                    xs[i], algebra.transform_inv(xs[p])\n                )\n\n            transform1_pos = Transform.create(pos=x_parent_to_link.pos)\n            transform2_rot = Transform.create(rot=x_parent_to_link.rot)\n            return (transform1_pos, transform2_rot)\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_parents)\n\n    return _unzip_xs(xs)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.zip_xs","title":"<code>zip_xs(sys, xs_transform1, xs_transform2)</code>","text":"<p>Performs forward kinematics using <code>transform1</code> and <code>transform2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Defines scan_sys</p> required <code>xs_transform1</code> <code>Transform</code> <p>Applied before <code>transform1</code></p> required <code>xs_transform2</code> <code>Transform</code> <p>Applied after <code>transform2</code></p> required <p>Returns:</p> Type Description <code>Transform</code> <p>x_xy.base.Transform: Time-series of eps-to-link transformations</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def zip_xs(\n    sys: System,\n    xs_transform1: Transform,\n    xs_transform2: Transform,\n) -&gt; Transform:\n\"\"\"Performs forward kinematics using `transform1` and `transform2`.\n\n    Args:\n        sys (x_xy.base.System): Defines scan_sys\n        xs_transform1 (x_xy.base.Transform): Applied before `transform1`\n        xs_transform2 (x_xy.base.Transform): Applied after `transform2`\n\n    Returns:\n        x_xy.base.Transform: Time-series of eps-to-link transformations\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs_transform1)\n    _checks_time_series_of_xs(sys, xs_transform2)\n\n    @jax.vmap\n    def _zip_xs(xs_transform1, xs_transform2):\n        eps_to_l = {-1: x_xy.base.Transform.zero()}\n\n        def f(_, __, i: int, p: int):\n            transform = algebra.transform_mul(xs_transform2[i], xs_transform1[i])\n            eps_to_l[i] = algebra.transform_mul(transform, eps_to_l[p])\n            return eps_to_l[i]\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_parents)\n\n    return _zip_xs(xs_transform1, xs_transform2)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.delete_to_world_pos_rot","title":"<code>delete_to_world_pos_rot(sys, xs)</code>","text":"<p>Replace the transforms of all links that connect to the worldbody by unity transforms.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System only used for structure (in scan_sys).</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of modified transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def delete_to_world_pos_rot(sys: System, xs: Transform) -&gt; Transform:\n\"\"\"Replace the transforms of all links that connect to the worldbody\n    by unity transforms.\n\n    Args:\n        sys (System): System only used for structure (in scan_sys).\n        xs (Transform): Time-series of transforms to be modified.\n\n    Returns:\n        Transform: Time-series of modified transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    zero_trafo = Transform.zero((xs.shape(),))\n    for i, p in enumerate(sys.link_parents):\n        if p == -1:\n            xs = _overwrite_transform_of_link_then_update(sys, xs, zero_trafo, i)\n    return xs\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.randomize_to_world_pos_rot","title":"<code>randomize_to_world_pos_rot(key, sys, xs, config)</code>","text":"<p>Replace the transforms of all links that connect to the worldbody by randomize transforms.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Array</code> <p>PRNG Key.</p> required <code>sys</code> <code>System</code> <p>System only used for structure (in scan_sys).</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <code>config</code> <code>RCMG_Config</code> <p>Defines the randomization.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of modified transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def randomize_to_world_pos_rot(\n    key: jax.Array, sys: System, xs: Transform, config: RCMG_Config\n) -&gt; Transform:\n\"\"\"Replace the transforms of all links that connect to the worldbody\n    by randomize transforms.\n\n    Args:\n        key (jax.Array): PRNG Key.\n        sys (System): System only used for structure (in scan_sys).\n        xs (Transform): Time-series of transforms to be modified.\n        config (RCMG_Config): Defines the randomization.\n\n    Returns:\n        Transform: Time-series of modified transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n    assert sys.link_parents.count(-1) == 1, \"Found multiple connections to world\"\n\n    free_sys_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"free\" joint=\"free\"/&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\n    free_sys = load_sys_from_str(free_sys_str)\n    _, xs_free = build_generator(free_sys, config)(key)\n    xs_free = xs_free.take(free_sys.name_to_idx(\"free\"), axis=1)\n    link_idx_to_world = sys.link_parents.index(-1)\n    return _overwrite_transform_of_link_then_update(sys, xs, xs_free, link_idx_to_world)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.scale_xs","title":"<code>scale_xs(sys, xs, factor, exclude=['px', 'py', 'pz', 'free'])</code>","text":"<p>Increase / decrease transforms by scaling their positional / rotational components based on the systems link type, i.e. the <code>xs</code> should conceptionally be <code>transform2</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System defining structure (for scan_sys)</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <code>factor</code> <code>float</code> <p>Multiplicative factor.</p> required <code>exclude</code> <code>list[str]</code> <p>Skip scaling of transforms if their link_type is one of those. Defaults to [\"px\", \"py\", \"pz\", \"free\"].</p> <code>['px', 'py', 'pz', 'free']</code> <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of scaled transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def scale_xs(\n    sys: System,\n    xs: Transform,\n    factor: float,\n    exclude: list[str] = [\"px\", \"py\", \"pz\", \"free\"],\n) -&gt; Transform:\n\"\"\"Increase / decrease transforms by scaling their positional / rotational\n    components based on the systems link type, i.e. the `xs` should conceptionally\n    be `transform2` objects.\n\n    Args:\n        sys (System): System defining structure (for scan_sys)\n        xs (Transform): Time-series of transforms to be modified.\n        factor (float): Multiplicative factor.\n        exclude (list[str], optional): Skip scaling of transforms if their link_type\n            is one of those. Defaults to [\"px\", \"py\", \"pz\", \"free\"].\n\n    Returns:\n        Transform: Time-series of scaled transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    @jax.vmap\n    def _scale_xs(xs):\n        def f(_, __, i: int, type: str):\n            x_link = xs[i]\n            if type not in exclude:\n                x_link = _scale_transform_based_on_type(x_link, type, factor)\n            return x_link\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_types)\n\n    return _scale_xs(xs)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.project_xs","title":"<code>project_xs(sys, transform2)</code>","text":"<p>Project transforms into the physically feasible subspace as defined by the joints in the system.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def project_xs(sys: System, transform2: Transform) -&gt; Transform:\n\"\"\"Project transforms into the physically feasible subspace as defined by the\n    joints in the system.\"\"\"\n    _checks_time_series_of_xs(sys, transform2)\n\n    _str2idx = {\"x\": 0, \"y\": 1, \"z\": 2}\n\n    @jax.vmap\n    def _project_xs(transform2):\n        def f(_, __, i: int, link_type: str):\n            t = transform2[i]\n            rot, pos = jnp.array([1.0, 0, 0, 0]), jnp.zeros((3,))\n\n            if link_type in [\"rx\", \"ry\", \"rz\"]:\n                angles = maths.quat_to_euler(t.rot)\n                idx = _str2idx[link_type[1]]\n                proj_angles = jnp.zeros((3,)).at[idx].set(angles[idx])\n                rot = maths.euler_to_quat(proj_angles)\n            elif link_type in [\"px\", \"py\", \"pz\"]:\n                idx = _str2idx[link_type[1]]\n                pos = pos.at[idx].set(t.pos[idx])\n            elif link_type == \"spherical\":\n                rot = t.rot\n            elif link_type in [\"p3d\", \"cor\"]:\n                pos = t.pos\n            elif link_type == \"free\":\n                pos, rot = t.pos, t.rot\n            elif link_type in [\"rr\", \"frozen\"]:\n                warnings.warn(\n                    f\"`{link_type}`-joint-types can currently not be projected.\"\n                )\n            else:\n                raise NotImplementedError\n            return Transform(pos=pos, rot=rot)\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_types)\n\n    return _project_xs(transform2)\n</code></pre>"},{"location":"api/state/","title":"State","text":""},{"location":"api/state/#x_xy.base.State","title":"<code>State</code>","text":"<p>The static and dynamic state of a system in minimal and maximal coordinates. Use <code>.create()</code> to create this object.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Array</code> <p>System state in minimal coordinates (equals <code>sys.q_size()</code>)</p> required <code>qd</code> <code>Array</code> <p>System velocity in minimal coordinates (equals <code>sys.qd_size()</code>)</p> required <code>x</code> <p>(Transform): Maximal coordinates of all links. From epsilon-to-link.</p> required <code>mass_mat_inv</code> <code>Array</code> <p>Inverse of the mass matrix. Internal usage.</p> required Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass State(_Base):\n\"\"\"The static and dynamic state of a system in minimal and maximal coordinates.\n    Use `.create()` to create this object.\n\n    Args:\n        q (jax.Array): System state in minimal coordinates (equals `sys.q_size()`)\n        qd (jax.Array): System velocity in minimal coordinates (equals `sys.qd_size()`)\n        x: (Transform): Maximal coordinates of all links. From epsilon-to-link.\n        mass_mat_inv (jax.Array): Inverse of the mass matrix. Internal usage.\n    \"\"\"\n\n    q: jax.Array\n    qd: jax.Array\n    x: Transform\n    mass_mat_inv: jax.Array\n\n    @classmethod\n    def create(\n        cls, sys: System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None\n    ):\n\"\"\"Create state of system.\n\n        Args:\n            sys (System): The system for which to create a state.\n            q (jax.Array, optional): The joint values of the system. Defaults to None.\n            Which then defaults to zeros.\n            qd (jax.Array, optional): The joint velocities of the system.\n            Defaults to None. Which then defaults to zeros.\n\n        Returns:\n            (State): Create State object.\n        \"\"\"\n        # to avoid circular imports\n        from x_xy import scan_sys\n\n        if q is None:\n            q = jnp.zeros((sys.q_size(),))\n\n            # free and spherical joints are not zeros but unit quaternions\n            def replace_by_unit_quat(carry, idx_map, link_typ, link_idx):\n                nonlocal q\n\n                if link_typ == \"spherical\" or link_typ == \"free\":\n                    q_idxs_link = idx_map[\"q\"](link_idx)\n                    q = q.at[q_idxs_link.start].set(1.0)\n\n            scan_sys(\n                sys,\n                replace_by_unit_quat,\n                \"ll\",\n                sys.link_types,\n                list(range(sys.num_links())),\n            )\n\n        if qd is None:\n            qd = jnp.zeros((sys.qd_size(),))\n        x = Transform.zero((sys.num_links(),))\n        return cls(q, qd, x, jnp.diag(jnp.ones((sys.qd_size(),))))\n</code></pre>"},{"location":"api/state/#x_xy.base.State.create","title":"<code>create(sys, q=None, qd=None)</code>  <code>classmethod</code>","text":"<p>Create state of system.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>The system for which to create a state.</p> required <code>q</code> <code>Array</code> <p>The joint values of the system. Defaults to None.</p> <code>None</code> <code>qd</code> <code>Array</code> <p>The joint velocities of the system.</p> <code>None</code> <p>Returns:</p> Type Description <code>State</code> <p>Create State object.</p> Source code in <code>x_xy/base.py</code> <pre><code>@classmethod\ndef create(\n    cls, sys: System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None\n):\n\"\"\"Create state of system.\n\n    Args:\n        sys (System): The system for which to create a state.\n        q (jax.Array, optional): The joint values of the system. Defaults to None.\n        Which then defaults to zeros.\n        qd (jax.Array, optional): The joint velocities of the system.\n        Defaults to None. Which then defaults to zeros.\n\n    Returns:\n        (State): Create State object.\n    \"\"\"\n    # to avoid circular imports\n    from x_xy import scan_sys\n\n    if q is None:\n        q = jnp.zeros((sys.q_size(),))\n\n        # free and spherical joints are not zeros but unit quaternions\n        def replace_by_unit_quat(carry, idx_map, link_typ, link_idx):\n            nonlocal q\n\n            if link_typ == \"spherical\" or link_typ == \"free\":\n                q_idxs_link = idx_map[\"q\"](link_idx)\n                q = q.at[q_idxs_link.start].set(1.0)\n\n        scan_sys(\n            sys,\n            replace_by_unit_quat,\n            \"ll\",\n            sys.link_types,\n            list(range(sys.num_links())),\n        )\n\n    if qd is None:\n        qd = jnp.zeros((sys.qd_size(),))\n    x = Transform.zero((sys.num_links(),))\n    return cls(q, qd, x, jnp.diag(jnp.ones((sys.qd_size(),))))\n</code></pre>"},{"location":"api/sys_composer/","title":"sys_composer","text":""},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.delete_sys.delete_subsystem","title":"<code>delete_subsystem(sys, link_name)</code>","text":"<p>Cut subsystem starting at <code>link_name</code> (inclusive) from tree.</p> Source code in <code>x_xy/subpkgs/sys_composer/delete_sys.py</code> <pre><code>def delete_subsystem(sys: base.System, link_name: str | list[str]) -&gt; base.System:\n    \"Cut subsystem starting at `link_name` (inclusive) from tree.\"\n    if isinstance(link_name, list):\n        for ln in link_name:\n            sys = delete_subsystem(sys, ln)\n        return sys\n\n    assert (\n        link_name in sys.link_names\n    ), f\"link {link_name} not found in {sys.link_names}\"\n\n    subsys = _find_subsystem_indices(sys.link_parents, sys.name_to_idx(link_name))\n    idx_map, keep = _idx_map_and_keepers(sys.link_parents, subsys)\n\n    def take(list):\n        return [ele for i, ele in enumerate(list) if i in keep]\n\n    d, a, ss, sz = [], [], [], []\n\n    def filter_arrays(_, __, damp, arma, stiff, zero, i: int):\n        if i in keep:\n            d.append(damp)\n            a.append(arma)\n            ss.append(stiff)\n            sz.append(zero)\n\n    scan_sys(\n        sys,\n        filter_arrays,\n        \"dddql\",\n        sys.link_damping,\n        sys.link_armature,\n        sys.link_spring_stiffness,\n        sys.link_spring_zeropoint,\n        list(range(sys.num_links())),\n    )\n\n    d, a, ss, sz = map(jnp.concatenate, (d, a, ss, sz))\n\n    new_sys = base.System(\n        _reindex_parent_array(sys.link_parents, subsys),\n        tree_utils.tree_indices(sys.links, jnp.array(keep, dtype=int)),\n        take(sys.link_types),\n        d,\n        a,\n        ss,\n        sz,\n        sys.dt,\n        sys.dynamic_geometries,\n        [\n            geom.replace(link_idx=idx_map[geom.link_idx])\n            for geom in sys.geoms\n            if geom.link_idx in keep\n        ],\n        sys.gravity,\n        sys.integration_method,\n        sys.mass_mat_iters,\n        take(sys.link_names),\n        sys.model_name,\n    )\n\n    return parse_system(new_sys)\n</code></pre>"},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.inject_sys.inject_system","title":"<code>inject_system(sys, sub_sys, at_body=None, prefix='')</code>","text":"<p>Combine two systems into one.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Large system.</p> required <code>sub_sys</code> <code>System</code> <p>Small system that will be included into the large system <code>sys</code>.</p> required <code>at_body</code> <code>Optional[str]</code> <p>Into which body of the large system small system will be included. Defaults to <code>worldbody</code>.</p> <code>None</code> <code>prefix</code> <code>Optional[str]</code> <p>Prefix that is added to body identifiers of small system. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>System</code> <p>base.System: description</p> Source code in <code>x_xy/subpkgs/sys_composer/inject_sys.py</code> <pre><code>def inject_system(\n    sys: base.System,\n    sub_sys: base.System,\n    at_body: Optional[str] = None,\n    prefix: str = \"\",\n) -&gt; base.System:\n\"\"\"Combine two systems into one.\n\n    Args:\n        sys (base.System): Large system.\n        sub_sys (base.System): Small system that will be included into the\n            large system `sys`.\n        at_body (Optional[str], optional): Into which body of the large system\n            small system will be included. Defaults to `worldbody`.\n        prefix (Optional[str], optional): Prefix that is added to body identifiers\n            of small system. Defaults to ''.\n\n    Returns:\n        base.System: _description_\n    \"\"\"\n\n    # give bodies new names if required\n    sub_sys = sub_sys.replace(link_names=[prefix + name for name in sub_sys.link_names])\n\n    # replace parent array\n    if at_body is None:\n        new_world = -1\n    else:\n        new_world = sys.name_to_idx(at_body)\n\n    # append sub_sys at index end and replace sub_sys world with `at_body`\n    N = sys.num_links()\n\n    def new_parent(old_parent: int):\n        if old_parent != -1:\n            return old_parent + N\n        else:\n            return new_world\n\n    sub_sys = sub_sys.replace(\n        link_parents=[new_parent(p) for p in sub_sys.link_parents]\n    )\n\n    # replace link indices of geoms in sub_sys\n    sub_sys = sub_sys.replace(\n        geoms=[\n            geom.replace(link_idx=new_parent(geom.link_idx)) for geom in sub_sys.geoms\n        ]\n    )\n\n    # merge two systems\n    concat = lambda a1, a2: tree_batch([a1, a2], True, \"jax\")\n    combined_sys = base.System(\n        link_parents=sys.link_parents + sub_sys.link_parents,\n        links=concat(sys.links, sub_sys.links),\n        link_types=sys.link_types + sub_sys.link_types,\n        link_damping=concat(sys.link_damping, sub_sys.link_damping),\n        link_armature=concat(sys.link_armature, sub_sys.link_armature),\n        link_spring_stiffness=concat(\n            sys.link_spring_stiffness, sub_sys.link_spring_stiffness\n        ),\n        link_spring_zeropoint=concat(\n            sys.link_spring_zeropoint, sub_sys.link_spring_zeropoint\n        ),\n        dt=sys.dt,\n        dynamic_geometries=sys.dynamic_geometries,\n        geoms=sys.geoms + sub_sys.geoms,\n        gravity=sys.gravity,\n        integration_method=sys.integration_method,\n        mass_mat_iters=sys.mass_mat_iters,\n        link_names=sys.link_names + sub_sys.link_names,\n        model_name=sys.model_name,\n    )\n\n    return parse_system(combined_sys)\n</code></pre>"},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.morph_sys.morph_system","title":"<code>morph_system(sys, new_parents, prefix='')</code>","text":"<p>Re-orders the graph underlying the system. Returns a new system.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System to be modified.</p> required <code>new_parents</code> <code>list[int]</code> <p>Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system.</p> required <code>prefix</code> <code>str</code> <p>Prefix to prepend to all link names.</p> <code>''</code> <p>Returns:</p> Type Description <code>System</code> <p>base.System: Modified system.</p> Source code in <code>x_xy/subpkgs/sys_composer/morph_sys.py</code> <pre><code>def morph_system(\n    sys: base.System, new_parents: list[int | str], prefix: str = \"\"\n) -&gt; base.System:\n\"\"\"Re-orders the graph underlying the system. Returns a new system.\n\n    Args:\n        sys (base.System): System to be modified.\n        new_parents (list[int]): Let the i-th entry have value j. Then, after morphing\n            the system the system will be such that the link corresponding to the i-th\n            link in the old system will have as parent the link corresponding to the\n            j-th link in the old system.\n        prefix (str): Prefix to prepend to all link names.\n\n    Returns:\n        base.System: Modified system.\n    \"\"\"\n\n    structure, permutation, new_parent_array = identify_system(sys, new_parents)\n\n    link_idx_old_world_old_indices = sys.link_parents.index(-1)\n    d, a, ss, sz = _per_link_arrays(sys)\n\n    def _get_joint_properties_of(i1: int, i2: int):\n        return JointProperties(\n            sys.links.transform1[i1],\n            sys.links.pos_min[i1],\n            sys.links.pos_max[i1],\n            sys.link_types[i2],\n            d[i2],\n            a[i2],\n            ss[i2],\n            sz[i2],\n        )\n\n    joint_properties = []\n    for neighbours in structure:\n        if neighbours.new_parent_old_indices == -1:\n            i1 = i2 = link_idx_old_world_old_indices\n        elif neighbours.parent_changed:\n            i1 = neighbours.new_parent_old_indices\n        else:\n            i1 = neighbours.link_idx_old_indices\n        i2 = i1\n        properties_link = _get_joint_properties_of(i1, i2)\n        if neighbours.parent_changed:\n            properties_link = properties_link.inv()\n        joint_properties.append(properties_link)\n\n    unpack = lambda attr: ([getattr(jp, attr) for jp in joint_properties])\n    new_transform1 = unpack(\"transform1\")\n    new_transform1 = new_transform1[0].batch(*new_transform1[1:])\n    new_pos_min = jnp.stack(unpack(\"pos_min\"))\n    new_pos_max = jnp.stack(unpack(\"pos_max\"))\n\n    new_links = sys.links.replace(\n        transform1=new_transform1, pos_min=new_pos_min, pos_max=new_pos_max\n    )\n\n    new_links = _update_links_new_root_to_leaves(structure, permutation, new_links)\n\n    new_link_types = unpack(\"link_type\")\n    d, a, ss, sz = map(\n        unpack,\n        (\n            \"link_damping\",\n            \"link_armature\",\n            \"link_spring_stiffness\",\n            \"link_spring_zeropoint\",\n        ),\n    )\n\n    def _permute(obj):\n        if isinstance(obj, (base._Base, jax.Array)):\n            return obj[jnp.array(permutation, dtype=jnp.int32)]\n        elif isinstance(obj, list):\n            return [obj[permutation[i]] for i in range(len(obj))]\n        assert False\n\n    # permute those that have an indexing range not directly linked to 'l'\n    d, a, ss, sz = map(lambda list: jnp.concatenate(_permute(list)), (d, a, ss, sz))\n\n    morphed_system = base.System(\n        new_parent_array,\n        _permute(new_links),\n        _permute(new_link_types),\n        d,\n        a,\n        ss,\n        sz,\n        sys.dt,\n        sys.dynamic_geometries,\n        _permute_modify_geoms(sys.geoms, structure, new_transform1),\n        sys.gravity,\n        sys.integration_method,\n        sys.mass_mat_iters,\n        [prefix + name for name in _permute(sys.link_names)],\n        sys.model_name,\n    )\n\n    return parse_system(morphed_system)\n</code></pre>"},{"location":"api/system/","title":"System","text":""},{"location":"api/system/#x_xy.base.System","title":"<code>System</code>","text":"Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass System(_Base):\n    link_parents: list[int] = struct.field(False)\n    links: Link\n    link_types: list[str] = struct.field(False)\n    link_damping: jax.Array\n    link_armature: jax.Array\n    link_spring_stiffness: jax.Array\n    link_spring_zeropoint: jax.Array\n    # simulation timestep size\n    dt: float = struct.field(False)\n    # whether or not to re-calculate the inertia\n    # matrix at every simulation timestep because\n    # the geometries may have changed\n    dynamic_geometries: bool = struct.field(False)\n    # geometries in the system\n    geoms: list[Geometry]\n    # root / base acceleration offset\n    gravity: jax.Array = struct.field(default_factory=lambda: jnp.array([0, 0, -9.81]))\n\n    integration_method: str = struct.field(\n        False, default_factory=lambda: \"semi_implicit_euler\"\n    )\n    mass_mat_iters: int = struct.field(False, default_factory=lambda: 0)\n\n    link_names: list[str] = struct.field(False, default_factory=lambda: [])\n\n    model_name: Optional[str] = struct.field(False, default_factory=lambda: None)\n\n    def num_links(self) -&gt; int:\n        return len(self.link_parents)\n\n    def q_size(self) -&gt; int:\n        return sum([Q_WIDTHS[typ] for typ in self.link_types])\n\n    def qd_size(self) -&gt; int:\n        return sum([QD_WIDTHS[typ] for typ in self.link_types])\n\n    def name_to_idx(self, name: str) -&gt; int:\n        return self.link_names.index(name)\n\n    def idx_to_name(self, idx: int) -&gt; str:\n        assert idx &gt;= 0, \"Worldbody index has no name.\"\n        return self.link_names[idx]\n\n    def idx_map(self, type: str) -&gt; dict:\n        \"type: is either `l` or `q` or `d`\"\n        from x_xy import scan_sys\n\n        dict_int_slices = {}\n\n        def f(_, idx_map, name: str, link_idx: int):\n            dict_int_slices[name] = idx_map[type](link_idx)\n\n        scan_sys(self, f, \"ll\", self.link_names, list(range(self.num_links())))\n\n        return dict_int_slices\n\n    def parent_name(self, name: str) -&gt; str:\n        return self.idx_to_name(self.link_parents[self.name_to_idx(name)])\n\n    def add_prefix(self, prefix: str = \"\") -&gt; \"System\":\n        return self.replace(link_names=[prefix + name for name in self.link_names])\n\n    def change_model_name(self, name: str) -&gt; \"System\":\n        return self.replace(model_name=name)\n\n    @staticmethod\n    def deep_equal(a, b):\n        if type(a) is not type(b):\n            return False\n        if isinstance(a, _Base):\n            return System.deep_equal(a.__dict__, b.__dict__)\n        if isinstance(a, dict):\n            if a.keys() != b.keys():\n                return False\n            return all(System.deep_equal(a[k], b[k]) for k in a.keys())\n        if isinstance(a, (list, tuple)):\n            if len(a) != len(b):\n                return False\n            return all(System.deep_equal(a[i], b[i]) for i in range(len(a)))\n        if isinstance(a, (np.ndarray, jnp.ndarray, jax.Array)):\n            return jnp.array_equal(a, b)\n        return a == b\n</code></pre>"},{"location":"api/system/#x_xy.base.System.idx_map","title":"<code>idx_map(type)</code>","text":"<p>type: is either <code>l</code> or <code>q</code> or <code>d</code></p> Source code in <code>x_xy/base.py</code> <pre><code>def idx_map(self, type: str) -&gt; dict:\n    \"type: is either `l` or `q` or `d`\"\n    from x_xy import scan_sys\n\n    dict_int_slices = {}\n\n    def f(_, idx_map, name: str, link_idx: int):\n        dict_int_slices[name] = idx_map[type](link_idx)\n\n    scan_sys(self, f, \"ll\", self.link_names, list(range(self.num_links())))\n\n    return dict_int_slices\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.from_xml.load_sys_from_str","title":"<code>load_sys_from_str(xml_str, prefix='')</code>","text":"<p>Load system from string input.</p> <p>Parameters:</p> Name Type Description Default <code>xml_str</code> <code>str</code> <p>XML Presentation of the system.</p> required <code>prefix</code> <code>str</code> <p>Prefix to add to all link names. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Type Description <code>System</code> <p>base.System: Loaded system.</p> Source code in <code>x_xy/io/xml/from_xml.py</code> <pre><code>def load_sys_from_str(xml_str: str, prefix: str = \"\") -&gt; base.System:\n\"\"\"Load system from string input.\n\n    Args:\n        xml_str (str): XML Presentation of the system.\n        prefix (str, optional): Prefix to add to all link names. Defaults to \"\".\n\n    Returns:\n        base.System: Loaded system.\n    \"\"\"\n    xml_tree = ElementTree.fromstring(xml_str)\n    worldbody = _initial_setup(xml_tree)\n\n    # check that &lt;x_xy model=\"...\"&gt; syntax is correct\n    assert xml_tree.tag == \"x_xy\", (\n        \"The root element in the xml of a x_xy model must be `x_xy`.\"\n        \" Look up the examples under  x_xy/io/examples/*.xml to get started\"\n    )\n    model_name = xml_tree.attrib.get(\"model\", None)\n\n    # default options\n    options = {\"gravity\": DEFAULT_GRAVITY, \"dt\": DEFAULT_DT}\n    options_xml = _find_assert_unique(xml_tree, \"options\")\n    options.update({} if options_xml is None else options_xml.attrib)\n\n    # convert scalar array to float\n    # if this is uncommented, it leads to `ConcretizationTypeError`s\n    # options[\"dt\"] = float(options[\"dt\"])\n\n    links = {}\n    link_parents = {}\n    link_names = {}\n    link_types = {}\n    geoms = {}\n    armatures = {}\n    dampings = {}\n    spring_stiffnesses = {}\n    spring_zeropoints = {}\n    global_link_idx = -1\n\n    def process_body(body: ElementTree, parent: int):\n        nonlocal global_link_idx\n        global_link_idx += 1\n        current_link_idx = global_link_idx\n        current_link_typ = body.attrib[\"joint\"]\n\n        link_parents[current_link_idx] = parent\n        link_types[current_link_idx] = current_link_typ\n        link_names[current_link_idx] = prefix + body.attrib[\"name\"]\n\n        transform = abstract.AbsTrans.from_xml(body.attrib)\n        pos_min, pos_max = abstract.AbsPosMinMax.from_xml(body.attrib, transform.pos)\n        links[current_link_idx] = base.Link(transform, pos_min, pos_max)\n\n        q_size = base.Q_WIDTHS[current_link_typ]\n        qd_size = base.QD_WIDTHS[current_link_typ]\n\n        (\n            damping,\n            armature,\n            stiffness,\n            zeropoint,\n        ) = abstract.AbsDampArmaStiffZero.from_xml(\n            body.attrib, q_size, qd_size, current_link_typ\n        )\n\n        armatures[current_link_idx] = armature\n        dampings[current_link_idx] = damping\n        spring_stiffnesses[current_link_idx] = stiffness\n        spring_zeropoints[current_link_idx] = zeropoint\n\n        geoms[current_link_idx] = _extract_geoms_from_body_xml(body, current_link_idx)\n\n        for subbodies in body.findall(\"body\"):\n            process_body(subbodies, current_link_idx)\n\n        return\n\n    for body in worldbody.findall(\"body\"):\n        process_body(body, -1)\n\n    def assert_order_then_to_list(d: dict) -&gt; list:\n        assert [i for i in d] == list(range(len(d)))\n        return [d[i] for i in d]\n\n    links = assert_order_then_to_list(links)\n    links = links[0].batch(*links[1:])\n    dampings = jnp.concatenate(assert_order_then_to_list(dampings))\n    armatures = jnp.concatenate(assert_order_then_to_list(armatures))\n    spring_stiffnesses = jnp.concatenate(assert_order_then_to_list(spring_stiffnesses))\n    spring_zeropoints = jnp.concatenate(assert_order_then_to_list(spring_zeropoints))\n\n    # add all geoms directly connected to worldbody\n    flat_geoms = [geom for geoms in assert_order_then_to_list(geoms) for geom in geoms]\n    flat_geoms += _extract_geoms_from_body_xml(worldbody, -1)\n\n    sys = base.System(\n        assert_order_then_to_list(link_parents),\n        links,\n        assert_order_then_to_list(link_types),\n        dampings,\n        armatures,\n        spring_stiffnesses,\n        spring_zeropoints,\n        options[\"dt\"],\n        False,\n        flat_geoms,\n        options[\"gravity\"],\n        link_names=assert_order_then_to_list(link_names),\n        model_name=model_name,\n    )\n\n    return parse_system(sys)\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.from_xml.load_sys_from_xml","title":"<code>load_sys_from_xml(xml_path, prefix='')</code>","text":"Source code in <code>x_xy/io/xml/from_xml.py</code> <pre><code>def load_sys_from_xml(xml_path: str, prefix: str = \"\"):\n    return load_sys_from_str(_load_xml(xml_path), prefix=prefix)\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.to_xml.save_sys_to_str","title":"<code>save_sys_to_str(sys)</code>","text":"Source code in <code>x_xy/io/xml/to_xml.py</code> <pre><code>def save_sys_to_str(sys: base.System) -&gt; str:\n    if not jnp.all(sys.links.joint_params == 0.0):\n        warnings.warn(\n            \"The system has `sys.links.joint_params` unequal to the default value (of\"\n            \" zeros). This will not be preserved in the xml.\"\n        )\n    global_index_map = {qd: sys.idx_map(qd) for qd in [\"q\", \"d\"]}\n\n    # Create root element\n    x_xy = Element(\"x_xy\")\n    x_xy.set(\"model\", sys.model_name)\n\n    options = SubElement(x_xy, \"options\")\n    options.set(\"dt\", str(sys.dt))\n    options.set(\"gravity\", _to_str(sys.gravity))\n\n    # Create worldbody\n    worldbody = SubElement(x_xy, \"worldbody\")\n\n    def process_link(link_idx: int, parent_elem: Element):\n        link = sys.links[link_idx]\n        link_typ = sys.link_types[link_idx]\n        link_name = sys.link_names[link_idx]\n\n        # Create body element\n        body = SubElement(parent_elem, \"body\")\n        body.set(\"joint\", link_typ)\n        body.set(\"name\", link_name)\n\n        # Set attributes\n        abstract.AbsTrans.to_xml(body, link.transform1)\n        abstract.AbsPosMinMax.to_xml(body, link.pos_min, link.pos_max)\n        abstract.AbsDampArmaStiffZero.to_xml(\n            body,\n            sys.link_damping[global_index_map[\"d\"][link_name]],\n            sys.link_armature[global_index_map[\"d\"][link_name]],\n            sys.link_spring_stiffness[global_index_map[\"d\"][link_name]],\n            sys.link_spring_zeropoint[global_index_map[\"q\"][link_name]],\n            base.Q_WIDTHS[link_typ],\n            base.QD_WIDTHS[link_typ],\n            link_typ,\n        )\n\n        # Add geometry elements\n        geoms = sys.geoms\n        for geom in geoms:\n            if geom.link_idx == link_idx:\n                geom_elem = SubElement(body, \"geom\")\n                abstract_class = abstract.geometry_to_abstract[type(geom)]\n                abstract_class.to_xml(geom_elem, geom)\n\n        # Recursively process child links\n        for child_idx, parent_idx in enumerate(sys.link_parents):\n            if parent_idx == link_idx:\n                process_link(child_idx, body)\n\n    for root_link_idx, parent_idx in enumerate(sys.link_parents):\n        if parent_idx == -1:\n            process_link(root_link_idx, worldbody)\n\n    # Pretty print xml\n    xml_str = parseString(tostring(x_xy)).toprettyxml(indent=\"  \")\n    return xml_str\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.to_xml.save_sys_to_xml","title":"<code>save_sys_to_xml(sys, xml_path)</code>","text":"Source code in <code>x_xy/io/xml/to_xml.py</code> <pre><code>def save_sys_to_xml(sys: base.System, xml_path: str) -&gt; None:\n    xml_str = save_sys_to_str(sys)\n    with open(xml_path, \"w\") as f:\n        f.write(xml_str)\n</code></pre>"},{"location":"api/system/#x_xy.io.examples.load_example","title":"<code>load_example(name)</code>","text":"<p>Load example from examples dir.</p> Source code in <code>x_xy/io/examples.py</code> <pre><code>def load_example(name: str):\n    \"Load example from examples dir.\"\n\n    xml_path = parse_path(EXAMPLES_DIR, name, extension=\"xml\")\n    return load_sys_from_xml(xml_path)\n</code></pre>"},{"location":"api/system/#x_xy.scan.scan_sys","title":"<code>scan_sys(sys, f, in_types, *args, reverse=False)</code>","text":"<p>Scan <code>f</code> along each link in system whilst carrying along state.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>description</p> required <code>f</code> <code>Callable[..., Y]</code> <p>f(y: Y, *args) -&gt; y</p> required <code>in_types</code> <code>str</code> <p>string specifying the type of each input arg: 'l' is an input to be split according to link ranges 'q' is an input to be split according to q ranges 'd' is an input to be split according to qd ranges</p> required <code>args</code> <p>Arguments passed to <code>f</code>, and split to match the link.</p> <code>()</code> <code>reverse</code> <code>bool</code> <p>If <code>true</code> from leaves to root. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ys</code> <p>Stacked output y of f.</p> Source code in <code>x_xy/scan.py</code> <pre><code>def scan_sys(\n    sys: base.System, f: Callable, in_types: str, *args, reverse: bool = False\n):\n\"\"\"Scan `f` along each link in system whilst carrying along state.\n\n    Args:\n        sys (base.System): _description_\n        f (Callable[..., Y]): f(y: Y, *args) -&gt; y\n        in_types: string specifying the type of each input arg:\n            'l' is an input to be split according to link ranges\n            'q' is an input to be split according to q ranges\n            'd' is an input to be split according to qd ranges\n        args: Arguments passed to `f`, and split to match the link.\n        reverse (bool, optional): If `true` from leaves to root. Defaults to False.\n\n    Returns:\n        ys: Stacked output y of f.\n    \"\"\"\n\n    assert len(args) == len(in_types)\n\n    order = range(sys.num_links())\n    q_idx, qd_idx = 0, 0\n    q_idxs, qd_idxs = {}, {}\n    for link_idx, link_type in zip(order, sys.link_types):\n        # build map from\n        # link-idx -&gt; q_idx\n        # link-idx -&gt; qd_idx\n        q_idxs[link_idx] = slice(q_idx, q_idx + base.Q_WIDTHS[link_type])\n        qd_idxs[link_idx] = slice(qd_idx, qd_idx + base.QD_WIDTHS[link_type])\n        q_idx += base.Q_WIDTHS[link_type]\n        qd_idx += base.QD_WIDTHS[link_type]\n\n    idx_map = {\n        \"l\": lambda link_idx: link_idx,\n        \"q\": lambda link_idx: q_idxs[link_idx],\n        \"d\": lambda link_idx: qd_idxs[link_idx],\n    }\n\n    if reverse:\n        order = range(sys.num_links() - 1, -1, -1)\n\n    y, ys = None, []\n    for link_idx in order:\n        args_link = [arg[idx_map[t](link_idx)] for arg, t in zip(args, in_types)]\n        y = f(y, idx_map, *args_link)\n        ys.append(y)\n\n    if reverse:\n        ys.reverse()\n\n    ys = tree_utils.tree_batch(ys, backend=\"jax\")\n    return ys\n</code></pre>"},{"location":"api/transform/","title":"Transform","text":""},{"location":"api/transform/#x_xy.base.Transform","title":"<code>Transform</code>","text":"<p>Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B, where B is located relative to A at <code>pos</code> in frame A and <code>rot</code> is the relative quaternion from A to B.</p> Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass Transform(_Base):\n\"\"\"Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B,\n    where B is located relative to A at `pos` in frame A and `rot` is the\n    relative quaternion from A to B.\"\"\"\n\n    pos: Vector\n    rot: Quaternion\n\n    @classmethod\n    def create(cls, pos=None, rot=None):\n        assert not (pos is None and rot is None), \"One must be given.\"\n        shape_rot = rot.shape[:-1] if rot is not None else ()\n        shape_pos = pos.shape[:-1] if pos is not None else ()\n\n        if pos is None:\n            pos = jnp.zeros(shape_rot + (3,))\n        if rot is None:\n            rot = jnp.array([1.0, 0, 0, 0])\n            rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape_pos + (1,))\n\n        assert pos.shape[:-1] == rot.shape[:-1]\n\n        return Transform(pos, rot)\n\n    @classmethod\n    def zero(cls, shape=()) -&gt; \"Transform\":\n\"\"\"Returns a zero transform with a batch shape.\"\"\"\n        pos = jnp.zeros(shape + (3,))\n        rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape + (1,))\n        return Transform(pos, rot)\n\n    def as_matrix(self) -&gt; jax.Array:\n        E = maths.quat_to_3x3(self.rot)\n        return maths.spatial.quadrants(aa=E, bb=E) @ maths.spatial.xlt(self.pos)\n</code></pre>"},{"location":"api/transform/#x_xy.base.Transform.zero","title":"<code>zero(shape=())</code>  <code>classmethod</code>","text":"<p>Returns a zero transform with a batch shape.</p> Source code in <code>x_xy/base.py</code> <pre><code>@classmethod\ndef zero(cls, shape=()) -&gt; \"Transform\":\n\"\"\"Returns a zero transform with a batch shape.\"\"\"\n    pos = jnp.zeros(shape + (3,))\n    rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape + (1,))\n    return Transform(pos, rot)\n</code></pre>"},{"location":"api/transform/#x_xy.algebra.transform.transform_mul","title":"<code>transform_mul(t2, t1)</code>","text":"<p>Chains two transformations <code>t1</code> and <code>t2</code>. t1: Pl\u00fccker A -&gt; Pl\u00fccker B, t2: Pl\u00fccker B -&gt; Pl\u00fccker C =&gt; Returns: Pl\u00fccker A -&gt; Pl\u00fccker C</p> Source code in <code>x_xy/algebra/transform.py</code> <pre><code>def transform_mul(t2: base.Transform, t1: base.Transform) -&gt; base.Transform:\n\"\"\"Chains two transformations `t1` and `t2`.\n    t1: Pl\u00fccker A -&gt; Pl\u00fccker B,\n    t2: Pl\u00fccker B -&gt; Pl\u00fccker C\n    =&gt;\n    Returns: Pl\u00fccker A -&gt; Pl\u00fccker C\n    \"\"\"\n    pos = t1.pos + maths.rotate(t2.pos, maths.quat_inv(t1.rot))\n    rot = maths.quat_mul(t2.rot, t1.rot)\n    return base.Transform(pos, rot)\n</code></pre>"},{"location":"api/transform/#x_xy.algebra.transform.transform_inv","title":"<code>transform_inv(t)</code>","text":"<p>Inverts the transform. A -&gt; B becomes B -&gt; A</p> Source code in <code>x_xy/algebra/transform.py</code> <pre><code>def transform_inv(t: base.Transform) -&gt; base.Transform:\n    \"Inverts the transform. A -&gt; B becomes B -&gt; A\"\n    pos = maths.rotate(-t.pos, t.rot)\n    rot = maths.quat_inv(t.rot)\n    return base.Transform(pos, rot)\n</code></pre>"},{"location":"notebooks/batched_simulation/","title":"Batched simulation","text":"<p>This example is available as a jupyter notebook here.</p> <p><code>System</code> object is a registered Jax-PyTree. This means it's a nested array.</p> <p>This enables us to stack multiple systems (or states) to enable vectorized operations.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\nimport vispy\n\n# other backends are fine too, just not `jupyter_rfb`. You can install `pyqt6` using `pip install pyqt6`\nvispy.use(\"pyqt6\")\n\nxml_str = \"\"\"\n&lt;x_xy model=\"double_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"upper\" euler=\"0 90 0\" joint=\"ry\" damping=\"2\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"lower\" pos=\"1 0 0\" joint=\"ry\" damping=\"2\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nstate = x_xy.State.create(sys)\n</code></pre> <pre><code># second system with gravity disabled\nsys_nograv = sys.replace(gravity = sys.gravity * 0.0)\nsys_batched = sys.batch(sys_nograv)\n\nnext_state_batched = jax.vmap(x_xy.step, in_axes=(0, None))(sys_batched, state)\n</code></pre> <pre><code># note how the state of the system without gravity has not changed at all\nnext_state_batched.q\n</code></pre> <pre>\n<code>Array([[-1.7982468e-10,  2.3305433e-10],\n       [ 0.0000000e+00,  0.0000000e+00]], dtype=float32)</code>\n</pre> <pre><code>second_state = x_xy.State.create(sys, qd=jnp.ones((2,)))\nstate_batched = state.batch(second_state)\nnext_state_batched = jax.vmap(x_xy.step, in_axes=(None, 0))(sys, state_batched)\n</code></pre> <pre><code>next_state_batched.q\n</code></pre> <pre>\n<code>Array([[-1.7982468e-10,  2.3305433e-10],\n       [ 1.0048340e-02,  9.8215193e-03]], dtype=float32)</code>\n</pre> <p>Batched kinematic simulation is done using either <code>x_xy.batch_generator</code> or <code>x_xy.offline_generator</code>.</p> <pre><code>gen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nbatchsize = 8\ngen_batched = x_xy.batch_generator(gen, batchsizes=batchsize)\nseed = 1\nqs, xs = gen_batched(jax.random.PRNGKey(seed))\n</code></pre> <pre><code>qs.shape\n</code></pre> <pre>\n<code>(8, 1000, 2)</code>\n</pre> <pre><code>\n</code></pre>"},{"location":"notebooks/batched_simulation/#batched-dynamical-simulation","title":"Batched Dynamical Simulation","text":""},{"location":"notebooks/batched_simulation/#batched-system","title":"Batched System","text":"<p>I.e. simulating two different system with the same initial state.</p>"},{"location":"notebooks/batched_simulation/#batched-state","title":"Batched State","text":""},{"location":"notebooks/batched_simulation/#batched-kinematic-simulation","title":"Batched Kinematic Simulation","text":""},{"location":"notebooks/control/","title":"Control","text":"<p>This example is available as a jupyter notebook here.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\nimport vispy\n\n# other backends are fine too, just not `jupyter_rfb`. You can install `pyqt6` using `pip install pyqt6`\nvispy.use(\"pyqt6\")\n</code></pre> <p>The <code>step</code> function also takes generalized forces <code>tau</code> applied to the degrees of freedom its third input <code>step(sys, state, taus)</code>.</p> <p>Let's consider an inverted pendulum on a cart, and apply a left-right force onto the cart such that the pole stays in the upright position.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"inv_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;defaults&gt;\n        &lt;geom edge_color=\"black\" color=\"white\"/&gt;\n    &lt;/defaults&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"cart\" joint=\"px\" damping=\"0.01\"&gt;\n            &lt;geom type=\"box\" mass=\"1\" dim=\"0.4 0.1 0.1\"/&gt;\n            &lt;body name=\"pendulum\" joint=\"ry\" euler=\"0 -90 0\" damping=\"0.01\"&gt;\n                &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.5 0 0\" dim=\"1 0.1 0.1\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nstate = x_xy.State.create(sys, q=jnp.array([0.0, 0.2])) \n\nxs = []\nT = 10.0\nfor t in range(int(T / sys.dt)):\n    measurement_noise = np.random.normal() * 5\n    phi = jnp.rad2deg(state.q[1]) + measurement_noise\n    cart_motor_input = 0.1 * phi * abs(phi)\n    taus = jnp.clip(jnp.array([cart_motor_input, 0.0]), -10, 10) \n    state = jax.jit(x_xy.step)(sys, state, taus)\n    xs.append(state.x)\n</code></pre> <pre><code>def show_video(sys, xs: list[x_xy.Transform]):\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render_frames(sys, [xs[i] for i in range(0, len(xs), 4)])\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:00&lt;00:00, 289.60it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>xml_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"pendulum\" joint=\"ry\" euler=\"0 90 0\" damping=\"0.01\"&gt;\n            &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.5 0 0\" dim=\"1 0.1 0.1\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nP, D = jnp.array([10.0]), jnp.array([1.0])\n\ndef simulate_pd_control(sys, P, D):\n    controller = x_xy.pd_control(P, D)\n    # reference signal\n    q_ref = jnp.ones((1000, 1)) * jnp.pi / 2\n    controller_state = controller.init(sys, q_ref)\n    state = x_xy.State.create(sys) \n\n    xs = []\n    T = 5.0\n    for t in range(int(T / sys.dt)):\n        controller_state, taus = jax.jit(controller.apply)(controller_state, sys, state)\n        state = jax.jit(x_xy.step)(sys, state, taus)\n        xs.append(state.x)\n    return xs\n</code></pre> <pre><code>xs = simulate_pd_control(sys, P, D)\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00&lt;00:00, 280.73it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Note the steady state error. This is because we have gravity and no Integral part (so no PID control).</p> <p>If we remove gravity the steady state error also vanishes (as is expected.)</p> <pre><code>sys_nograv = sys.replace(gravity = sys.gravity * 0.0)\nxs = simulate_pd_control(sys_nograv, P, D)\nshow_video(sys_nograv, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00&lt;00:00, 299.47it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/control/#balance-an-inverted-pendulum-on-a-cart","title":"Balance an inverted Pendulum on a cart","text":""},{"location":"notebooks/control/#pd-control","title":"PD Control","text":""},{"location":"notebooks/custom_joint_type/","title":"Custom joint type","text":"<p>This example is available as a jupyter notebook here.</p> <p>In this notebook we will define a new joint type that is a hinge joint with a random joint axes direction.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\nimport vispy\n\n# other backends are fine too, just not `jupyter_rfb`. You can install `pyqt6` using `pip install pyqt6`\nvispy.use(\"pyqt6\")\n</code></pre> <p>We will give this new joint type the identifier <code>rr</code> (random revolute).</p> <pre><code>from x_xy.algorithms.jcalc import _draw_rxyz\n\n\n# we use this `params` input to specify the joint-axes, if we later then randomize the attribute of the system object\n# we will have the effect of a hinge joint with a randomized joint axes direction\n\n# set the dimensionality of the attribute to 3 for each joint / link in the system.\n# This is save because the library itself does not use this attribute at all\nx_xy.base.update_n_joint_params(3)\n\ndef _rr_transform(q, params):\n    axis = params\n    q = jnp.squeeze(q)\n    rot = x_xy.maths.quat_rot_axis(axis, q)\n    return x_xy.Transform.create(rot=rot)\n\n# we don't specify the motion vectors; They are required for dynamic simulation\nrr_joint = x_xy.JointModel(_rr_transform, rcmg_draw_fn=_draw_rxyz)\n\n# qd_width is zero because we have not specified the motion vectors\nx_xy.register_new_joint_type(\"rr\", rr_joint, q_width=1, qd_width=0)\n</code></pre> <pre>\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[11], line 21\n     18 rr_joint = x_xy.JointModel(_rr_transform, rcmg_draw_fn=_draw_rxyz)\n     20 # qd_width is zero because we have not specified the motion vectors\n---&gt; 21 x_xy.register_new_joint_type(\"rr\", rr_joint, q_width=1, qd_width=0)\n\nFile ~/Documents/PYTHON/x_xy_v2/x_xy/algorithms/jcalc.py:361, in register_new_joint_type(joint_type, joint_model, q_width, qd_width)\n    358     qd_width = q_width\n    360 assert len(joint_model.motion) == qd_width\n--&gt; 361 assert joint_type not in _joint_types, \"already exists\"\n    362 _joint_types.update({joint_type: joint_model})\n    363 base.Q_WIDTHS.update({joint_type: q_width})\n\nAssertionError: already exists</pre> <pre><code>xml_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"pendulum\" joint=\"rr\"&gt;\n            &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.25 0 0\" dim=\"0.5 0.1 0.1\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n</code></pre> <pre><code>def setup_fn_randomize_joint_axes(key, sys: x_xy.System) -&gt; x_xy.System:\n    \"Randomizes the `sys.links.joint_params` attribute, which is used as joint-axis direction.\"\n    @jax.vmap\n    def _draw_random_joint_axis(key):\n        return x_xy.maths.rotate(jnp.array([1.0, 0, 0]), x_xy.maths.quat_random(key))\n\n    joint_axes = _draw_random_joint_axis(jax.random.split(key, sys.num_links()))\n    return sys.replace(links=sys.links.replace(joint_params=joint_axes))\n\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, ang0_min=0.0, ang0_max=0.0), \n                           setup_fn=setup_fn_randomize_joint_axes)\n_, xs = gen(jax.random.PRNGKey(1))\n</code></pre> <pre><code>def show_video(sys, xs: x_xy.Transform):\n    # right now `xs` is a batched `Transform` object\n    # so convert to a list of unbatched `Transform` object which is what `render_frames` expects.\n    xs = [xs[i] for i in range(xs.shape())]\n\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render_frames(sys, [xs[i] for i in range(0, len(xs), 4)])\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:00&lt;00:00, 291.31it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>And now with a different seed, the joint axis (and motion) is different.</p> <pre><code>_, xs = gen(jax.random.PRNGKey(3))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:00&lt;00:00, 280.85it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/custom_joint_type/#defining-a-custom-joint-type","title":"Defining a custom Joint Type","text":""},{"location":"notebooks/getting_started/","title":"Getting started","text":"<p>This example is available as a jupyter notebook here.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\nimport vispy\n\n# other backends are fine too, just not `jupyter_rfb`. You can install `pyqt6` using `pip install pyqt6`\nvispy.use(\"pyqt6\")\n</code></pre> <p>Systems are defined with the following xml syntax.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"double_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"upper\" euler=\"0 90 0\" joint=\"ry\" damping=\"2\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"lower\" pos=\"1 0 0\" joint=\"ry\" damping=\"2\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n</code></pre> <p>With this xml description of the system, we are ready to load the system using <code>load_sys_from_str</code>. We can also save this to a text-file <code>double_pendulum.xml</code> and load with <code>load_sys_from_xml</code>.</p> <pre><code>sys = x_xy.load_sys_from_str(xml_str)\n</code></pre> <pre><code>sys.model_name\n</code></pre> <pre>\n<code>'double_pendulum'</code>\n</pre> <p>System objects have many attributes. You may refer to the API documentation for more details.</p> <pre><code>sys.link_names\n</code></pre> <pre>\n<code>['upper', 'lower']</code>\n</pre> <p>Let's start with the most obvious. A physical simulation. We refer to it as \"dynamical simulation\", in contrast to what we do a little later which is a purely kinematic simulation.</p> <p>First, we have to create the dynamical state of the system. It is defined by the all degrees of freedom in the system and their velocities. Here, we have two revolute joints (one degree of freedom). Thus, the minimal coordinates vector \\(q\\) and minimal velocity vector \\(q'\\) has two dimensions.</p> <pre><code>state = x_xy.State.create(sys)\n</code></pre> <pre><code>state.q\n</code></pre> <pre>\n<code>Array([0., 0.], dtype=float32)</code>\n</pre> <pre><code>state.qd\n</code></pre> <pre>\n<code>Array([0., 0.], dtype=float32)</code>\n</pre> <pre><code>next_state = x_xy.step(sys, state)\n</code></pre> <p>Massive speedups if we use <code>jax.jit</code> to jit-compile the function.</p> <pre><code>%timeit x_xy.step(sys, state)\n</code></pre> <pre>\n<code>340 ms \u00b1 11.3 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code>\n</pre> <pre><code>%timeit jax.jit(x_xy.step)(sys, state)\n</code></pre> <pre>\n<code>89.2 \u00b5s \u00b1 41.9 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code>\n</pre> <p>Let's unroll the dynamics for multiple timesteps.</p> <pre><code>T = 10.0\nxs = []\nfor _ in range(int(T / sys.dt)):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n</code></pre> <p>Next, let's render the frames and create an animation.</p> <pre><code>frames = x_xy.render_frames(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03&lt;00:00, 272.26it/s]\n</code>\n</pre> <pre><code>def show_video(frames: list[np.ndarray], dt: float):\n    assert dt == 0.01\n    # frames are at 100 Hz, but let's create an animation at 25Hz\n    media.show_video([frames[i][..., :3] for i in range(0, len(frames), 4)], fps=25)\n\nshow_video(frames, sys.dt)\n</code></pre>        This browser does not support the video tag.        <p>Hmm, pretty boring. Let's get the pendulum into an configuration with some potential energy.</p> <p>All we have to change is the initial state <code>state.q</code>.</p> <pre><code>state = x_xy.State.create(sys, q=jnp.array([jnp.pi / 2, 0]))\n</code></pre> <pre><code>T = 10.0\nxs = []\nfor _ in range(int(T / sys.dt)):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n\nframes = x_xy.render_frames(sys, xs)\nshow_video(frames, sys.dt)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03&lt;00:00, 276.10it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>That's more like it!</p> <p>Next, we will take a look at \"kinematic simulation\".</p> <p>Let's start with why you would want this. </p> <p>Imagine we want to learn a filter that estimates some quantity of interest from some sensor input. </p> <p>Then, we could try to create many random motions, record the measured sensor input, and the ground truth quantity of interest target values. </p> <p>This is then used as training data for a Machine Learning model.</p> <p>The general interface to kinematic simulation is via <code>x_xy.build_generator</code>.</p> <p>This function creates a function (of type <code>Generator</code>) that maps a PRNG seed to, e.g., <code>X, y</code> data.</p> <pre><code>gen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nseed = 1\n_, xs = gen(jax.random.PRNGKey(seed))\n</code></pre> <pre><code># right now `xs` is a batched `Transform` object\n# so convert to a list of unbatched `Transform` object which is what `render_frames` expects.\nxs_list = [xs[i] for i in range(xs.shape())]\n</code></pre> <pre><code>frames = x_xy.render_frames(sys, xs_list)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03&lt;00:00, 286.03it/s]\n</code>\n</pre> <p>This is now completely random, but unphysical motion. It's only kinematics, but that is okay for creating training data.</p> <pre><code>show_video(frames, sys.dt)\n</code></pre>        This browser does not support the video tag.        <p>We are interested in simulating IMU data as input <code>X</code>, and estimating quaternions as target <code>y</code>.</p> <p>We can easily simulate an IMU with only the trajectory of maximal coordinates <code>xs</code>.</p> <p>Suppose, we want to simulate an IMU right that is placed on the <code>lower</code> segment and right at the revolute joint.</p> <p>This is exactly where the coordinate system of the <code>lower</code> segment is placed.</p> <p>Right now the <code>xs</code> trajectory contains both coordinate sytems of <code>upper</code> and <code>lower</code>.</p> <pre><code># (n_timesteps, n_links, 3)\nxs.pos.shape\n</code></pre> <pre>\n<code>(1000, 2, 3)</code>\n</pre> <pre><code># (n_timesteps, n_links, 4)\nxs.rot.shape\n</code></pre> <pre>\n<code>(1000, 2, 4)</code>\n</pre> <p>From the axis with length two, the 0th entry is for <code>upper</code> and the 1st entry is for <code>lower</code>.</p> <pre><code>sys.name_to_idx(\"upper\")\n</code></pre> <pre>\n<code>0</code>\n</pre> <pre><code>sys.name_to_idx(\"lower\")\n</code></pre> <pre>\n<code>1</code>\n</pre> <pre><code>xs_lower = xs.take(1, axis=1)\n</code></pre> <pre><code>imu_lower = x_xy.imu(xs_lower, sys.gravity, sys.dt)\n</code></pre> <pre><code>imu_lower.keys()\n</code></pre> <pre>\n<code>dict_keys(['acc', 'gyr'])</code>\n</pre> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), imu_lower[\"gyr\"], label=[\"x\", \"y\", \"z\"])\nplt.ylabel(\"gyro [rad / s]\")\nplt.xlabel(\"time [s]\")\nplt.legend()\nplt.show()\n</code></pre> <pre>\n<code>&lt;matplotlib.legend.Legend at 0x2c33ccca0&gt;</code>\n</pre> <p>As you can see it's a two-dimensional problem, which is why only one (<code>y</code>) is non-zero.</p> <p>Let's consider a larger kinematic chain in free 3D space.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"three_segment_kinematic_chain\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\"&gt;\n            &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"seg1\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"-0.5 0 0\" dim=\"-1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"-0.5 0 0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rz\" pos=\"1 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.5 0 -0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nseed = 1\n_, xs = gen(jax.random.PRNGKey(seed))\nxs_list = [xs[i] for i in range(xs.shape())]\nframes = x_xy.render_frames(sys, xs_list)\nshow_video(frames, sys.dt)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:04&lt;00:00, 223.44it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>We can modify the <code>build_generator</code> with a custom <code>finalize_fn</code> which determines what output the generator generates.</p> <p>The two orange boxes on segment 1 and segment 3 are modelling our two IMUs. This will be the network's input <code>X</code> data.</p> <p>As target we will try to estimate both relative orientations as <code>y</code> data.</p> <pre><code>def finalize_fn(key: jax.Array, q: jax.Array, xs: x_xy.Transform, sys: x_xy.System):\n    xs_by_name = lambda name: xs.take(sys.name_to_idx(name), axis=1)\n    X = {\n        \"seg1\": x_xy.imu(xs_by_name(\"imu1\"), sys.gravity, sys.dt),\n        \"seg3\": x_xy.imu(xs_by_name(\"imu2\"), sys.gravity, sys.dt),\n    }\n\n    xs_seg1 = xs_by_name(\"seg1\")\n    xs_seg2 = xs_by_name(\"seg2\")\n    xs_seg3 = xs_by_name(\"seg3\")\n\n    # all `xs` transforms are to be interpreted as \"from epsilon to segment\"\n    xs_from_seg2_to_seg1 = x_xy.transform_mul(xs_seg1, x_xy.transform_inv(xs_seg2))\n    xs_from_seg3_to_seg2 = x_xy.transform_mul(xs_seg2, x_xy.transform_inv(xs_seg3))\n\n    y = {\n        # we only estimate the orientation, so extract the quaternion from the transform (transform.rot)\n        \"seg2\": xs_from_seg2_to_seg1.rot,\n        \"seg3\": xs_from_seg3_to_seg2.rot\n    }\n    return X, y\n\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5), finalize_fn=finalize_fn)\nseed = 1\nX, y = gen(jax.random.PRNGKey(seed))\n</code></pre> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), X[\"seg1\"][\"gyr\"], label=[\"x\", \"y\", \"z\"])\nplt.ylabel(\"gyro [rad / s]\")\nplt.xlabel(\"time [s]\")\nplt.title(\"IMU 1 Gyroscope\")\nplt.legend()\nplt.show()\n</code></pre> <p>Now, the IMU is non-zero in all three <code>x/y/z</code> components.</p> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), y[\"seg2\"], label=[\"w\", \"x\", \"y\", \"z\"])\nplt.xlabel(\"time [s]\")\nplt.title(\"Relative quaternion from seg2 to seg1\")\nplt.legend()\nplt.show()\n</code></pre> <p>Note how the relative quaternion is only around the y-axis. Can you see why? (Hint: Check the defining <code>xml_str</code>.)</p> <pre><code>\n</code></pre>"},{"location":"notebooks/getting_started/#dynamical-simulation","title":"Dynamical Simulation","text":""},{"location":"notebooks/getting_started/#kinematic-simulation","title":"Kinematic Simulation","text":""},{"location":"notebooks/getting_started/#x-y-training-data-attaching-sensors","title":"<code>X, y</code> Training data / Attaching sensors","text":""},{"location":"notebooks/morph_system/","title":"Morph system","text":"<pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\nimport vispy\n\n# other backends are fine too, just not `jupyter_rfb`. You can install `pyqt6` using `pip install pyqt6`\nvispy.use(\"pyqt6\")\n\ndef show_video(sys, xs: x_xy.Transform) -&gt; None:\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render_frames(sys, [xs[i] for i in range(0, xs.shape(), 4)])\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n</code></pre> <p>In this system the middle segment <code>seg2</code> acts as \"anchor\".</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"three_segment_kinematic_chain\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\"&gt;\n            &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"seg1\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"-0.5 0 0\" dim=\"-1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"-0.5 0 0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rz\" pos=\"1 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.5 0 -0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, dang_max_free_spherical=0.1, dpos_max=0.1))\n_, xs = gen(jax.random.PRNGKey(1))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01&lt;00:00, 185.40it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Can you see what i mean? The middle segment has all the \"global rotation and translation\".</p> <p>Let's move the anchor to <code>seg1</code> but without changing the xml syntax. This can be done with the subpackage <code>sys_composer</code>.</p> <pre><code>from x_xy.subpkgs import sys_composer\n</code></pre> <pre><code># the new parents of seg2, seg1, imu1, seg3, imu2 are ...\nnew_parents = [\"seg1\", -1, \"seg1\", \"seg2\", \"seg3\"]\nsys = sys_composer.morph_system(sys, new_parents=new_parents)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, dang_max_free_spherical=0.1, dpos_max=0.1))\n_, xs = gen(jax.random.PRNGKey(1))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01&lt;00:00, 226.98it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Pretty cool, ha? :)</p> <pre><code>\n</code></pre>"},{"location":"notebooks/morph_system/#different-anchors-explains-sys_composermorph_system","title":"Different Anchors (explains sys_composer.morph_system)","text":""}]}