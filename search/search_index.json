{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>x_xy</code> - Documentation Home","text":"<p>This is the documentation for the <code>x_xy</code> software library.</p> <p> </p>"},{"location":"#x_xy_v2-a-tiny-kinematic-tree-simulator","title":"<code>x_xy_v2</code> -- A tiny Kinematic Tree Simulator","text":""},{"location":"#installation","title":"Installation","text":"<p>Supports <code>Python=3.10/3.11</code> (tested).</p> <p>Install with <code>pip</code> using</p> <p><code>pip install 'x_xy[all] @ git+https://github.com/SimiPixel/x_xy_v2'</code></p> <p>Typically, this will install <code>jax</code> as cpu-only version. CUDA version can be installed with <pre><code>pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n</code></pre></p>"},{"location":"#installation-of-extras","title":"Installation of Extras","text":"<p>Seperates dependencies neatly per subpackage. E.g. the dependencies for subpkg <code>omc</code> can be installed via</p> <p><code>pip install 'x_xy[omc] @ git+https://github.com/SimiPixel/x_xy_v2'</code></p> <p>Also available installs are</p> <p><code>pip install 'x_xy @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base; only subpackages <code>sys_composer</code> and <code>sim2real</code> work, no rendering)</p> <p><code>pip install 'x_xy[omc] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+omc)</p> <p><code>pip install 'x_xy[ml] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ml)</p> <p><code>pip install 'x_xy[exp] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+exp)</p> <p><code>pip install 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ mujoco rendering backend)</p> <p><code>pip install 'x_xy[vis] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ vispy rendering backend)</p> <p><code>pip install 'x_xy[all] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (everything works)</p> <p><code>pip install 'x_xy[all_muj] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (everything works but not vispy rendering only mujoco rendering)</p> <p><code>pip install 'x_xy[dev] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ development dependencies)</p> <p>Can also be combined, e.g. <code>pip install 'x_xy[ml,omc] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ml+omc)</p>"},{"location":"#publications","title":"Publications","text":"<p>The following publications utilize this software library, and refer to it as the Random Chain Motion Generator (RCMG) (more specifically the function <code>x_xy.build_generator</code>):</p> <ul> <li>RNN-based Observability Analysis for Magnetometer-Free Sparse Inertial Motion Tracking</li> <li>Plug-and-Play Sparse Inertial Motion Tracking With Sim-to-Real Transfer</li> <li>RNN-based State and Parameter Estimation for Sparse Magnetometer-free Inertial Motion Tracking</li> </ul>"},{"location":"#other-useful-ressources","title":"Other useful ressources","text":"<p>Particularly useful is the following publication from Roy Featherstone - A Beginner\u2019s Guide to 6-D Vectors (Part 2)</p>"},{"location":"#contact","title":"Contact","text":"<p>Simon Bachhuber (simon.bachhuber@fau.de)</p>"},{"location":"api/dyn_sim/","title":"Dynamic Simulation","text":""},{"location":"api/dyn_sim/#x_xy.algorithms.step","title":"<code>step(sys, state, taus=None, n_substeps=1)</code>","text":"Source code in <code>x_xy/algorithms/dynamics.py</code> <pre><code>def step(\n    sys: base.System,\n    state: base.State,\n    taus: Optional[jax.Array] = None,\n    n_substeps: int = 1,\n) -&gt; base.State:\n    assert sys.q_size() == state.q.size\n    if taus is None:\n        taus = jnp.zeros_like(state.qd)\n    assert sys.qd_size() == state.qd.size == taus.size\n    assert (\n        sys.integration_method.lower() == \"semi_implicit_euler\"\n    ), \"Currently, nothing else then `semi_implicit_euler` implemented.\"\n\n    sys = sys.replace(dt=sys.dt / n_substeps)\n\n    for _ in range(n_substeps):\n        # update kinematics before stepping; this means that the `x` in `state`\n        # will lag one step behind but otherwise we would have to return\n        # the system object which would be awkward\n        sys, state = forward_kinematics(sys, state)\n        state = _integration_methods[sys.integration_method.lower()](sys, state, taus)\n\n    return state\n</code></pre>"},{"location":"api/dyn_sim/#x_xy.algorithms.pd_control","title":"<code>pd_control(P, D)</code>","text":"<p>Computes tau using a PD controller. Returns a pair of (init, apply) functions.</p> <p>NOTE: Gains around ~10_000 are good for spherical joints, everything else ~250-300 works just fine. Damping should be about 2500 for spherical joints, and about 25 for everything else.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>Array</code> <p>jax.Array of P gains. Shape: (sys_init.qd_size())</p> required <code>D</code> <code>Array</code> <p>jax.Array of D gains. Shape: (sys_init.qd_size()) where <code>sys_init</code> is the system that recorded the reference trajectory <code>q_ref</code></p> required <p>Pair of (init, apply) functions</p> Name Type Description <code>init</code> <p>(sys, q_ref) -&gt; controller_state</p> <code>apply</code> <p>(controller_state, sys, state) -&gt; controller_state, tau</p> Example <p>gains = jnp.array([250.0] * sys1.qd_size()) controller = pd_control(gains, gains) q_ref = rcmg(sys1) cs = controller.init(sys1, q_ref) for t in range(1000):     cs, tau = controller.apply(cs, sys2, state)     state = dynamics.step(sys2, state, tau)</p> Source code in <code>x_xy/algorithms/control.py</code> <pre><code>def pd_control(P: jax.Array, D: jax.Array):\n\"\"\"Computes tau using a PD controller. Returns a pair of (init, apply) functions.\n\n    NOTE: Gains around ~10_000 are good for spherical joints, everything else ~250-300\n    works just fine. Damping should be about 2500 for spherical joints, and\n    about 25 for everything else.\n\n    Args:\n        P: jax.Array of P gains. Shape: (sys_init.qd_size())\n        D: jax.Array of D gains. Shape: (sys_init.qd_size()) where `sys_init` is the\n            system that recorded the reference trajectory `q_ref`\n\n    Returns: Pair of (init, apply) functions\n        init: (sys, q_ref) -&gt; controller_state\n        apply: (controller_state, sys, state) -&gt; controller_state, tau\n\n    Example:\n        &gt;&gt;&gt; gains = jnp.array([250.0] * sys1.qd_size())\n        &gt;&gt;&gt; controller = pd_control(gains, gains)\n        &gt;&gt;&gt; q_ref = rcmg(sys1)\n        &gt;&gt;&gt; cs = controller.init(sys1, q_ref)\n        &gt;&gt;&gt; for t in range(1000):\n        &gt;&gt;&gt;     cs, tau = controller.apply(cs, sys2, state)\n        &gt;&gt;&gt;     state = dynamics.step(sys2, state, tau)\n    \"\"\"\n\n    def init(sys: base.System, q_ref: jax.Array) -&gt; dict:\n        q_qd_ref = {}\n        P_as_dict = {}\n        D_as_dict = {}\n\n        def f(_, __, q_ref_link, name, typ, P_link, D_link):\n            q_ref_link = q_ref_link.T\n\n            if typ == \"free\":\n                dq = _derivative_quaternion(q_ref_link[:, :4], sys.dt)\n                qd_ref = jnp.hstack((dq, _derivative(q_ref_link[:, 4:], sys.dt)))\n            elif typ == \"spherical\":\n                qd_ref = _derivative_quaternion(q_ref_link, sys.dt)\n            else:\n                qd_ref = _derivative(q_ref_link, sys.dt)\n            q_qd_ref[name] = (q_ref_link, qd_ref)\n            P_as_dict[name] = P_link\n            D_as_dict[name] = D_link\n\n        scan_sys(sys, f, \"qlldd\", q_ref.T, sys.link_names, sys.link_types, P, D)\n        return PDControllerState(0, q_qd_ref, P_as_dict, D_as_dict)\n\n    def apply(\n        controller_state: PDControllerState, sys: base.System, state: base.State\n    ) -&gt; jax.Array:\n        taus = jnp.zeros((sys.qd_size()))\n        q_qd_ref = jax.tree_map(\n            lambda arr: jax.lax.dynamic_index_in_dim(\n                arr, controller_state.i, keepdims=False\n            ),\n            controller_state.q_qd_ref,\n        )\n\n        def f(_, idx_map, idx, name, typ, q_curr, qd_curr):\n            nonlocal taus\n\n            if name not in controller_state.q_qd_ref:\n                return\n\n            q_ref, qd_ref = q_qd_ref[name]\n            if typ == \"free\":\n                P_term = jnp.concatenate(\n                    (\n                        _p_control_quaternion(q_curr[:4], q_ref[:4]),\n                        q_ref[4:] - q_curr[4:],\n                    )\n                )\n            elif typ == \"spherical\":\n                P_term = _p_control_quaternion(q_curr, q_ref)\n            elif typ in [\"rx\", \"ry\", \"rz\"]:\n                # q_ref comes from rcmg. Thus, it is already wrapped\n                # TODO: Currently state.q is not wrapped. Change that?\n                P_term = maths.wrap_to_pi(q_ref - maths.wrap_to_pi(q_curr))\n            elif typ in [\"px\", \"py\", \"pz\"]:\n                P_term = q_ref - q_curr\n            elif typ == \"frozen\":\n                return\n            else:\n                raise NotImplementedError(\n                    f\"pd control of joint type {typ} is not yet implemented.\"\n                )\n\n            D_term = qd_ref - qd_curr\n\n            P_link = controller_state.P_gains[name]\n            D_link = controller_state.D_gains[name]\n\n            tau = P_link * P_term + D_link * D_term\n            taus = taus.at[idx_map[\"d\"](idx)].set(tau)\n\n        scan_sys(\n            sys,\n            f,\n            \"lllqd\",\n            list(range(sys.num_links())),\n            sys.link_names,\n            sys.link_types,\n            state.q,\n            state.qd,\n        )\n\n        return controller_state.replace(i=controller_state.i + 1), taus\n\n    return SimpleNamespace(init=init, apply=apply)\n</code></pre>"},{"location":"api/exp/","title":"exp","text":""},{"location":"api/exp/#x_xy.subpkgs.exp.exp.load_data","title":"<code>load_data(exp_id, motion_start=None, motion_stop=None, left_padd=0.0, right_padd=0.0, resample_to_hz=100.0)</code>","text":"Source code in <code>x_xy/subpkgs/exp/exp.py</code> <pre><code>def load_data(\n    exp_id: str,\n    motion_start: Optional[str] = None,\n    motion_stop: Optional[str] = None,\n    left_padd: float = 0.0,\n    right_padd: float = 0.0,\n    resample_to_hz: float = 100.0,\n) -&gt; dict:\n    trial_data = joblib.load(x_xy.utils.download_from_repo(f\"data/{exp_id}.joblib\"))\n\n    metadata = _read_yaml(\"metadata.yaml\")[exp_id]\n    timings = metadata[\"timings\"]\n    hz_imu, hz_omc = float(metadata[\"hz\"][\"imu\"]), float(metadata[\"hz\"][\"omc\"])\n\n    trial_data = omc.resample(\n        trial_data,\n        hz_in=omc.hz_helper(trial_data.keys(), hz_imu=hz_imu, hz_omc=hz_omc),\n        hz_out=resample_to_hz,\n        vecinterp_method=\"cubic\",\n    )\n    trial_data = omc.crop_tail(trial_data, resample_to_hz, strict=True, verbose=False)\n\n    if motion_start is not None:\n        assert (\n            motion_start in timings\n        ), f\"`{motion_start}` is not one of {load_timings(exp_id).keys()}\"\n\n        motion_sequence = list(timings.keys())\n        next_motion_i = motion_sequence.index(motion_start) + 1\n        assert next_motion_i &lt; len(motion_sequence)\n\n        if motion_stop is None:\n            motion_stop = motion_sequence[next_motion_i]\n\n        assert (\n            motion_stop in timings\n        ), f\"`{motion_stop}` is not one of {load_timings(exp_id).keys()}\"\n\n        assert motion_sequence.index(motion_start) &lt; motion_sequence.index(\n            motion_stop\n        ), \"Empty sequence, stop &lt;= start\"\n\n        t1 = timings[motion_start] - left_padd\n        # ensure that t1 &gt;= 0\n        t1 = max(t1, 0.0)\n        t2 = timings[motion_stop] + right_padd\n\n        trial_data = _crop_sequence(trial_data, 1 / resample_to_hz, t1=t1, t2=t2)\n    else:\n        assert motion_stop is None\n\n    return trial_data\n</code></pre>"},{"location":"api/exp/#x_xy.subpkgs.exp.exp.load_sys","title":"<code>load_sys(exp_id, preprocess_sys=None, morph_yaml_key=None, delete_after_morph=None, replace_rxyz=None)</code>","text":"Source code in <code>x_xy/subpkgs/exp/exp.py</code> <pre><code>def load_sys(\n    exp_id: str,\n    preprocess_sys: Optional[Callable] = None,\n    morph_yaml_key: Optional[str] = None,\n    delete_after_morph: Optional[list[str]] = None,\n    replace_rxyz: Optional[str] = None,\n) -&gt; x_xy.base.System:\n    xml_path = _relative_to_this_file(_id2xml[exp_id])\n    sys = x_xy.io.load_sys_from_xml(xml_path)\n\n    if preprocess_sys is not None:\n        sys = preprocess_sys(sys)\n\n    if replace_rxyz is not None:\n        sys = _replace_rxyz_with(sys, replace_rxyz)\n\n    if morph_yaml_key is not None:\n        new_parents = _morph_new_parents_from_xml_file(xml_path)[morph_yaml_key]\n        sys = sys_composer.morph_system(sys, new_parents)\n\n    if delete_after_morph is not None:\n        sys = sys_composer.delete_subsystem(sys, delete_after_morph)\n\n    return sys\n</code></pre>"},{"location":"api/kin_sim/","title":"Kinematic Simulation","text":""},{"location":"api/kin_sim/#x_xy.algorithms.generator.base.build_generator","title":"<code>build_generator(sys, config=RCMG_Config(), setup_fn=lambda , : sys, finalize_fn=lambda , , , : (q, x), randomize_positions=False)</code>","text":"Source code in <code>x_xy/algorithms/generator/base.py</code> <pre><code>def build_generator(\n    sys: base.System,\n    config: RCMG_Config = RCMG_Config(),\n    setup_fn: SETUP_FN = lambda key, sys: sys,\n    finalize_fn: FINALIZE_FN = lambda key, q, x, sys: (q, x),\n    randomize_positions: bool = False,\n) -&gt; Generator:\n    return GeneratorPipe(\n        GeneratorTrafoSetupFn(setup_fn),\n        GeneratorTrafoRandomizePositions()\n        if randomize_positions\n        else (lambda gen: gen),\n        GeneratorTrafoFinalizeFn(finalize_fn),\n        GeneratorTrafoRemoveInputExtras(sys),\n        GeneratorTrafoRemoveOutputExtras(),\n    )(config)\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.jcalc.RCMG_Config","title":"<code>RCMG_Config</code>  <code>dataclass</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>@dataclass\nclass RCMG_Config:\n    T: float = 60.0  # length of random motion\n    Ts: float = 0.01  # sampling rate\n    t_min: float = 0.05  # min time between two generated angles\n    t_max: float | TimeDependentFloat = 0.30  # max time ..\n\n    dang_min: float | TimeDependentFloat = 0.1  # minimum angular velocity in rad/s\n    dang_max: float | TimeDependentFloat = 3.0  # maximum angular velocity in rad/s\n\n    # minimum angular velocity of euler angles used for `free and spherical joints`\n    dang_min_free_spherical: float | TimeDependentFloat = 0.1\n    dang_max_free_spherical: float | TimeDependentFloat = 3.0\n\n    # max min allowed actual delta values in radians\n    delta_ang_min: float | TimeDependentFloat = 0.0\n    delta_ang_max: float | TimeDependentFloat = 2 * jnp.pi\n    delta_ang_min_free_spherical: float | TimeDependentFloat = 0.0\n    delta_ang_max_free_spherical: float | TimeDependentFloat = 2 * jnp.pi\n\n    dpos_min: float | TimeDependentFloat = 0.001  # speed of translation\n    dpos_max: float | TimeDependentFloat = 0.7\n    pos_min: float | TimeDependentFloat = -2.5\n    pos_max: float | TimeDependentFloat = +2.5\n\n    # used by both `random_angle_*` and `random_pos_*`\n    # only used if `randomized_interpolation` is set\n    cdf_bins_min: int = 5\n    # by default equal to `cdf_bins_min`\n    cdf_bins_max: Optional[int] = None\n\n    # flags\n    randomized_interpolation_angle: bool = False\n    randomized_interpolation_position: bool = False\n    interpolation_method: str = \"cosine\"\n    range_of_motion_hinge: bool = True\n    range_of_motion_hinge_method: str = \"uniform\"\n\n    # initial value of joints\n    ang0_min: float = -jnp.pi\n    ang0_max: float = jnp.pi\n    pos0_min: float = 0.0\n    pos0_max: float = 0.0\n\n    # cor (center of rotation) custom fields\n    cor: bool = False\n    cor_t_min: float = 0.2\n    cor_t_max: float | TimeDependentFloat = 2.0\n    cor_dpos_min: float | TimeDependentFloat = 0.00001\n    cor_dpos_max: float | TimeDependentFloat = 0.5\n    cor_pos_min: float | TimeDependentFloat = -0.4\n    cor_pos_max: float | TimeDependentFloat = 0.4\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.base.GeneratorPipe","title":"<code>GeneratorPipe</code>","text":"Source code in <code>x_xy/algorithms/generator/base.py</code> <pre><code>class GeneratorPipe:\n    def __init__(self, *gen_trafos: Sequence[GeneratorTrafo]):\n        self._gen_trafos = gen_trafos\n\n    def __call__(\n        self, config: RCMG_Config\n    ) -&gt; (\n        GeneratorWithInputOutputExtras\n        | GeneratorWithOutputExtras\n        | GeneratorWithInputExtras\n        | Generator\n    ):\n        gen = _generator_with_extras(config)\n        for trafo in self._gen_trafos:\n            gen = trafo(gen)\n        return gen\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.types.GeneratorTrafo","title":"<code>GeneratorTrafo</code>","text":"Source code in <code>x_xy/algorithms/generator/types.py</code> <pre><code>class GeneratorTrafo(Protocol):\n    def __call__(\n        self,\n        gen: GeneratorWithInputOutputExtras\n        | GeneratorWithOutputExtras\n        | GeneratorWithInputExtras,\n    ) -&gt; (\n        GeneratorWithInputOutputExtras\n        | GeneratorWithOutputExtras\n        | GeneratorWithInputExtras\n        | Generator\n    ):\n        ...\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.base.GeneratorTrafoRemoveInputExtras","title":"<code>GeneratorTrafoRemoveInputExtras</code>","text":"Source code in <code>x_xy/algorithms/generator/base.py</code> <pre><code>class GeneratorTrafoRemoveInputExtras(GeneratorTrafo):\n    def __init__(self, sys: base.System):\n        self.sys = sys\n\n    def __call__(\n        self,\n        gen: GeneratorWithInputExtras | GeneratorWithInputOutputExtras,\n    ) -&gt; Generator | GeneratorWithOutputExtras:\n        def _gen(key):\n            return gen(key, self.sys)\n\n        return _gen\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.base.GeneratorTrafoRemoveOutputExtras","title":"<code>GeneratorTrafoRemoveOutputExtras</code>","text":"Source code in <code>x_xy/algorithms/generator/base.py</code> <pre><code>class GeneratorTrafoRemoveOutputExtras(GeneratorTrafo):\n    def __call__(\n        self,\n        gen: GeneratorWithOutputExtras | GeneratorWithInputOutputExtras,\n    ) -&gt; Generator | GeneratorWithInputExtras:\n        def _gen(*args):\n            return gen(*args)[0]\n\n        return _gen\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.base.GeneratorTrafoRandomizePositions","title":"<code>GeneratorTrafoRandomizePositions</code>","text":"Source code in <code>x_xy/algorithms/generator/transforms.py</code> <pre><code>class GeneratorTrafoRandomizePositions(GeneratorTrafo):\n    def __call__(\n        self,\n        gen: GeneratorWithInputExtras | GeneratorWithInputOutputExtras,\n    ) -&gt; GeneratorWithInputExtras | GeneratorWithInputOutputExtras:\n        return GeneratorTrafoSetupFn(_setup_fn_randomize_positions)(gen)\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.jcalc.concat_configs","title":"<code>concat_configs(configs, boundaries)</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>def concat_configs(configs: list[RCMG_Config], boundaries: list[float]) -&gt; RCMG_Config:\n    assert len(configs) == (\n        len(boundaries) + 1\n    ), \"length of `boundaries` should be one less than length of `configs`\"\n    boundaries = jnp.array(boundaries, dtype=float)\n\n    def new_value(field: str):\n        scalar_options = jnp.array([getattr(c, field) for c in configs])\n\n        def scalar(t):\n            return jax.lax.dynamic_index_in_dim(\n                scalar_options, _find_interval(t, boundaries), keepdims=False\n            )\n\n        return scalar\n\n    hints = get_type_hints(RCMG_Config())\n    attrs = RCMG_Config().__dict__\n    is_time_dependent_field = lambda key: hints[key] == (float | TimeDependentFloat)\n    time_dependent_fields = [key for key in attrs if is_time_dependent_field(key)]\n    time_independent_fields = [key for key in attrs if not is_time_dependent_field(key)]\n\n    for time_dep_field in time_independent_fields:\n        field_values = set([getattr(config, time_dep_field) for config in configs])\n        assert (\n            len(field_values) == 1\n        ), f\"RCMG_Config.{time_dep_field}={field_values}. Should be one unique value..\"\n\n    changes = {field: new_value(field) for field in time_dependent_fields}\n    return replace(configs[0], **changes)\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.batch.batch_generator","title":"<code>batch_generator(generators, batchsizes=1, stochastic=False)</code>","text":"<p>Create a large generator by stacking multiple generators lazily. NOTE: If <code>stochastic</code> then <code>batchsizes</code> must be a single integer.</p> Source code in <code>x_xy/algorithms/generator/batch.py</code> <pre><code>def batch_generator(\n    generators: Generator | list[Generator],\n    batchsizes: int | list[int] = 1,\n    stochastic: bool = False,\n) -&gt; BatchedGenerator:\n\"\"\"Create a large generator by stacking multiple generators lazily.\n    NOTE: If `stochastic` then `batchsizes` must be a single integer.\n    \"\"\"\n    if not isinstance(generators, list):\n        # test if generator is already batched, then this is a no-op\n        key = jax.random.PRNGKey(0)\n        X, y = generators(key)\n        if tree_utils.tree_ndim(X) &gt; 2:\n            return generators\n\n    generators = utils.to_list(generators)\n\n    if stochastic:\n        assert isinstance(batchsizes, int)\n        bs_total = batchsizes\n        pmap, vmap = utils.distribute_batchsize(bs_total)\n    else:\n        batchsizes = utils.to_list(batchsizes)\n        assert len(generators) == len(batchsizes)\n\n        batch_arr_nonstoch = _build_batch_matrix(batchsizes)\n        bs_total = len(batch_arr_nonstoch)\n        pmap, vmap = utils.distribute_batchsize(bs_total)\n        batch_arr_nonstoch = batch_arr_nonstoch.reshape((pmap, vmap))\n\n    pmap_trafo = jax.pmap\n    # single GPU node, then do jit + vmap instead of pmap\n    # this allows e.g. better NAN debugging capabilities\n    if pmap == 1:\n        pmap_trafo = lambda f: jax.jit(jax.vmap(f))\n\n    @pmap_trafo\n    @jax.vmap\n    def _generator(key, which_gen: int):\n        return jax.lax.switch(which_gen, generators, key)\n\n    def generator(key):\n        if stochastic:\n            key, consume = jax.random.split(key)\n            batch_arr = jax.random.choice(\n                consume, jnp.arange(len(generators)), shape=(pmap, vmap)\n            )\n        else:\n            batch_arr = batch_arr_nonstoch\n\n        pmap_vmap_keys = jax.random.split(key, bs_total).reshape((pmap, vmap, 2))\n        data = _generator(pmap_vmap_keys, batch_arr)\n\n        # merge pmap and vmap axis\n        data = utils.merge_batchsize(data, pmap, vmap)\n\n        return data\n\n    return generator\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.batch.offline_generator","title":"<code>offline_generator(generators, sizes, batchsize, shuffle=True, drop_last=True, seed=1, store_on_cpu=True)</code>","text":"<p>Eagerly create a large precomputed generator by calling multiple generators and stacking their output.</p> Source code in <code>x_xy/algorithms/generator/batch.py</code> <pre><code>def offline_generator(\n    generators: Generator | list[Generator],\n    sizes: int | list[int],\n    batchsize: int,\n    shuffle: bool = True,\n    drop_last: bool = True,\n    seed: int = 1,\n    store_on_cpu: bool = True,\n) -&gt; BatchedGenerator:\n\"\"\"Eagerly create a large precomputed generator by calling multiple generators\n    and stacking their output.\"\"\"\n    assert drop_last, \"Not `drop_last` is currently not implemented.\"\n    generators, sizes = utils.to_list(generators), utils.to_list(sizes)\n    assert len(generators) == len(sizes)\n\n    key = jax.random.PRNGKey(seed)\n    data = []\n    for gen, size in tqdm(zip(generators, sizes), desc=\"offline generator\"):\n        key, consume = jax.random.split(key)\n        sample = batch_generator(gen, size)(consume)\n        if store_on_cpu:\n            sample = jax.device_put(sample, jax.devices(\"cpu\")[0])\n        data.extend([jax.tree_map(lambda a: a[i], sample) for i in range(size)])\n\n    N, i = len(data) // batchsize, 0\n    random.seed(seed)\n\n    def generator(key: jax.Array):\n        nonlocal i\n        del key\n        if shuffle and i == 0:\n            random.shuffle(data)\n\n        start, stop = i * batchsize, (i + 1) * batchsize\n        batch = tree_batch(data[start:stop], backend=\"jax\")\n        i = (i + 1) % N\n        return batch\n\n    return generator\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.forward_kinematics","title":"<code>forward_kinematics(sys, state)</code>","text":"<p>Perform forward kinematics in system. - Updates <code>transform</code> and <code>transform2</code> in <code>sys</code> - Updates <code>x</code> in <code>state</code></p> Source code in <code>x_xy/algorithms/kinematics.py</code> <pre><code>def forward_kinematics(\n    sys: base.System, state: base.State\n) -&gt; Tuple[base.System, base.State]:\n\"\"\"Perform forward kinematics in system.\n    - Updates `transform` and `transform2` in `sys`\n    - Updates `x` in `state`\n    \"\"\"\n    x, sys = forward_kinematics_transforms(sys, state.q)\n    state = state.replace(x=x)\n    return sys, state\n</code></pre>"},{"location":"api/kin_sim/#x_xy.algorithms.generator.utils.make_normalizer_from_generator","title":"<code>make_normalizer_from_generator(generator, approx_with_large_batchsize=512)</code>","text":"<p>Returns a pure function that normalizes <code>X</code>.</p> Source code in <code>x_xy/algorithms/generator/utils.py</code> <pre><code>def make_normalizer_from_generator(\n    generator: BatchedGenerator, approx_with_large_batchsize: int = 512\n) -&gt; Normalizer:\n    \"Returns a pure function that normalizes `X`.\"\n\n    # probe generator for its batchsize\n    X, _ = generator(KEY)\n    bs = tree_utils.tree_shape(X)\n    assert tree_utils.tree_ndim(X) == 3, \"`generator` must be batched.\"\n\n    # how often do we have to query the generator\n    number_of_gen_calls = math.ceil(approx_with_large_batchsize / bs)\n\n    Xs, key = [], KEY\n    for _ in range(number_of_gen_calls):\n        key, consume = jax.random.split(key)\n        Xs.append(generator(consume)[0])\n    Xs = tree_utils.tree_batch(Xs, True, \"jax\")\n    # permute 0-th axis, since batchsize of generator might be larger than\n    # `approx_with_large_batchsize`, then we would not get a representative\n    # subsample otherwise\n    Xs = jax.tree_map(lambda arr: jax.random.permutation(KEY_PERMUTATION, arr), Xs)\n    Xs = tree_utils.tree_slice(Xs, start=0, slice_size=approx_with_large_batchsize)\n\n    # obtain statistics\n    mean = jax.tree_map(lambda arr: jnp.mean(arr, axis=(0, 1)), Xs)\n    std = jax.tree_map(lambda arr: jnp.std(arr, axis=(0, 1)), Xs)\n\n    eps = 1e-8\n\n    def normalizer(X):\n        return jax.tree_map(lambda a, b, c: (a - b) / (c + eps), X, mean, std)\n\n    return normalizer\n</code></pre>"},{"location":"api/maths/","title":"x_xy.maths","text":""},{"location":"api/maths/#x_xy.maths.quat.quat_mul","title":"<code>quat_mul(u, v)</code>","text":"<p>Multiplies two quaternions.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4),(4)-&gt;(4)\")\ndef quat_mul(u: jnp.ndarray, v: jnp.ndarray) -&gt; jnp.ndarray:\n    \"Multiplies two quaternions.\"\n    q = jnp.array(\n        [\n            u[0] * v[0] - u[1] * v[1] - u[2] * v[2] - u[3] * v[3],\n            u[0] * v[1] + u[1] * v[0] + u[2] * v[3] - u[3] * v[2],\n            u[0] * v[2] - u[1] * v[3] + u[2] * v[0] + u[3] * v[1],\n            u[0] * v[3] + u[1] * v[2] - u[2] * v[1] + u[3] * v[0],\n        ]\n    )\n    return q\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_inv","title":"<code>quat_inv(q)</code>","text":"<p>Calculates the inverse of quaternion q.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_inv(q: jnp.ndarray) -&gt; jnp.ndarray:\n    \"Calculates the inverse of quaternion q.\"\n    return q * jnp.array([1.0, -1, -1, -1])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_random","title":"<code>quat_random(key, batch_shape=(), maxval=jnp.pi)</code>","text":"<p>Provides a random unit quaternion, sampled uniformly</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_random(\n    key: jrand.PRNGKey, batch_shape: tuple = (), maxval: float = jnp.pi\n) -&gt; jax.Array:\n\"\"\"Provides a random *unit* quaternion, sampled uniformly\"\"\"\n    shape = batch_shape + (4,)\n    qs = safe_normalize(jrand.normal(key, shape))\n\n    def _scale_angle():\n        axis, angle = quat_to_rot_axis(qs)\n        angle_scaled = angle * maxval / jnp.pi\n        return quat_rot_axis(axis, angle_scaled)\n\n    return jax.lax.cond(maxval == jnp.pi, lambda: qs, _scale_angle)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_rot_axis","title":"<code>quat_rot_axis(axis, angle)</code>","text":"<p>Construct a unit quaternion that describes rotating around <code>axis</code> by <code>angle</code> (radians).</p> <p>This is the interpretation of rotating the vector and not the frame. For the interpretation of rotating the frame and not the vector, you should use angle -&gt; -angle. NOTE: Usually, we actually want the second interpretation. Think about it, we use quaternions to re-express vectors in other frames. But the vectors stay the same. We only transform them to a common frames.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3),()-&gt;(4)\")\ndef quat_rot_axis(axis: jnp.ndarray, angle: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Construct a *unit* quaternion that describes rotating around\n    `axis` by `angle` (radians).\n\n    This is the interpretation of rotating the vector and *not*\n    the frame.\n    For the interpretation of rotating the frame and *not* the\n    vector, you should use angle -&gt; -angle.\n    NOTE: Usually, we actually want the second interpretation. Think about it,\n    we use quaternions to re-express vectors in other frames. But the\n    vectors stay the same. We only transform them to a common frames.\n    \"\"\"\n    assert axis.shape == (3,)\n    assert angle.shape == ()\n\n    axis = safe_normalize(axis)\n    # NOTE: CONVENTION\n    # 23.04.23\n    # this fixes the issue of prismatic joints being inverted w.r.t.\n    # gravity vector.\n    # The reason is that it inverts the way how revolute joints behave\n    # Such that prismatic joints work by inverting gravity\n    angle *= -1.0\n    s, c = jnp.sin(angle / 2), jnp.cos(angle / 2)\n    return jnp.array([c, *(axis * s)])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_rot_axis","title":"<code>quat_to_rot_axis(q)</code>","text":"<p>Extract unit-axis and angle from quaternion <code>q</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3),()\")\ndef quat_to_rot_axis(q):\n    \"Extract unit-axis and angle from quaternion `q`.\"\n    angle = quat_angle(q)\n    # NOTE: CONVENTION\n    angle *= -1.0\n    axis = safe_normalize(q[1:])\n    return axis, angle\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_euler","title":"<code>quat_euler(angles, intrinsic=True, convention='zyx')</code>","text":"<p>Construct a unit quaternion from Euler angles (radians).</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_euler(angles, intrinsic=True, convention=\"zyx\"):\n    \"Construct a *unit* quaternion from Euler angles (radians).\"\n\n    @partial(jnp.vectorize, signature=\"(3)-&gt;(4)\")\n    def _quat_euler(angles):\n        xunit = jnp.array([1.0, 0.0, 0.0])\n        yunit = jnp.array([0.0, 1.0, 0.0])\n        zunit = jnp.array([0.0, 0.0, 1.0])\n\n        axes_map = {\n            \"x\": xunit,\n            \"y\": yunit,\n            \"z\": zunit,\n        }\n\n        q1 = quat_rot_axis(axes_map[convention[0]], angles[0])\n        q2 = quat_rot_axis(axes_map[convention[1]], angles[1])\n        q3 = quat_rot_axis(axes_map[convention[2]], angles[2])\n\n        if intrinsic:\n            return quat_mul(q3, quat_mul(q2, q1))\n        else:\n            return quat_mul(q1, quat_mul(q2, q3))\n\n    return _quat_euler(angles)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_euler","title":"<code>quat_to_euler(q)</code>","text":"<p>Converts quaternions to euler rotations in radians.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3)\")\ndef quat_to_euler(q: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts quaternions to euler rotations in radians.\"\"\"\n    # this follows the Tait-Bryan intrinsic rotation formalism: x-y'-z''\n\n    # NOTE: CONVENTION\n    q = quat_inv(q)\n\n    z = jnp.arctan2(\n        -2 * q[1] * q[2] + 2 * q[0] * q[3],\n        q[1] * q[1] + q[0] * q[0] - q[3] * q[3] - q[2] * q[2],\n    )\n    # TODO: Investigate why quaternions go so big we need to clip.\n    y = safe_arcsin(jnp.clip(2 * q[1] * q[3] + 2 * q[0] * q[2], -1.0, 1.0))\n    x = jnp.arctan2(\n        -2 * q[2] * q[3] + 2 * q[0] * q[1],\n        q[3] * q[3] - q[2] * q[2] - q[1] * q[1] + q[0] * q[0],\n    )\n\n    return jnp.array([x, y, z])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_from_3x3","title":"<code>quat_from_3x3(m)</code>","text":"<p>Converts 3x3 rotation matrix to unit quaternion.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3,3)-&gt;(4)\")\ndef quat_from_3x3(m: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts 3x3 rotation matrix to *unit* quaternion.\"\"\"\n    w = jnp.sqrt(1 + m[0, 0] + m[1, 1] + m[2, 2]) / 2.0\n    x = (m[2][1] - m[1][2]) / (w * 4)\n    y = (m[0][2] - m[2][0]) / (w * 4)\n    z = (m[1][0] - m[0][1]) / (w * 4)\n    return jnp.array([w, x, y, z])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_3x3","title":"<code>quat_to_3x3(q)</code>","text":"<p>Converts unit quaternion to 3x3 rotation matrix.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3,3)\")\ndef quat_to_3x3(q: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts *unit* quaternion to 3x3 rotation matrix.\"\"\"\n    d = jnp.dot(q, q)\n    w, x, y, z = q\n    s = 2 / d\n    xs, ys, zs = x * s, y * s, z * s\n    wx, wy, wz = w * xs, w * ys, w * zs\n    xx, xy, xz = x * xs, x * ys, x * zs\n    yy, yz, zz = y * ys, y * zs, z * zs\n\n    return jnp.array(\n        [\n            jnp.array([1 - (yy + zz), xy - wz, xz + wy]),\n            jnp.array([xy + wz, 1 - (xx + zz), yz - wx]),\n            jnp.array([xz - wy, yz + wx, 1 - (xx + yy)]),\n        ]\n    )\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_project","title":"<code>quat_project(q, k)</code>","text":"<p>Decompose quaternion into a primary rotation around axis <code>k</code> such that the residual rotation's angle is minimized.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Array</code> <p>Quaternion to decompose.</p> required <code>k</code> <code>Array</code> <p>Primary axis direction.</p> required <p>Returns:</p> Type Description <code>tuple[Array, Array]</code> <p>tuple[jax.Array, jax.Array]: Primary quaternion, residual quaternion</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4),(3)-&gt;(4),(4)\")\ndef quat_project(q: jax.Array, k: jax.Array) -&gt; tuple[jax.Array, jax.Array]:\n\"\"\"Decompose quaternion into a primary rotation around axis `k` such that\n    the residual rotation's angle is minimized.\n\n    Args:\n        q (jax.Array): Quaternion to decompose.\n        k (jax.Array): Primary axis direction.\n\n    Returns:\n        tuple[jax.Array, jax.Array]: Primary quaternion, residual quaternion\n    \"\"\"\n    phi_pri = 2 * jnp.arctan2(q[1:] @ k, q[0])\n    # NOTE: CONVENTION\n    q_pri = quat_rot_axis(k, -phi_pri)\n    q_res = quat_mul(q, quat_inv(q_pri))\n    return q_pri, q_res\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_avg","title":"<code>quat_avg(qs)</code>","text":"<p>Tolga Birdal's algorithm.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_avg(qs: jax.Array):\n    \"Tolga Birdal's algorithm.\"\n    if qs.ndim == 1:\n        qs = qs[None, :]\n    assert qs.ndim == 2\n    return jnp.linalg.eigh(\n        jnp.einsum(\"ij,ik,i-&gt;...jk\", qs, qs, jnp.ones((qs.shape[0],)))\n    )[1][:, -1]\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_lowpassfilter","title":"<code>quat_lowpassfilter(qs, alpha=0.55)</code>","text":"Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_lowpassfilter(qs: jax.Array, alpha: float = 0.55) -&gt; jax.Array:\n    def f(y, x):\n        # error quaternion; current state -&gt; target\n        q_err = quat_mul(x, quat_inv(y))\n        # scale down error quaternion\n        axis, angle = quat_to_rot_axis(q_err)\n        # ensure angle &gt;= 0\n        axis, angle = jax.lax.cond(\n            angle &lt; 0,\n            lambda axis, angle: (-axis, -angle),\n            lambda axis, angle: (axis, angle),\n            axis,\n            angle,\n        )\n        angle_scaled = angle * alpha\n        q_err_scaled = quat_rot_axis(axis, angle_scaled)\n        # move small step toward error quaternion\n        y = quat_mul(q_err_scaled, y)\n        return y, y\n\n    qs_filtered = jax.lax.scan(f, qs[0], qs[1:])[1]\n    return jnp.vstack((qs[0:1], qs_filtered))\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.rotate","title":"<code>rotate(vector, quat)</code>","text":"<p>Rotates a vector <code>vector</code> by a unit quaternion <code>quat</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3),(4)-&gt;(3)\")\ndef rotate(vector: jnp.ndarray, quat: jnp.ndarray):\n\"\"\"Rotates a vector `vector` by a *unit* quaternion `quat`.\"\"\"\n    qvec = jnp.array([0, *vector])\n    return rotate_quat(qvec, quat)[1:4]\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.rotate_quat","title":"<code>rotate_quat(q, quat)</code>","text":"<p>Rotate quaternion <code>q</code> by <code>quat</code></p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def rotate_quat(q: jax.Array, quat: jax.Array):\n    \"Rotate quaternion `q` by `quat`\"\n    return quat_mul(quat, quat_mul(q, quat_inv(quat)))\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.angle_error","title":"<code>angle_error(q, qhat)</code>","text":"<p>Absolute angle in radians between <code>q</code> and <code>qhat</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def angle_error(q, qhat):\n    \"Absolute angle in radians between `q` and `qhat`.\"\n    return jnp.abs(quat_angle(quat_mul(quat_inv(q), qhat)))\n</code></pre>"},{"location":"api/maths/#x_xy.maths.safe.safe_normalize","title":"<code>safe_normalize(x)</code>","text":"<p>Execution- and Grad-safe for x=0.0. Normalizes along last axis.</p> Source code in <code>x_xy/maths/safe.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(k)-&gt;(k)\")\ndef safe_normalize(x):\n\"\"\"Execution- and Grad-safe for x=0.0. Normalizes along last axis.\"\"\"\n    assert x.ndim == 1\n\n    is_zero = jnp.allclose(x, 0.0)\n    return jax.lax.cond(\n        is_zero,\n        lambda x: jnp.zeros_like(x),\n        lambda x: x / jnp.where(is_zero, 1.0, safe_norm(x)),\n        x,\n    )\n</code></pre>"},{"location":"api/maths/#x_xy.maths.basic.wrap_to_pi","title":"<code>wrap_to_pi(phi)</code>","text":"<p>Wraps angle <code>phi</code> (radians) to interval [-pi, pi].</p> Source code in <code>x_xy/maths/basic.py</code> <pre><code>def wrap_to_pi(phi):\n    \"Wraps angle `phi` (radians) to interval [-pi, pi].\"\n    return (phi + jnp.pi) % (2 * jnp.pi) - jnp.pi\n</code></pre>"},{"location":"api/ml/","title":"ml","text":""},{"location":"api/ml/#x_xy.subpkgs.ml.rnno.make_rnno","title":"<code>make_rnno(sys, hidden_state_dim=400, message_dim=200, use_gru=True, stack_rnn_cells=1, send_message_n_layers=1, send_message_method='mlp', send_message_init=hk.initializers.Orthogonal(), send_message_stop_grads=False, link_output_dim=4, link_output_normalize=True, link_output_transform=None)</code>","text":"<p>Expects batched inputs.</p> Source code in <code>x_xy/subpkgs/ml/rnno.py</code> <pre><code>def make_rnno(\n    sys: base.System,\n    hidden_state_dim: int = 400,\n    message_dim: int = 200,\n    use_gru: bool = True,\n    stack_rnn_cells: int = 1,\n    send_message_n_layers: int = 1,\n    send_message_method: str = \"mlp\",\n    send_message_init: hk.initializers.Initializer = hk.initializers.Orthogonal(),\n    send_message_stop_grads: bool = False,\n    link_output_dim: int = 4,\n    link_output_normalize: bool = True,\n    link_output_transform: Optional[Callable] = None,\n) -&gt; SimpleNamespace:\n    \"Expects batched inputs.\"\n\n    if use_gru:\n        cell = hk.GRU\n        hidden_state_init = hidden_state_dim\n    else:\n        cell = LSTM\n        hidden_state_init = hidden_state_dim * 2\n\n    if link_output_normalize:\n        assert link_output_transform is None\n        link_output_transform = safe_normalize\n\n    @hk.without_apply_rng\n    @hk.transform_with_state\n    def forward(X):\n        if send_message_method == \"mlp\":\n            send_msg = hk.nets.MLP(\n                [hidden_state_dim] * send_message_n_layers + [message_dim]\n            )\n        elif send_message_method == \"matrix\":\n            matrix = hk.get_state(\n                \"send_msg_matrix\",\n                [message_dim, hidden_state_dim],\n                init=send_message_init,\n            )\n            send_msg = lambda hidden_state: matrix @ hidden_state\n        else:\n            raise NotImplementedError\n\n        inner_cell = StackedRNNCell(cell, hidden_state_dim, stack_rnn_cells)\n        send_output = hk.nets.MLP([hidden_state_dim, link_output_dim])\n        state = hk.get_state(\n            \"inner_cell_state\",\n            [sys.num_links(), stack_rnn_cells, hidden_state_init],\n            init=jnp.zeros,\n        )\n\n        y, state = hk.dynamic_unroll(\n            _make_rnno_cell_apply_fn(\n                sys,\n                inner_cell,\n                send_msg,\n                send_output,\n                hidden_state_dim,\n                message_dim,\n                send_message_stop_grads,\n                output_transform=link_output_transform,\n            ),\n            X,\n            state,\n        )\n        hk.set_state(\"inner_cell_state\", state)\n        return y\n\n    def init(key, X):\n        \"X.shape (bs, timesteps, features)\"\n        X = tree_utils.to_2d_if_3d(X, strict=True)\n        return forward.init(key, X)\n\n    def apply(params, state, X):\n\"\"\"\n        params: (features)\n        state.shape (bs, features)\n        X.shape (bs, timesteps, features)\n\n        Returns: (yhat, state)\n        yhat.shape (bs, timesteps, features)\n        state.shape (bs, features)\n        \"\"\"\n        assert tree_utils.tree_ndim(X) == 3\n        return jax.vmap(forward.apply, in_axes=(None, 0, 0))(params, state, X)\n\n    return SimpleNamespace(init=init, apply=apply)\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.train.train","title":"<code>train(generator, n_episodes, network, optimizer=None, tbp=1000, tbp_skip=0, tbp_skip_keep_grads=False, loggers=[], callbacks=[], initial_params=None, key_network=key_network, key_generator=key_generator, callback_save_params=None, callback_save_params_track_metrices=None, callback_kill_if_grads_larger=None, callback_kill_if_nan=False, callback_kill_after_episode=None, callback_kill_after_seconds=None, loss_fn=_default_loss_fn, metrices=_default_metrices)</code>","text":"<p>Trains RNNO</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>Callable</code> <p>output of the rcmg-module</p> required <code>n_episodes</code> <code>int</code> <p>number of episodes to train for</p> required <code>network</code> <code>TransformedWithState</code> <p>RNNO network</p> required <code>optimizer</code> <code>_type_</code> <p>optimizer, see optimizer.py module</p> <code>None</code> <code>tbp</code> <code>int</code> <p>Truncated backpropagation through time step size</p> <code>1000</code> <code>tbp_skip</code> <code>int</code> <p>Skip <code>tbp_skip</code> number of first steps per epoch.</p> <code>0</code> <code>tbp_skip_keep_grads</code> <code>bool</code> <p>Keeps grads between first <code>tbp_skip</code> steps per epoch.</p> <code>False</code> <code>loggers</code> <code>list[Logger]</code> <p>list of Loggers used to log the training progress.</p> <code>[]</code> <code>callbacks</code> <code>list[TrainingLoopCallback]</code> <p>callbacks of the TrainingLoop.</p> <code>[]</code> <code>initial_params</code> <code>Optional[dict]</code> <p>If given uses as initial parameters.</p> <code>None</code> <code>key_network</code> <code>PRNGKey</code> <p>PRNG Key that inits the network state and parameters.</p> <code>key_network</code> <code>key_generator</code> <code>PRNGKey</code> <p>PRNG Key that inits the data stream of the generator.</p> <code>key_generator</code> Source code in <code>x_xy/subpkgs/ml/train.py</code> <pre><code>def train(\n    generator: Callable,\n    n_episodes: int,\n    network: hk.TransformedWithState,\n    optimizer: Optional[optax.GradientTransformation] = None,\n    tbp: int = 1000,\n    tbp_skip: int = 0,\n    tbp_skip_keep_grads: bool = False,\n    loggers: list[Logger] = [],\n    callbacks: list[TrainingLoopCallback] = [],\n    initial_params: Optional[dict] = None,\n    key_network: jax.random.PRNGKey = key_network,\n    key_generator: jax.random.PRNGKey = key_generator,\n    callback_save_params: Optional[str] = None,\n    callback_save_params_track_metrices: Optional[list[list[str]]] = None,\n    callback_kill_if_grads_larger: Optional[float] = None,\n    callback_kill_if_nan: bool = False,\n    callback_kill_after_episode: Optional[int] = None,\n    callback_kill_after_seconds: Optional[float] = None,\n    loss_fn: LOSS_FN = _default_loss_fn,\n    metrices: METRICES = _default_metrices,\n):\n\"\"\"Trains RNNO\n\n    Args:\n        generator (Callable): output of the rcmg-module\n        n_episodes (int): number of episodes to train for\n        network (hk.TransformedWithState): RNNO network\n        optimizer (_type_, optional): optimizer, see optimizer.py module\n        tbp (int, optional): Truncated backpropagation through time step size\n        tbp_skip (int, optional): Skip `tbp_skip` number of first steps per epoch.\n        tbp_skip_keep_grads (bool, optional): Keeps grads between first `tbp_skip`\n            steps per epoch.\n        loggers: list of Loggers used to log the training progress.\n        callbacks: callbacks of the TrainingLoop.\n        initial_params: If given uses as initial parameters.\n        key_network: PRNG Key that inits the network state and parameters.\n        key_generator: PRNG Key that inits the data stream of the generator.\n    \"\"\"\n\n    # test if generator is batched..\n    key = jax.random.PRNGKey(0)\n    X, _ = generator(key)\n\n    if tree_utils.tree_ndim(X) == 2:\n        # .. if not then batch it\n        generator = x_xy.algorithms.batch_generator(generator, 1)\n\n    # .. now it most certainly is; Queue it for data\n    X, _ = generator(key)\n\n    batchsize = tree_utils.tree_shape(X)\n    pmap_size, vmap_size = distribute_batchsize(batchsize)\n\n    params, initial_state = network.init(\n        key_network,\n        X,\n    )\n    initial_state = _repeat_state(initial_state, batchsize)\n\n    if initial_params is not None:\n        params = initial_params\n    del initial_params\n\n    if optimizer is None:\n        # TODO; hardcoded `n_steps_per_episode`\n        optimizer = make_optimizer(3e-3, n_episodes, n_steps_per_episode=6)\n\n    opt_state = optimizer.init(params)\n\n    step_fn = _build_step_fn(\n        loss_fn,\n        network.apply,\n        initial_state,\n        pmap_size,\n        vmap_size,\n        optimizer,\n        tbp=tbp,\n        tbp_skip=tbp_skip,\n        tbp_skip_keep_grads=tbp_skip_keep_grads,\n    )\n\n    eval_fn = _build_eval_fn(\n        metrices, network.apply, initial_state, pmap_size, vmap_size\n    )\n\n    default_callbacks = [_DefaultEvalFnCallback(eval_fn), WandbKillRun()]\n\n    if callback_save_params is not None:\n        default_callbacks.append(SaveParamsTrainingLoopCallback(callback_save_params))\n\n    if callback_kill_if_grads_larger is not None:\n        default_callbacks.append(\n            LogGradsTrainingLoopCallBack(\n                callback_kill_if_grads_larger, consecutive_larger=18\n            )\n        )\n\n    if callback_kill_if_nan:\n        default_callbacks.append(NanKillRunCallback())\n\n    # always log, because we also want `i_epsiode` to be logged in wandb\n    default_callbacks.append(\n        LogEpisodeTrainingLoopCallback(callback_kill_after_episode)\n    )\n\n    if callback_kill_after_seconds is not None:\n        default_callbacks.append(TimingKillRunCallback(callback_kill_after_seconds))\n\n    callbacks_all = default_callbacks + callbacks\n\n    # we add this callback afterwards because it might require the metrices calculated\n    # from one of the user-provided callbacks\n    if callback_save_params_track_metrices is not None:\n        assert (\n            callback_save_params is not None\n        ), \"Required field if `callback_save_params_track_metrices` is set.\"\n\n        callbacks_all.append(\n            SaveParamsTrainingLoopCallback(\n                path_to_file=parse_path(callback_save_params, extension=\"\"),\n                last_n_params=3,\n                track_metrices=callback_save_params_track_metrices,\n                cleanup=True,\n            )\n        )\n\n    loop = TrainingLoop(\n        key_generator,\n        generator,\n        params,\n        opt_state,\n        step_fn,\n        loggers=loggers,\n        callbacks=callbacks_all,\n    )\n\n    loop.run(n_episodes)\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.optimizer.make_optimizer","title":"<code>make_optimizer(lr, n_episodes, n_steps_per_episode, adap_clip=0.1, glob_clip=0.2, skip_large_update_max_normsq=5.0, skip_large_update_warmup=300, inner_opt=optax.lamb, **inner_opt_kwargs)</code>","text":"Source code in <code>x_xy/subpkgs/ml/optimizer.py</code> <pre><code>def make_optimizer(\n    lr: float,\n    n_episodes: int,\n    n_steps_per_episode: int,\n    adap_clip: Optional[float] = 0.1,\n    glob_clip: Optional[float] = 0.2,\n    skip_large_update_max_normsq: float = 5.0,\n    skip_large_update_warmup: int = 300,\n    inner_opt=optax.lamb,\n    **inner_opt_kwargs\n):\n    steps = n_steps_per_episode * n_episodes\n    schedule = optax.cosine_decay_schedule(lr, steps, 1e-7)\n    optimizer = optax.chain(\n        optax.adaptive_grad_clip(adap_clip)\n        if adap_clip is not None\n        else optax.identity(),\n        optax.clip_by_global_norm(0.2) if glob_clip is not None else optax.identity(),\n        inner_opt(schedule, **inner_opt_kwargs),\n    )\n    optimizer = skip_large_update(\n        optimizer,\n        skip_large_update_max_normsq,\n        max_consecutive_toolarge=6 * 25,\n        warmup=skip_large_update_warmup,\n    )\n    return optimizer\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.callbacks.EvalXy2TrainingLoopCallback","title":"<code>EvalXy2TrainingLoopCallback</code>","text":"Source code in <code>x_xy/subpkgs/ml/callbacks.py</code> <pre><code>class EvalXy2TrainingLoopCallback(TrainingLoopCallback):\n    def __init__(\n        self,\n        exp_name: str,\n        rnno_fn,\n        sys_noimu,\n        eval_metrices: dict[str, Tuple[Callable, Callable, Callable]],\n        X: dict,\n        y: dict,\n        xs: base.Transform,\n        sys_xs,\n        metric_identifier: str,\n        render_plot_metric: str,\n        eval_every: int = 5,\n        render_plot_every: int = 50,\n        maximal_error: bool | list[bool] = True,\n        plot: bool = False,\n        render: bool = False,\n        upload: bool = True,\n        save2disk: bool = False,\n        render_0th_epoch: bool = True,\n        verbose: bool = True,\n        show_cs: bool = False,\n        show_cs_root: bool = True,\n    ):\n        \"X, y is batched.\"\n\n        network = rnno_fn(sys_noimu)\n        self.sys_noimu, self.sys_xs = sys_noimu, sys_xs\n        self.X, self.y, self.xs = X, y, xs\n        self.plot, self.render = plot, render\n        self.upload = upload\n        self.save2disk = save2disk\n        self.render_plot_metric = render_plot_metric\n        self.maximal_error = (\n            maximal_error if isinstance(maximal_error, list) else [maximal_error]\n        )\n        self.rnno_fn = rnno_fn\n        self.path = f\"~/experiments/{exp_name}\"\n\n        # delete batchsize dimension for init of state\n        consume = jax.random.PRNGKey(1)\n        _, initial_state = network.init(consume, X)\n        batchsize = tree_utils.tree_shape(X)\n        self.eval_fn = _build_eval_fn2(\n            eval_metrices,\n            network.apply,\n            _repeat_state(initial_state, batchsize),\n            *distribute_batchsize(batchsize),\n        )\n        self.eval_every = eval_every\n        self.render_plot_every = render_plot_every\n        self.metric_identifier = metric_identifier\n        self.render_0th_epoch = render_0th_epoch\n        self.verbose = verbose\n        self.show_cs, self.show_cs_root = show_cs, show_cs_root\n\n    def after_training_step(\n        self,\n        i_episode: int,\n        metrices: dict,\n        params: dict,\n        grads: list[dict],\n        sample_eval: dict,\n        loggers: list[Logger],\n    ):\n        self._params = params\n        self._loggers = loggers\n        self.i_episode = i_episode\n\n        if self.eval_every == -1:\n            return\n\n        if (i_episode % self.eval_every) == 0:\n            point_estimates, self.per_seq = self.eval_fn(params, self.X, self.y)\n            self.last_metrices = {self.metric_identifier: point_estimates}\n        metrices.update(self.last_metrices)\n\n        if (i_episode % self.render_plot_every) == 0:\n            if i_episode != 0 or self.render_0th_epoch:\n                self._render_plot()\n\n    def close(self):\n        self._render_plot()\n\n    def _render_plot(self):\n        return\n        if not self.plot and not self.render:\n            return\n\n        for maximal_error in self.maximal_error:\n            reduce = jnp.argmax if maximal_error else jnp.argmin\n            idx = reduce(\n                jnp.mean(\n                    tree_utils.batch_concat(self.per_seq[self.render_plot_metric]),\n                    axis=-1,\n                )\n            )\n            X, y, xs = tree_utils.tree_slice((self.X, self.y, self.xs), idx)\n\n            def filename(prefix: str):\n                return (\n                    f\"{prefix}_{self.metric_identifier}_{self.render_plot_metric}_\"\n                    f\"idx={idx}_episode={self.i_episode}_maxError={int(maximal_error)}\"\n                )\n\n            render_path = parse_path(\n                self.path,\n                \"videos\",\n                filename(\"animation\"),\n                extension=\"mp4\",\n            )\n\n            if self.verbose:\n                print(f\"--- EvalFnCallback {self.metric_identifier} --- \")\n\n\"\"\"pipeline.predict(\n                self.sys_noimu,\n                self.rnno_fn,\n                X,\n                y,\n                xs,\n                self.sys_xs,\n                self._params,\n                plot=self.plot,\n                render=self.render,\n                render_path=render_path,\n                verbose=self.verbose,\n                show_cs=self.show_cs,\n                show_cs_root=self.show_cs_root,\n            )\"\"\"\n\n            plot_path = parse_path(\n                self.path,\n                \"plots\",\n                filename(\"plot\"),\n                extension=\"png\",\n            )\n            if self.plot:\n                import matplotlib.pyplot as plt\n\n                plt.savefig(plot_path, dpi=300)\n                plt.close()\n\n            if self.upload:\n                logger = _find_multimedia_logger(self._loggers)\n                if self.render:\n                    logger.log_video(render_path, step=self.i_episode)\n                if self.plot:\n                    logger.log_image(plot_path)\n\n            if not self.save2disk:\n                for path in [render_path, plot_path]:\n                    if Path(path).exists():\n                        os.system(f\"rm {path}\")\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.callbacks.EvalXy2TrainingLoopCallback.__init__","title":"<code>__init__(exp_name, rnno_fn, sys_noimu, eval_metrices, X, y, xs, sys_xs, metric_identifier, render_plot_metric, eval_every=5, render_plot_every=50, maximal_error=True, plot=False, render=False, upload=True, save2disk=False, render_0th_epoch=True, verbose=True, show_cs=False, show_cs_root=True)</code>","text":"<p>X, y is batched.</p> Source code in <code>x_xy/subpkgs/ml/callbacks.py</code> <pre><code>def __init__(\n    self,\n    exp_name: str,\n    rnno_fn,\n    sys_noimu,\n    eval_metrices: dict[str, Tuple[Callable, Callable, Callable]],\n    X: dict,\n    y: dict,\n    xs: base.Transform,\n    sys_xs,\n    metric_identifier: str,\n    render_plot_metric: str,\n    eval_every: int = 5,\n    render_plot_every: int = 50,\n    maximal_error: bool | list[bool] = True,\n    plot: bool = False,\n    render: bool = False,\n    upload: bool = True,\n    save2disk: bool = False,\n    render_0th_epoch: bool = True,\n    verbose: bool = True,\n    show_cs: bool = False,\n    show_cs_root: bool = True,\n):\n    \"X, y is batched.\"\n\n    network = rnno_fn(sys_noimu)\n    self.sys_noimu, self.sys_xs = sys_noimu, sys_xs\n    self.X, self.y, self.xs = X, y, xs\n    self.plot, self.render = plot, render\n    self.upload = upload\n    self.save2disk = save2disk\n    self.render_plot_metric = render_plot_metric\n    self.maximal_error = (\n        maximal_error if isinstance(maximal_error, list) else [maximal_error]\n    )\n    self.rnno_fn = rnno_fn\n    self.path = f\"~/experiments/{exp_name}\"\n\n    # delete batchsize dimension for init of state\n    consume = jax.random.PRNGKey(1)\n    _, initial_state = network.init(consume, X)\n    batchsize = tree_utils.tree_shape(X)\n    self.eval_fn = _build_eval_fn2(\n        eval_metrices,\n        network.apply,\n        _repeat_state(initial_state, batchsize),\n        *distribute_batchsize(batchsize),\n    )\n    self.eval_every = eval_every\n    self.render_plot_every = render_plot_every\n    self.metric_identifier = metric_identifier\n    self.render_0th_epoch = render_0th_epoch\n    self.verbose = verbose\n    self.show_cs, self.show_cs_root = show_cs, show_cs_root\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.ml_utils.load","title":"<code>load(path=None, pretrained=None, pretrained_version=None)</code>","text":"Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>def load(\n    path: Optional[Union[str, Path]] = None,\n    pretrained: Optional[str] = None,\n    pretrained_version: Optional[int] = None,\n) -&gt; PyTree:\n    assert not (\n        path is None and pretrained is None\n    ), \"Either `path` or `pretrained` must be given.\"\n    assert not (\n        path is not None and pretrained is not None\n    ), \"Both `path` and `pretrained` cannot both be given.\"\n\n    if pretrained_version is not None:\n        assert pretrained is not None\n\n    if path is not None:\n        path = Path(path).expanduser()\n        if not path.is_file():\n            raise ValueError(f\"Not a file: {path}\")\n        if path.suffix != suffix:\n            raise ValueError(f\"Not a {suffix} file: {path}\")\n        with open(path, \"rb\") as file:\n            data = pickle.load(file)\n        return data\n    else:\n        version = \"\"\n        if pretrained_version is not None:\n            # v0, v1, v2, ...\n            version = f\"_v{int(pretrained_version)}\"\n        path_in_repo = f\"params/{pretrained}/params_{pretrained}{version}{suffix}\"\n        path_on_disk = download_from_repo(path_in_repo)\n        return load(path_on_disk)\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.ml_utils.save","title":"<code>save(data, path, overwrite=False)</code>","text":"Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>def save(data: PyTree, path: Union[str, Path], overwrite: bool = False):\n    path = Path(path).expanduser()\n    if path.suffix != suffix:\n        path = path.with_suffix(suffix)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if path.exists():\n        if overwrite:\n            path.unlink()\n        else:\n            raise RuntimeError(f\"File {path} already exists.\")\n    with open(path, \"wb\") as file:\n        pickle.dump(data, file)\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.ml_utils.list_pretrained","title":"<code>list_pretrained()</code>","text":"<p>Open Github repo that hosts the pretrained parameters.</p> Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>def list_pretrained() -&gt; None:\n    \"Open Github repo that hosts the pretrained parameters.\"\n    url = \"https://github.com/SimiPixel/x_xy_v2_datahost/tree/main/params\"\n    webbrowser.open(url)\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.ml_utils.n_params","title":"<code>n_params(params)</code>","text":"<p>Number of parameters in Pytree <code>params</code>.</p> Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>def n_params(params) -&gt; int:\n    \"Number of parameters in Pytree `params`.\"\n    return sum([arr.flatten().size for arr in jax.tree_util.tree_leaves(params)])\n</code></pre>"},{"location":"api/ml/#x_xy.subpkgs.ml.ml_utils.WandbLogger","title":"<code>WandbLogger</code>","text":"Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>class WandbLogger(MultimediaLogger):\n    def __init__(self):\n        _log_environment(self)\n        wandb.run.define_metric(STEP_METRIC_NAME)\n\n    def log_key_value(self, key: str, value: str | float, step: Optional[int] = None):\n        data = {key: value}\n        if step is not None:\n            data.update({STEP_METRIC_NAME: step})\n        wandb.log(data)\n\n    def log_params(self, path: str):\n        self._print_upload_file(path)\n        wandb.save(path, policy=\"now\")\n\n    def log_video(\n        self,\n        path: str,\n        fps: int = 25,\n        caption: Optional[str] = None,\n        step: Optional[int] = None,\n    ):\n        # TODO &gt;&gt;&gt;\n        wandb.save(path, policy=\"now\")\n        return\n        # &lt;&lt;&lt;\n        data = {\"video\": wandb.Video(path, caption=caption, fps=fps)}\n        if step is not None:\n            data.update({STEP_METRIC_NAME: step})\n        wandb.log(data)\n\n    def log_image(self, path: str, caption: Optional[str] = None):\n        # wandb.log({\"image\": wandb.Image(path, caption=caption)})\n        wandb.save(path, policy=\"now\")\n\n    def log_txt(self, path: str, wait: bool = True):\n        wandb.save(path, policy=\"now\")\n        # TODO: `wandb` is not async at all?\n        if wait:\n            time.sleep(3)\n\n    @staticmethod\n    def disable():\n        os.environ[\"WANDB_MODE\"] = \"offline\"\n\n    def close(self):\n        wandb.run.finish()\n</code></pre>"},{"location":"api/omc/","title":"omc","text":""},{"location":"api/omc/#x_xy.subpkgs.omc.read_omc","title":"<code>read_omc(path_marker_imu_setup_file, path_optitrack_file, path_imu_folder, segment_names_setup_file=['seg1', 'seg2', 'seg3', 'seg4', 'seg5'], imu_names_setup_file=['imu_rigid', 'imu_flex'], imu_file_prefix=None, imu_file_delimiter=None, qEOpt2EImu_euler_deg=np.array([0.0, 0, 0]), qImu2Seg_euler_deg={}, imu_sync_offset=None, hz_opt=None, hz_imu=None, verbose=True)</code>","text":"Source code in <code>x_xy/subpkgs/omc/omc.py</code> <pre><code>def read_omc(\n    path_marker_imu_setup_file: str,\n    path_optitrack_file: str,\n    path_imu_folder: str,\n    segment_names_setup_file: list[str] = [\"seg1\", \"seg2\", \"seg3\", \"seg4\", \"seg5\"],\n    imu_names_setup_file: list[str] = [\"imu_rigid\", \"imu_flex\"],\n    imu_file_prefix: Optional[str] = None,\n    imu_file_delimiter: Optional[str] = None,\n    # zyx convention\n    qEOpt2EImu_euler_deg: np.ndarray = np.array([0.0, 0, 0]),\n    # if imu and seg not in `q_Imu2seg[seg][imu]`, then [0, 0, 0]\n    # also zyx convention\n    qImu2Seg_euler_deg: dict = {},\n    imu_sync_offset: Optional[dict] = None,\n    hz_opt: Optional[int] = None,\n    hz_imu: Optional[int] = None,\n    verbose: bool = True,\n) -&gt; dict:\n    p_setup_file = parse_path(path_marker_imu_setup_file, extension=\"json\")\n    path_optitrack = parse_path(path_optitrack_file, extension=\"csv\")\n    path_imu = parse_path(path_imu_folder)\n\n    with open(p_setup_file) as f:\n        marker_imu_setup = json.load(f)\n\n    if hz_opt is None:\n        hz_opt = autodetermine_optitrack_freq(path_optitrack)\n        if verbose:\n            print(f\"OMC Hz: {hz_opt}\")\n\n    if hz_imu is None:\n        hz_imu = autodetermine_imu_freq(path_imu)\n        if verbose:\n            print(f\"IMU Hz: {hz_imu}\")\n\n    if imu_file_prefix is None:\n        imu_file_prefix = autodetermine_imu_file_prefix(path_imu)\n        if verbose:\n            print(f\"IMU File Prefix: {imu_file_prefix}\")\n\n    if imu_file_delimiter is None:\n        imu_file_delimiter = autodetermine_imu_file_delimiter(path_imu)\n        if verbose:\n            print(f\"IMU File Delimiter: {imu_file_delimiter}\")\n\n    data = {}\n    if imu_sync_offset is None:\n        imu_sync_offset = {}\n\n    for seg in segment_names_setup_file:\n        data[seg] = {}\n        if seg not in imu_sync_offset:\n            imu_sync_offset[seg] = {}\n\n        seg_number = int(seg[3])\n        xaxis_markers = marker_imu_setup[seg][\"xaxis_markers\"][0]\n        yaxis_markers = marker_imu_setup[seg][\"yaxis_markers\"][0]\n\n        quat_opt_markers2EOpt = _construct_quat_from_three_markers(\n            path_optitrack, seg_number, xaxis_markers, yaxis_markers, marker_imu_setup\n        )\n\n        imus = {}\n        for imu in imu_names_setup_file:\n            imu_number = marker_imu_setup[seg][imu]\n            imu_unsynced = _imu_measurements_from_txt(\n                path_imu, imu_file_prefix, imu_number, imu_file_delimiter\n            )\n            if imu not in imu_sync_offset[seg]:\n                imu_sync_offset[seg][imu] = _sync_imu_offset_with_optical(\n                    imu_unsynced, quat_opt_markers2EOpt, hz_imu, hz_opt\n                )\n            if verbose:\n                print(\n                    f\"Segment: {seg_number}, IMU: {imu_number}, Offset: \"\n                    f\"{imu_sync_offset[seg][imu]}\"\n                )\n\n            assert (\n                imu_sync_offset[seg][imu] &gt;= 0\n            ), f\"IMU sync offset negative, {imu_sync_offset[seg][imu]}\"\n            imu_synced = jax.tree_map(\n                lambda arr: arr[imu_sync_offset[seg][imu] :], imu_unsynced\n            )\n            imus[imu] = imu_synced\n\n            # alignment: rigid-imu to markers\n            q_Imu2Seg_default = np.array([1.0, 0, 0, 0])\n            if seg in qImu2Seg_euler_deg:\n                if imu in qImu2Seg_euler_deg[seg]:\n                    q_Imu2Seg_default = _from_euler(qImu2Seg_euler_deg[seg][imu])\n\n            for signal in [\"acc\", \"mag\", \"gyr\"]:\n                imus[imu][signal] = qmt.rotate(q_Imu2Seg_default, imus[imu][signal])\n\n        data[seg].update(imus)\n\n        # alignment: earth_omc to earth_inertial\n        qEOpt2EImu = _from_euler(qEOpt2EImu_euler_deg)\n        data[seg][\"quat\"] = qmt.qmult(qEOpt2EImu, quat_opt_markers2EOpt)\n        for marker_number in range(1, 5):\n            data[seg][f\"marker{marker_number}\"] = qmt.rotate(\n                qEOpt2EImu,\n                _construct_pos_from_single_marker(\n                    path_optitrack, seg_number, marker_number\n                ),\n            )\n\n    return data, imu_sync_offset\n</code></pre>"},{"location":"api/omc/#x_xy.subpkgs.omc.utils.crop_tail","title":"<code>crop_tail(signal, hz=None, strict=True, verbose=True)</code>","text":"<p>Crop all signals to length of shortest signal.</p> Source code in <code>x_xy/subpkgs/omc/utils.py</code> <pre><code>def crop_tail(\n    signal: PyTree,\n    hz: Optional[int | float | PyTree] = None,\n    strict: bool = True,\n    verbose: bool = True,\n):\n    \"Crop all signals to length of shortest signal.\"\n    if hz is None:\n        hz = 1.0\n\n    if isinstance(hz, (int, float)):\n        hz = tree.map_structure(lambda _: hz, signal)\n\n    # int -&gt; float\n    hz = tree.map_structure(float, hz)\n\n    def length_in_seconds(arr, hz):\n        assert arr.ndim &lt; 3\n        return len(arr) / hz\n\n    signal_lengths = tree.map_structure(length_in_seconds, signal, hz)\n    shortest_length = min(tree.flatten(signal_lengths))\n    hz_of_shortest_length = tree.flatten(hz)[np.argmin(tree.flatten(signal_lengths))]\n\n    if strict:\n        # reduce shortest_length until it becomes a clearn crop for all other\n        # frequencies\n        i = -1\n        cleancrop = False\n        while not cleancrop:\n            i += 1\n            shortest_length -= i * (1 / hz_of_shortest_length)\n            cleancrop = True\n\n            for each_hz in tree.flatten(hz):\n                if (shortest_length * each_hz) % 1 != 0.0:\n                    cleancrop = False\n                    break\n\n            if i &gt; int(hz_of_shortest_length):\n                warnings.warn(\n                    f\"Must crop more than i={i} and still no clean crop possible.\"\n                )\n\n            if i &gt; 100:\n                break\n\n    if verbose:\n        print(f\"`crop_tail`: Crop off at t={shortest_length}.\")\n\n    def crop(arr, hz):\n        if strict:\n            crop_tail = np.round(shortest_length * hz, decimals=10)\n            err_msg = (\n                f\"No clean crop possible: shortest_length={shortest_length}; hz={hz}\"\n            )\n            assert (crop_tail % 1) == 0.0, err_msg\n            crop_tail = int(crop_tail)\n        else:\n            crop_tail = math.ceil(shortest_length * hz)\n        return arr[:crop_tail]\n\n    return tree.map_structure(crop, signal, hz)\n</code></pre>"},{"location":"api/omc/#x_xy.subpkgs.omc.utils.resample","title":"<code>resample(signal, hz_in, hz_out, quatdetect=True, vecinterp_method='linear')</code>","text":"Source code in <code>x_xy/subpkgs/omc/utils.py</code> <pre><code>def resample(\n    signal: PyTree,\n    hz_in: int | float | PyTree,\n    hz_out: int | float | PyTree,\n    quatdetect: bool = True,\n    vecinterp_method: str = \"linear\",\n) -&gt; PyTree:\n    # int -&gt; float\n    hz_in, hz_out = tree.map_structure(float, (hz_in, hz_out))\n\n    if isinstance(hz_in, float):\n        hz_in = tree.map_structure(lambda _: hz_in, signal)\n    if isinstance(hz_out, float):\n        hz_out = tree.map_structure(lambda _: hz_out, signal)\n\n    def resample_array(signal: np.ndarray, hz_in, hz_out):\n        is1D = False\n        if signal.ndim == 1:\n            is1D = True\n            signal = signal[:, None]\n        assert signal.ndim == 2\n\n        N = signal.shape[0]\n        ts_out = np.arange(N, step=hz_in / hz_out)\n        signal = nanInterp(signal)\n        if quatdetect and signal.shape[1] == 4:\n            signal = quatInterp(signal, ts_out)\n        else:\n            if vecinterp_method == \"linear\":\n                signal = vecInterp(signal, ts_out)\n            elif vecinterp_method == \"cubic\":\n                signal = _cubic_interpolation(signal, ts_out)\n            else:\n                raise NotImplementedError(\n                    \"`vecinterp_method` must be one of ['linear', 'cubic']\"\n                )\n        if is1D:\n            signal = signal[:, 0]\n        return signal\n\n    return tree.map_structure(resample_array, signal, hz_in, hz_out)\n</code></pre>"},{"location":"api/omc/#x_xy.subpkgs.omc.utils.hz_helper","title":"<code>hz_helper(segments, imus=['imu_rigid', 'imu_flex'], markers=[1, 2, 3, 4], hz_imu=40.0, hz_omc=120.0)</code>","text":"Source code in <code>x_xy/subpkgs/omc/utils.py</code> <pre><code>def hz_helper(\n    segments: list[str],\n    imus: list[str] = [\"imu_rigid\", \"imu_flex\"],\n    markers: list[int] = [1, 2, 3, 4],\n    hz_imu: float = 40.0,\n    hz_omc: float = 120.0,\n):\n    hz_in = {}\n    imu_dict = dict(acc=hz_imu, mag=hz_imu, gyr=hz_imu)\n    for seg in segments:\n        hz_in[seg] = {}\n        for imu in imus:\n            hz_in[seg][imu] = imu_dict\n        for marker in markers:\n            hz_in[seg][f\"marker{marker}\"] = hz_omc\n        hz_in[seg][\"quat\"] = hz_omc\n\n    return hz_in\n</code></pre>"},{"location":"api/register/","title":"Register New Joint Types","text":""},{"location":"api/register/#x_xy.algorithms.jcalc.register_new_joint_type","title":"<code>register_new_joint_type(joint_type, joint_model, q_width, qd_width=None)</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>def register_new_joint_type(\n    joint_type: str,\n    joint_model: JointModel,\n    q_width: int,\n    qd_width: Optional[int] = None,\n):\n    if qd_width is None:\n        qd_width = q_width\n\n    assert len(joint_model.motion) == qd_width\n    assert joint_type not in _joint_types, \"already exists\"\n    _joint_types.update({joint_type: joint_model})\n    base.Q_WIDTHS.update({joint_type: q_width})\n    base.QD_WIDTHS.update({joint_type: qd_width})\n</code></pre>"},{"location":"api/register/#x_xy.algorithms.jcalc.JointModel","title":"<code>JointModel</code>  <code>dataclass</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>@dataclass\nclass JointModel:\n    # (q, params) -&gt; Transform\n    transform: Callable[[jax.Array, jax.Array], base.Transform]\n    # len(motion) == len(qd)\n    motion: list[base.Motion] = field(default_factory=lambda: [])\n    # (config, key_t, key_value, params) -&gt; jax.Array\n    rcmg_draw_fn: Optional[DRAW_FN] = None\n</code></pre>"},{"location":"api/register/#x_xy.base.update_n_joint_params","title":"<code>update_n_joint_params(n_joint_params=None)</code>","text":"<p>If None then reset to default value.</p> Source code in <code>x_xy/base.py</code> <pre><code>def update_n_joint_params(n_joint_params: Optional[int] = None) -&gt; None:\n    \"If None then reset to default value.\"\n    global _N_JOINT_PARAMS\n    global _DEFAULT_N_JOINT_PARAMS\n    if n_joint_params is None:\n        _N_JOINT_PARAMS = _DEFAULT_N_JOINT_PARAMS\n    else:\n        _N_JOINT_PARAMS = n_joint_params\n</code></pre>"},{"location":"api/rendering/","title":"Rendering","text":""},{"location":"api/rendering/#x_xy.rendering.render","title":"<code>render(sys, xs=None, camera=None, show_pbar=True, backend='mujoco', **scene_kwargs)</code>","text":"<p>Render frames from system and trajectory of maximal coordinates <code>xs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System to render.</p> required <code>xs</code> <code>Transform | list[Transform]</code> <p>Single or time-series</p> <code>None</code> <code>show_pbar</code> <code>bool</code> <p>Whether or not to show a progress bar.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>list[np.ndarray]: Stacked rendered frames. Length == len(xs).</p> Source code in <code>x_xy/rendering/base_render.py</code> <pre><code>def render(\n    sys: base.System,\n    xs: Optional[base.Transform | list[base.Transform]] = None,\n    camera: Optional[str] = None,\n    show_pbar: bool = True,\n    backend: str = \"mujoco\",\n    **scene_kwargs,\n) -&gt; list[np.ndarray]:\n\"\"\"Render frames from system and trajectory of maximal coordinates `xs`.\n\n    Args:\n        sys (base.System): System to render.\n        xs (base.Transform | list[base.Transform]): Single or time-series\n        of maximal coordinates `xs`.\n        show_pbar (bool, optional): Whether or not to show a progress bar.\n        Defaults to True.\n\n    Returns:\n        list[np.ndarray]: Stacked rendered frames. Length == len(xs).\n    \"\"\"\n    if backend == \"mujoco\":\n        from x_xy.rendering.mujoco_render import MujocoScene\n\n        scene = MujocoScene(**scene_kwargs)\n    elif backend == \"vispy\":\n        import vispy\n\n        if \"vispy_backend\" in scene_kwargs:\n            vispy_backend = scene_kwargs.pop(\"vispy_backend\")\n        else:\n            vispy_backend = \"pyqt6\"\n        vispy.use(vispy_backend)\n\n        from x_xy.rendering.vispy_render import VispyScene\n\n        scene = VispyScene(**scene_kwargs)\n    else:\n        raise NotImplementedError\n\n    # convert all colors to rgbas\n    geoms_rgba = [_color_to_rgba(geom) for geom in sys.geoms]\n\n    if xs is None:\n        xs = forward_kinematics(sys, base.State.create(sys))[1].x\n\n    xs = to_list(xs)\n\n    n_links = sys.num_links()\n\n    def data_check(x):\n        assert (\n            x.pos.ndim == x.rot.ndim == 2\n        ), f\"Expected shape = (n_links, 3/4). Got pos.shape{x.pos.shape}, \"\n        \"rot.shape={x.rot.shape}\"\n        assert (\n            x.pos.shape[0] == x.rot.shape[0] == n_links\n        ), \"Number of links does not match\"\n\n    for x in xs:\n        data_check(x)\n\n    scene.init(geoms_rgba)\n\n    frames = []\n    for x in tqdm.tqdm(xs, \"Rendering frames..\", disable=not show_pbar):\n        scene.update(x)\n        frames.append(scene.render(camera=camera))\n\n    return frames\n</code></pre>"},{"location":"api/sensors/","title":"Sensors","text":""},{"location":"api/sensors/#x_xy.algorithms.sensors.imu","title":"<code>imu(xs, gravity, dt, key=None, noisy=False, smoothen_degree=None, delay=None, random_s2s_ori=None, quasi_physical=False, low_pass_filter_pos_f_cutoff=None, low_pass_filter_rot_alpha=None)</code>","text":"<p>Simulates a 6D IMU, <code>xs</code> should be Transforms from eps-to-imu. NOTE: <code>smoothen_degree</code> is used as window size for moving average. NOTE: If <code>smoothen_degree</code> is given, and <code>delay</code> is not, then delay is chosen such moving average window is delayed to just be causal.</p> Source code in <code>x_xy/algorithms/sensors.py</code> <pre><code>def imu(\n    xs: base.Transform,\n    gravity: jax.Array,\n    dt: float,\n    key: Optional[jax.random.PRNGKey] = None,\n    noisy: bool = False,\n    smoothen_degree: Optional[int] = None,\n    delay: Optional[int] = None,\n    random_s2s_ori: Optional[float] = None,\n    quasi_physical: bool = False,\n    low_pass_filter_pos_f_cutoff: Optional[float] = None,\n    low_pass_filter_rot_alpha: Optional[bool] = None,\n) -&gt; dict:\n\"\"\"Simulates a 6D IMU, `xs` should be Transforms from eps-to-imu.\n    NOTE: `smoothen_degree` is used as window size for moving average.\n    NOTE: If `smoothen_degree` is given, and `delay` is not, then delay is chosen\n    such moving average window is delayed to just be causal.\n    \"\"\"\n    assert xs.ndim() == 2\n\n    if random_s2s_ori is not None:\n        assert key is not None, \"`random_s2s_ori` requires a random seed via `key`\"\n        # `xs` are now from eps-to-segment, so add another final rotation from\n        # segment-to-sensor where this transform is only rotational\n        key, consume = jax.random.split(key)\n        xs_s2s = base.Transform.create(\n            rot=maths.quat_random(consume, maxval=random_s2s_ori)\n        )\n        xs = jax.vmap(algebra.transform_mul, in_axes=(None, 0))(xs_s2s, xs)\n\n    if quasi_physical:\n        xs = _quasi_physical_simulation(xs, dt)\n\n    if low_pass_filter_pos_f_cutoff is not None:\n        xs = xs.replace(pos=_butterworth(xs.pos, 1 / dt, low_pass_filter_pos_f_cutoff))\n\n    if low_pass_filter_rot_alpha is not None:\n        xs = xs.replace(rot=maths.quat_lowpassfilter(xs.rot, low_pass_filter_rot_alpha))\n\n    measurements = {\"acc\": accelerometer(xs, gravity, dt), \"gyr\": gyroscope(xs.rot, dt)}\n\n    if smoothen_degree is not None:\n        measurements = jax.tree_map(\n            lambda arr: _moving_average(arr, smoothen_degree),\n            measurements,\n        )\n\n        # if you low-pass filter the imu measurements through a moving average which\n        # effectively uses future values, then it also makes sense to delay the imu\n        # measurements by this amount such that no future information is used\n        if delay is None:\n            half_window = (smoothen_degree - 1) // 2\n            delay = half_window\n\n    if delay is not None and delay &gt; 0:\n        measurements = jax.tree_map(\n            lambda arr: (jnp.pad(arr, ((delay, 0), (0, 0)))[:-delay]), measurements\n        )\n\n    if noisy:\n        assert key is not None, \"For noisy sensors random seed `key` must be provided.\"\n        measurements = add_noise_bias(key, measurements)\n\n    return measurements\n</code></pre>"},{"location":"api/sensors/#x_xy.algorithms.sensors.rel_pose","title":"<code>rel_pose(sys_scan, xs, sys_xs=None)</code>","text":"<p>Relative pose of the entire system. <code>sys_scan</code> defines the parent-child ordering, relative pose is from child to parent in local coordinates. Bodies that connect to the base are skipped (that would be absolute pose).</p> <p>Parameters:</p> Name Type Description Default <code>sys_scan</code> <code>System</code> <p>System defining parent-child ordering.</p> required <code>xs</code> <code>Transform</code> <p>Body transforms from base to body.</p> required <code>sys_xs</code> <code>System</code> <p>System that defines the stacking order of <code>xs</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Child-to-parent quaternions</p> Source code in <code>x_xy/algorithms/sensors.py</code> <pre><code>def rel_pose(\n    sys_scan: base.System, xs: base.Transform, sys_xs: Optional[base.System] = None\n) -&gt; dict:\n\"\"\"Relative pose of the entire system. `sys_scan` defines the parent-child ordering,\n    relative pose is from child to parent in local coordinates. Bodies that connect\n    to the base are skipped (that would be absolute pose).\n\n    Args:\n        sys_scan (base.System): System defining parent-child ordering.\n        xs (base.Transform): Body transforms from base to body.\n        sys_xs (base.System): System that defines the stacking order of `xs`.\n\n    Returns:\n        dict: Child-to-parent quaternions\n    \"\"\"\n    if sys_xs is None:\n        sys_xs = sys_scan\n\n    if xs.pos.ndim == 3:\n        # swap (n_timesteps, n_links) axes\n        xs = xs.transpose([1, 0, 2])\n\n    assert xs.batch_dim() == sys_xs.num_links()\n\n    qrel = lambda q1, q2: maths.quat_mul(q1, maths.quat_inv(q2))\n\n    y = {}\n\n    def pose_child_to_parent(_, __, name_i: str, p: int):\n        # body connects to base\n        if p == -1:\n            return\n\n        name_p = sys_scan.idx_to_name(p)\n\n        # find the transforms of those named bodies\n        i = sys_xs.name_to_idx(name_i)\n        p = sys_xs.name_to_idx(name_p)\n\n        # get those transforms\n        q1, q2 = xs.take(p).rot, xs.take(i).rot\n\n        y[name_i] = qrel(q1, q2)\n\n    scan_sys(\n        sys_scan, pose_child_to_parent, \"ll\", sys_scan.link_names, sys_scan.link_parents\n    )\n\n    return y\n</code></pre>"},{"location":"api/sim2real/","title":"sim2real","text":""},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.xs_from_raw","title":"<code>xs_from_raw(sys, link_name_pos_rot, eps_frame=None, qinv=False)</code>","text":"<p>Build time-series of maximal coordinates <code>xs</code> from raw position and quaternion trajectory data. This function scans through each link (as defined by <code>sys</code>), looks for the raw data in <code>link_name_pos_rot</code> using the <code>link_name</code> as identifier. It inverts the quaternion if <code>qinv</code>. Then, it creates a <code>Transform</code> that transforms from epsilon (as defined by <code>eps_frame</code>) to the link for each timestep. Finally, it stacks all transforms in order as defined by <code>sys</code> along the 1-th axis. The 0-th axis is time axis.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System which defines ordering of returned <code>xs</code></p> required <code>link_name_pos_rot</code> <code>dict</code> <p>Dictonary of <code>link_name</code> -&gt; {'pos': ..., 'quat': ...}. Obtained, e.g., using <code>process_omc</code>.</p> required <code>eps_frame</code> <code>str</code> <p>Move into this segment's frame at time zero as eps frame. Defaults to <code>None</code>. If <code>None</code>: Don't move into a specific eps-frame.</p> <code>None</code> <p>Returns:</p> Type Description <code>Transform</code> <p>x_xy.base.Transform: Time-series of eps-to-link transformations</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def xs_from_raw(\n    sys: x_xy.base.System,\n    link_name_pos_rot: dict,\n    eps_frame: Optional[str] = None,\n    qinv: bool = False,\n) -&gt; x_xy.base.Transform:\n\"\"\"Build time-series of maximal coordinates `xs` from raw position and\n    quaternion trajectory data. This function scans through each link (as\n    defined by `sys`), looks for the raw data in `link_name_pos_rot` using\n    the `link_name` as identifier. It inverts the quaternion if `qinv`.\n    Then, it creates a `Transform` that transforms from epsilon (as defined\n    by `eps_frame`) to the link for each timestep. Finally, it stacks all\n    transforms in order as defined by `sys` along the 1-th axis. The 0-th\n    axis is time axis.\n\n    Args:\n        sys (x_xy.base.System): System which defines ordering of returned `xs`\n        link_name_pos_rot (dict): Dictonary of `link_name` -&gt;\n            {'pos': ..., 'quat': ...}. Obtained, e.g., using `process_omc`.\n        eps_frame (str, optional): Move into this segment's frame at time zero as\n            eps frame. Defaults to `None`.\n            If `None`: Don't move into a specific eps-frame.\n\n    Returns:\n        x_xy.base.Transform: Time-series of eps-to-link transformations\n    \"\"\"\n    # determine `eps_frame` transform\n    if eps_frame is not None:\n        eps = link_name_pos_rot[eps_frame]\n        q_eps = eps[\"quat\"][0]\n        if qinv:\n            q_eps = x_xy.maths.quat_inv(q_eps)\n        t_eps = x_xy.base.Transform(eps[\"pos\"][0], q_eps)\n    else:\n        t_eps = x_xy.base.Transform.zero()\n\n    # build `xs` from optical motion capture data\n    xs = []\n\n    def f(_, __, link_name: str):\n        q, pos = (\n            link_name_pos_rot[link_name][\"quat\"],\n            link_name_pos_rot[link_name][\"pos\"],\n        )\n        if qinv:\n            q = x_xy.maths.quat_inv(q)\n        t = x_xy.base.Transform(pos, q)\n        t = x_xy.algebra.transform_mul(t, x_xy.algebra.transform_inv(t_eps))\n        xs.append(t)\n\n    scan_sys(sys, f, \"l\", sys.link_names)\n\n    # stack and permute such that time-axis is 0-th axis\n    xs = xs[0].batch(*xs[1:])\n    xs = xs.transpose((1, 0, 2))\n    return xs\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.match_xs","title":"<code>match_xs(sys, xs, sys_xs)</code>","text":"<p>Match tranforms <code>xs</code> to subsystem <code>sys</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Smaller system. Every link in <code>sys</code> must be in <code>sys_xs</code>.</p> required <code>xs</code> <code>Transform</code> <p>Transforms of larger system.</p> required <code>sys_xs</code> <code>Transform</code> <p>Larger system.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Transforms of smaller system.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def match_xs(sys: System, xs: Transform, sys_xs: System) -&gt; Transform:\n\"\"\"Match tranforms `xs` to subsystem `sys`.\n\n    Args:\n        sys (System): Smaller system. Every link in `sys` must be in `sys_xs`.\n        xs (Transform): Transforms of larger system.\n        sys_xs (Transform): Larger system.\n\n    Returns:\n        Transform: Transforms of smaller system.\n    \"\"\"\n    _checks_time_series_of_xs(sys_xs, xs)\n\n    xs_small = xs_from_raw(\n        sys,\n        {\n            name: {\n                \"pos\": xs.pos[:, sys_xs.name_to_idx(name)],\n                \"quat\": xs.rot[:, sys_xs.name_to_idx(name)],\n            }\n            for name in sys_xs.link_names\n        },\n        eps_frame=None,\n        qinv=False,\n    )\n    return xs_small\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.unzip_xs","title":"<code>unzip_xs(sys, xs)</code>","text":"<p>Split eps-to-link transforms into parent-to-child pure translational <code>transform1</code> and pure rotational <code>transform2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Defines scan.tree</p> required <code>xs</code> <code>Transform</code> <p>Eps-to-link transforms</p> required <p>Returns:</p> Type Description <code>Tuple[Transform, Transform]</code> <p>Tuple[Transform, Transform]: transform1, transform2</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def unzip_xs(sys: System, xs: Transform) -&gt; Tuple[Transform, Transform]:\n\"\"\"Split eps-to-link transforms into parent-to-child pure\n    translational `transform1` and pure rotational `transform2`.\n\n    Args:\n        sys (System): Defines scan.tree\n        xs (Transform): Eps-to-link transforms\n\n    Returns:\n        Tuple[Transform, Transform]: transform1, transform2\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    @jax.vmap\n    def _unzip_xs(xs):\n        def f(_, __, i: int, p: int):\n            if p == -1:\n                x_parent_to_link = xs[i]\n            else:\n                x_parent_to_link = algebra.transform_mul(\n                    xs[i], algebra.transform_inv(xs[p])\n                )\n\n            transform1_pos = Transform.create(pos=x_parent_to_link.pos)\n            transform2_rot = Transform.create(rot=x_parent_to_link.rot)\n            return (transform1_pos, transform2_rot)\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_parents)\n\n    return _unzip_xs(xs)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.zip_xs","title":"<code>zip_xs(sys, xs_transform1, xs_transform2)</code>","text":"<p>Performs forward kinematics using <code>transform1</code> and <code>transform2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Defines scan_sys</p> required <code>xs_transform1</code> <code>Transform</code> <p>Applied before <code>transform1</code></p> required <code>xs_transform2</code> <code>Transform</code> <p>Applied after <code>transform2</code></p> required <p>Returns:</p> Type Description <code>Transform</code> <p>x_xy.base.Transform: Time-series of eps-to-link transformations</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def zip_xs(\n    sys: System,\n    xs_transform1: Transform,\n    xs_transform2: Transform,\n) -&gt; Transform:\n\"\"\"Performs forward kinematics using `transform1` and `transform2`.\n\n    Args:\n        sys (x_xy.base.System): Defines scan_sys\n        xs_transform1 (x_xy.base.Transform): Applied before `transform1`\n        xs_transform2 (x_xy.base.Transform): Applied after `transform2`\n\n    Returns:\n        x_xy.base.Transform: Time-series of eps-to-link transformations\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs_transform1)\n    _checks_time_series_of_xs(sys, xs_transform2)\n\n    @jax.vmap\n    def _zip_xs(xs_transform1, xs_transform2):\n        eps_to_l = {-1: x_xy.base.Transform.zero()}\n\n        def f(_, __, i: int, p: int):\n            transform = algebra.transform_mul(xs_transform2[i], xs_transform1[i])\n            eps_to_l[i] = algebra.transform_mul(transform, eps_to_l[p])\n            return eps_to_l[i]\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_parents)\n\n    return _zip_xs(xs_transform1, xs_transform2)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.delete_to_world_pos_rot","title":"<code>delete_to_world_pos_rot(sys, xs)</code>","text":"<p>Replace the transforms of all links that connect to the worldbody by unity transforms.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System only used for structure (in scan_sys).</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of modified transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def delete_to_world_pos_rot(sys: System, xs: Transform) -&gt; Transform:\n\"\"\"Replace the transforms of all links that connect to the worldbody\n    by unity transforms.\n\n    Args:\n        sys (System): System only used for structure (in scan_sys).\n        xs (Transform): Time-series of transforms to be modified.\n\n    Returns:\n        Transform: Time-series of modified transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    zero_trafo = Transform.zero((xs.shape(),))\n    for i, p in enumerate(sys.link_parents):\n        if p == -1:\n            xs = _overwrite_transform_of_link_then_update(sys, xs, zero_trafo, i)\n    return xs\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.randomize_to_world_pos_rot","title":"<code>randomize_to_world_pos_rot(key, sys, xs, config)</code>","text":"<p>Replace the transforms of all links that connect to the worldbody by randomize transforms.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Array</code> <p>PRNG Key.</p> required <code>sys</code> <code>System</code> <p>System only used for structure (in scan_sys).</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <code>config</code> <code>RCMG_Config</code> <p>Defines the randomization.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of modified transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def randomize_to_world_pos_rot(\n    key: jax.Array, sys: System, xs: Transform, config: RCMG_Config\n) -&gt; Transform:\n\"\"\"Replace the transforms of all links that connect to the worldbody\n    by randomize transforms.\n\n    Args:\n        key (jax.Array): PRNG Key.\n        sys (System): System only used for structure (in scan_sys).\n        xs (Transform): Time-series of transforms to be modified.\n        config (RCMG_Config): Defines the randomization.\n\n    Returns:\n        Transform: Time-series of modified transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n    assert sys.link_parents.count(-1) == 1, \"Found multiple connections to world\"\n\n    free_sys_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"free\" joint=\"free\"/&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\n    free_sys = load_sys_from_str(free_sys_str)\n    _, xs_free = build_generator(free_sys, config)(key)\n    xs_free = xs_free.take(free_sys.name_to_idx(\"free\"), axis=1)\n    link_idx_to_world = sys.link_parents.index(-1)\n    return _overwrite_transform_of_link_then_update(sys, xs, xs_free, link_idx_to_world)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.scale_xs","title":"<code>scale_xs(sys, xs, factor, exclude=['px', 'py', 'pz', 'free'])</code>","text":"<p>Increase / decrease transforms by scaling their positional / rotational components based on the systems link type, i.e. the <code>xs</code> should conceptionally be <code>transform2</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System defining structure (for scan_sys)</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <code>factor</code> <code>float</code> <p>Multiplicative factor.</p> required <code>exclude</code> <code>list[str]</code> <p>Skip scaling of transforms if their link_type is one of those. Defaults to [\"px\", \"py\", \"pz\", \"free\"].</p> <code>['px', 'py', 'pz', 'free']</code> <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of scaled transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def scale_xs(\n    sys: System,\n    xs: Transform,\n    factor: float,\n    exclude: list[str] = [\"px\", \"py\", \"pz\", \"free\"],\n) -&gt; Transform:\n\"\"\"Increase / decrease transforms by scaling their positional / rotational\n    components based on the systems link type, i.e. the `xs` should conceptionally\n    be `transform2` objects.\n\n    Args:\n        sys (System): System defining structure (for scan_sys)\n        xs (Transform): Time-series of transforms to be modified.\n        factor (float): Multiplicative factor.\n        exclude (list[str], optional): Skip scaling of transforms if their link_type\n            is one of those. Defaults to [\"px\", \"py\", \"pz\", \"free\"].\n\n    Returns:\n        Transform: Time-series of scaled transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    @jax.vmap\n    def _scale_xs(xs):\n        def f(_, __, i: int, type: str):\n            x_link = xs[i]\n            if type not in exclude:\n                x_link = _scale_transform_based_on_type(x_link, type, factor)\n            return x_link\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_types)\n\n    return _scale_xs(xs)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.project_xs","title":"<code>project_xs(sys, transform2)</code>","text":"<p>Project transforms into the physically feasible subspace as defined by the joints in the system.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def project_xs(sys: System, transform2: Transform) -&gt; Transform:\n\"\"\"Project transforms into the physically feasible subspace as defined by the\n    joints in the system.\"\"\"\n    _checks_time_series_of_xs(sys, transform2)\n\n    _str2idx = {\"x\": 0, \"y\": 1, \"z\": 2}\n\n    @jax.vmap\n    def _project_xs(transform2):\n        def f(_, __, i: int, link_type: str, joint_params: jax.Array):\n            t = transform2[i]\n            rot, pos = jnp.array([1.0, 0, 0, 0]), jnp.zeros((3,))\n\n            if link_type in [\"rx\", \"ry\", \"rz\"]:\n                angles = maths.quat_to_euler(t.rot)\n                idx = _str2idx[link_type[1]]\n                proj_angles = jnp.zeros((3,)).at[idx].set(angles[idx])\n                rot = maths.euler_to_quat(proj_angles)\n            elif link_type in [\"px\", \"py\", \"pz\"]:\n                idx = _str2idx[link_type[1]]\n                pos = pos.at[idx].set(t.pos[idx])\n            elif link_type == \"spherical\":\n                rot = t.rot\n            elif link_type in [\"p3d\", \"cor\"]:\n                pos = t.pos\n            elif link_type == \"free\":\n                pos, rot = t.pos, t.rot\n            # TODO; Consider removing the case of `rr` and `rr_imp`\n            # after all these joints are not part of the standard library\n            elif link_type == \"rr\":\n                assert joint_params.shape == (3,)\n                rot = maths.quat_project(t.rot, joint_params)\n            elif link_type == \"rr_imp\":\n                assert joint_params.shape == (6,)\n                warnings.warn(\"`rr_imp` cannot be projected.\")\n                rot = t.rot\n            elif link_type == \"frozen\":\n                pass\n            else:\n                raise NotImplementedError\n            return Transform(pos=pos, rot=rot)\n\n        return scan_sys(\n            sys,\n            f,\n            \"lll\",\n            list(range(sys.num_links())),\n            sys.link_types,\n            sys.links.joint_params,\n        )\n\n    return _project_xs(transform2)\n</code></pre>"},{"location":"api/state/","title":"State","text":""},{"location":"api/state/#x_xy.base.State","title":"<code>State</code>","text":"<p>The static and dynamic state of a system in minimal and maximal coordinates. Use <code>.create()</code> to create this object.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Array</code> <p>System state in minimal coordinates (equals <code>sys.q_size()</code>)</p> required <code>qd</code> <code>Array</code> <p>System velocity in minimal coordinates (equals <code>sys.qd_size()</code>)</p> required <code>x</code> <p>(Transform): Maximal coordinates of all links. From epsilon-to-link.</p> required <code>mass_mat_inv</code> <code>Array</code> <p>Inverse of the mass matrix. Internal usage.</p> required Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass State(_Base):\n\"\"\"The static and dynamic state of a system in minimal and maximal coordinates.\n    Use `.create()` to create this object.\n\n    Args:\n        q (jax.Array): System state in minimal coordinates (equals `sys.q_size()`)\n        qd (jax.Array): System velocity in minimal coordinates (equals `sys.qd_size()`)\n        x: (Transform): Maximal coordinates of all links. From epsilon-to-link.\n        mass_mat_inv (jax.Array): Inverse of the mass matrix. Internal usage.\n    \"\"\"\n\n    q: jax.Array\n    qd: jax.Array\n    x: Transform\n    mass_mat_inv: jax.Array\n\n    @classmethod\n    def create(\n        cls, sys: System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None\n    ):\n\"\"\"Create state of system.\n\n        Args:\n            sys (System): The system for which to create a state.\n            q (jax.Array, optional): The joint values of the system. Defaults to None.\n            Which then defaults to zeros.\n            qd (jax.Array, optional): The joint velocities of the system.\n            Defaults to None. Which then defaults to zeros.\n\n        Returns:\n            (State): Create State object.\n        \"\"\"\n        # to avoid circular imports\n        from x_xy import scan_sys\n\n        if q is None:\n            q = jnp.zeros((sys.q_size(),))\n\n            # free and spherical joints are not zeros but unit quaternions\n            def replace_by_unit_quat(carry, idx_map, link_typ, link_idx):\n                nonlocal q\n\n                if link_typ == \"spherical\" or link_typ == \"free\":\n                    q_idxs_link = idx_map[\"q\"](link_idx)\n                    q = q.at[q_idxs_link.start].set(1.0)\n\n            scan_sys(\n                sys,\n                replace_by_unit_quat,\n                \"ll\",\n                sys.link_types,\n                list(range(sys.num_links())),\n            )\n\n        if qd is None:\n            qd = jnp.zeros((sys.qd_size(),))\n        x = Transform.zero((sys.num_links(),))\n        return cls(q, qd, x, jnp.diag(jnp.ones((sys.qd_size(),))))\n</code></pre>"},{"location":"api/state/#x_xy.base.State.create","title":"<code>create(sys, q=None, qd=None)</code>  <code>classmethod</code>","text":"<p>Create state of system.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>The system for which to create a state.</p> required <code>q</code> <code>Array</code> <p>The joint values of the system. Defaults to None.</p> <code>None</code> <code>qd</code> <code>Array</code> <p>The joint velocities of the system.</p> <code>None</code> <p>Returns:</p> Type Description <code>State</code> <p>Create State object.</p> Source code in <code>x_xy/base.py</code> <pre><code>@classmethod\ndef create(\n    cls, sys: System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None\n):\n\"\"\"Create state of system.\n\n    Args:\n        sys (System): The system for which to create a state.\n        q (jax.Array, optional): The joint values of the system. Defaults to None.\n        Which then defaults to zeros.\n        qd (jax.Array, optional): The joint velocities of the system.\n        Defaults to None. Which then defaults to zeros.\n\n    Returns:\n        (State): Create State object.\n    \"\"\"\n    # to avoid circular imports\n    from x_xy import scan_sys\n\n    if q is None:\n        q = jnp.zeros((sys.q_size(),))\n\n        # free and spherical joints are not zeros but unit quaternions\n        def replace_by_unit_quat(carry, idx_map, link_typ, link_idx):\n            nonlocal q\n\n            if link_typ == \"spherical\" or link_typ == \"free\":\n                q_idxs_link = idx_map[\"q\"](link_idx)\n                q = q.at[q_idxs_link.start].set(1.0)\n\n        scan_sys(\n            sys,\n            replace_by_unit_quat,\n            \"ll\",\n            sys.link_types,\n            list(range(sys.num_links())),\n        )\n\n    if qd is None:\n        qd = jnp.zeros((sys.qd_size(),))\n    x = Transform.zero((sys.num_links(),))\n    return cls(q, qd, x, jnp.diag(jnp.ones((sys.qd_size(),))))\n</code></pre>"},{"location":"api/sys_composer/","title":"sys_composer","text":""},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.delete_sys.delete_subsystem","title":"<code>delete_subsystem(sys, link_name)</code>","text":"<p>Cut subsystem starting at <code>link_name</code> (inclusive) from tree.</p> Source code in <code>x_xy/subpkgs/sys_composer/delete_sys.py</code> <pre><code>def delete_subsystem(sys: base.System, link_name: str | list[str]) -&gt; base.System:\n    \"Cut subsystem starting at `link_name` (inclusive) from tree.\"\n    if isinstance(link_name, list):\n        for ln in link_name:\n            sys = delete_subsystem(sys, ln)\n        return sys\n\n    assert (\n        link_name in sys.link_names\n    ), f\"link {link_name} not found in {sys.link_names}\"\n\n    subsys = _find_subsystem_indices(sys.link_parents, sys.name_to_idx(link_name))\n    idx_map, keep = _idx_map_and_keepers(sys.link_parents, subsys)\n\n    def take(list):\n        return [ele for i, ele in enumerate(list) if i in keep]\n\n    d, a, ss, sz = [], [], [], []\n\n    def filter_arrays(_, __, damp, arma, stiff, zero, i: int):\n        if i in keep:\n            d.append(damp)\n            a.append(arma)\n            ss.append(stiff)\n            sz.append(zero)\n\n    scan_sys(\n        sys,\n        filter_arrays,\n        \"dddql\",\n        sys.link_damping,\n        sys.link_armature,\n        sys.link_spring_stiffness,\n        sys.link_spring_zeropoint,\n        list(range(sys.num_links())),\n    )\n\n    d, a, ss, sz = map(jnp.concatenate, (d, a, ss, sz))\n\n    new_sys = base.System(\n        link_parents=_reindex_parent_array(sys.link_parents, subsys),\n        links=tree_utils.tree_indices(sys.links, jnp.array(keep, dtype=int)),\n        link_types=take(sys.link_types),\n        link_damping=d,\n        link_armature=a,\n        link_spring_stiffness=ss,\n        link_spring_zeropoint=sz,\n        dt=sys.dt,\n        geoms=[\n            geom.replace(link_idx=idx_map[geom.link_idx])\n            for geom in sys.geoms\n            if geom.link_idx in keep\n        ],\n        gravity=sys.gravity,\n        integration_method=sys.integration_method,\n        mass_mat_iters=sys.mass_mat_iters,\n        link_names=take(sys.link_names),\n        model_name=sys.model_name,\n    )\n\n    return parse_system(new_sys)\n</code></pre>"},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.delete_sys.make_sys_noimu","title":"<code>make_sys_noimu(sys, imu_link_names=None)</code>","text":"<p>Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'}</p> Source code in <code>x_xy/subpkgs/sys_composer/delete_sys.py</code> <pre><code>def make_sys_noimu(sys: x_xy.System, imu_link_names: Optional[list[str]] = None):\n    \"Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'}\"\n    if imu_link_names is None:\n        imu_link_names = _autodetermine_imu_names(sys)\n    imu_attachment = {name: sys.parent_name(name) for name in imu_link_names}\n    sys_noimu = delete_subsystem(sys, imu_link_names)\n    return sys_noimu, imu_attachment\n</code></pre>"},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.inject_sys.inject_system","title":"<code>inject_system(sys, sub_sys, at_body=None)</code>","text":"<p>Combine two systems into one.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Large system.</p> required <code>sub_sys</code> <code>System</code> <p>Small system that will be included into the large system <code>sys</code>.</p> required <code>at_body</code> <code>Optional[str]</code> <p>Into which body of the large system small system will be included. Defaults to <code>worldbody</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>System</code> <p>base.System: description</p> Source code in <code>x_xy/subpkgs/sys_composer/inject_sys.py</code> <pre><code>def inject_system(\n    sys: base.System,\n    sub_sys: base.System,\n    at_body: Optional[str] = None,\n) -&gt; base.System:\n\"\"\"Combine two systems into one.\n\n    Args:\n        sys (base.System): Large system.\n        sub_sys (base.System): Small system that will be included into the\n            large system `sys`.\n        at_body (Optional[str], optional): Into which body of the large system\n            small system will be included. Defaults to `worldbody`.\n\n    Returns:\n        base.System: _description_\n    \"\"\"\n\n    # replace parent array\n    if at_body is None:\n        new_world = -1\n    else:\n        new_world = sys.name_to_idx(at_body)\n\n    # append sub_sys at index end and replace sub_sys world with `at_body`\n    N = sys.num_links()\n\n    def new_parent(old_parent: int):\n        if old_parent != -1:\n            return old_parent + N\n        else:\n            return new_world\n\n    sub_sys = sub_sys.replace(\n        link_parents=[new_parent(p) for p in sub_sys.link_parents]\n    )\n\n    # replace link indices of geoms in sub_sys\n    sub_sys = sub_sys.replace(\n        geoms=[\n            geom.replace(link_idx=new_parent(geom.link_idx)) for geom in sub_sys.geoms\n        ]\n    )\n\n    # merge two systems\n    concat = lambda a1, a2: tree_batch([a1, a2], True, \"jax\")\n    combined_sys = base.System(\n        link_parents=sys.link_parents + sub_sys.link_parents,\n        links=concat(sys.links, sub_sys.links),\n        link_types=sys.link_types + sub_sys.link_types,\n        link_damping=concat(sys.link_damping, sub_sys.link_damping),\n        link_armature=concat(sys.link_armature, sub_sys.link_armature),\n        link_spring_stiffness=concat(\n            sys.link_spring_stiffness, sub_sys.link_spring_stiffness\n        ),\n        link_spring_zeropoint=concat(\n            sys.link_spring_zeropoint, sub_sys.link_spring_zeropoint\n        ),\n        dt=sys.dt,\n        geoms=sys.geoms + sub_sys.geoms,\n        gravity=sys.gravity,\n        integration_method=sys.integration_method,\n        mass_mat_iters=sys.mass_mat_iters,\n        link_names=sys.link_names + sub_sys.link_names,\n        model_name=sys.model_name,\n    )\n\n    return parse_system(combined_sys)\n</code></pre>"},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.morph_sys.morph_system","title":"<code>morph_system(sys, new_parents)</code>","text":"<p>Re-orders the graph underlying the system. Returns a new system.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System to be modified.</p> required <code>new_parents</code> <code>list[int]</code> <p>Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system.</p> required <p>Returns:</p> Type Description <code>System</code> <p>base.System: Modified system.</p> Source code in <code>x_xy/subpkgs/sys_composer/morph_sys.py</code> <pre><code>def morph_system(sys: base.System, new_parents: list[int | str]) -&gt; base.System:\n\"\"\"Re-orders the graph underlying the system. Returns a new system.\n\n    Args:\n        sys (base.System): System to be modified.\n        new_parents (list[int]): Let the i-th entry have value j. Then, after morphing\n            the system the system will be such that the link corresponding to the i-th\n            link in the old system will have as parent the link corresponding to the\n            j-th link in the old system.\n\n    Returns:\n        base.System: Modified system.\n    \"\"\"\n    assert len(new_parents) == sys.num_links()\n\n    structure, permutation, new_parent_array = identify_system(sys, new_parents)\n\n    sys, new_transform1 = _new_transform1(sys, permutation, structure, True, True)\n\n    def _new_pos_min_max(old_pos_min_max):\n        new_pos_min_max = []\n        for link_idx_old_indices in range(sys.num_links()):\n            node = structure[link_idx_old_indices]\n            if node.parent_changed and node.new_parent_old_indices != -1:\n                grandparent = structure[\n                    node.new_parent_old_indices\n                ].new_parent_old_indices\n                if grandparent != -1:\n                    use = grandparent\n                else:\n                    # in this case we will always move the cs into the cs that connects\n                    # to -1; thus the `pos_mod` will always be zeros no matter what we\n                    # `use`\n                    use = None\n            else:\n                use = link_idx_old_indices\n\n            if use is not None:\n                pos_min_max_using_one = sys.links.transform1.pos.at[use].set(\n                    old_pos_min_max[use]\n                )\n            else:\n                pos_min_max_using_one = sys.links.transform1.pos\n\n            sys_mod = sys.replace(\n                links=sys.links.replace(\n                    transform1=sys.links.transform1.replace(pos=pos_min_max_using_one)\n                )\n            )\n\n            # break early because we only use the value of `link_idx_old_indices` anways\n            pos_mod = _new_transform1(\n                sys_mod, permutation, structure, breakearly=link_idx_old_indices\n            )[1][link_idx_old_indices].pos\n\n            new_pos_min_max.append(pos_mod)\n        return jnp.vstack(new_pos_min_max)\n\n    new_pos_min_unsorted = _new_pos_min_max(sys.links.pos_min)\n    new_pos_max_unsorted = _new_pos_min_max(sys.links.pos_max)\n    new_pos_min = jnp.where(\n        new_pos_min_unsorted &gt; new_pos_max_unsorted,\n        new_pos_max_unsorted,\n        new_pos_min_unsorted,\n    )\n    new_pos_max = jnp.where(\n        new_pos_max_unsorted &lt; new_pos_min_unsorted,\n        new_pos_min_unsorted,\n        new_pos_max_unsorted,\n    )\n    links = sys.links.replace(\n        transform1=new_transform1, pos_min=new_pos_min, pos_max=new_pos_max\n    )\n\n    def _permute(obj):\n        if isinstance(obj, (base._Base, jax.Array)):\n            return obj[jnp.array(permutation, dtype=jnp.int32)]\n        elif isinstance(obj, list):\n            return [obj[permutation[i]] for i in range(len(obj))]\n        assert False\n\n    _joint_properties = _permute(_swapped_joint_properties(sys, structure))\n    stack_joint_properties = lambda i: jnp.concatenate(\n        [link[i] for link in _joint_properties]\n    )\n\n    morphed_system = base.System(\n        link_parents=new_parent_array,\n        links=_permute(links).replace(\n            joint_params=jnp.vstack([link[5] for link in _joint_properties])\n        ),\n        link_types=[link[4] for link in _joint_properties],\n        link_damping=stack_joint_properties(0),\n        link_armature=stack_joint_properties(1),\n        link_spring_stiffness=stack_joint_properties(2),\n        link_spring_zeropoint=stack_joint_properties(3),\n        dt=sys.dt,\n        geoms=_permute_modify_geoms(sys.geoms, structure),\n        gravity=sys.gravity,\n        integration_method=sys.integration_method,\n        mass_mat_iters=sys.mass_mat_iters,\n        link_names=_permute(sys.link_names),\n        model_name=sys.model_name,\n    )\n\n    return parse_system(morphed_system)\n</code></pre>"},{"location":"api/system/","title":"System","text":""},{"location":"api/system/#x_xy.base.System","title":"<code>System</code>","text":"Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass System(_Base):\n    link_parents: list[int] = struct.field(False)\n    links: Link\n    link_types: list[str] = struct.field(False)\n    link_damping: jax.Array\n    link_armature: jax.Array\n    link_spring_stiffness: jax.Array\n    link_spring_zeropoint: jax.Array\n    # simulation timestep size\n    dt: float = struct.field(False)\n    # geometries in the system\n    geoms: list[Geometry]\n    # root / base acceleration offset\n    gravity: jax.Array = struct.field(default_factory=lambda: jnp.array([0, 0, -9.81]))\n\n    integration_method: str = struct.field(\n        False, default_factory=lambda: \"semi_implicit_euler\"\n    )\n    mass_mat_iters: int = struct.field(False, default_factory=lambda: 0)\n\n    link_names: list[str] = struct.field(False, default_factory=lambda: [])\n\n    model_name: Optional[str] = struct.field(False, default_factory=lambda: None)\n\n    def num_links(self) -&gt; int:\n        return len(self.link_parents)\n\n    def q_size(self) -&gt; int:\n        return sum([Q_WIDTHS[typ] for typ in self.link_types])\n\n    def qd_size(self) -&gt; int:\n        return sum([QD_WIDTHS[typ] for typ in self.link_types])\n\n    def name_to_idx(self, name: str) -&gt; int:\n        return self.link_names.index(name)\n\n    def idx_to_name(self, idx: int) -&gt; str:\n        assert idx &gt;= 0, \"Worldbody index has no name.\"\n        return self.link_names[idx]\n\n    def idx_map(self, type: str) -&gt; dict:\n        \"type: is either `l` or `q` or `d`\"\n        from x_xy import scan_sys\n\n        dict_int_slices = {}\n\n        def f(_, idx_map, name: str, link_idx: int):\n            dict_int_slices[name] = idx_map[type](link_idx)\n\n        scan_sys(self, f, \"ll\", self.link_names, list(range(self.num_links())))\n\n        return dict_int_slices\n\n    def parent_name(self, name: str) -&gt; str:\n        return self.idx_to_name(self.link_parents[self.name_to_idx(name)])\n\n    def add_prefix(self, prefix: str = \"\") -&gt; \"System\":\n        return self.replace(link_names=[prefix + name for name in self.link_names])\n\n    def change_model_name(self, name: str) -&gt; \"System\":\n        return self.replace(model_name=name)\n\n    def rename_link(self, old_name: str, new_name) -&gt; \"System\":\n        old_idx = self.name_to_idx(old_name)\n        new_link_names = self.link_names.copy()\n        new_link_names[old_idx] = new_name\n        return self.replace(link_names=new_link_names)\n\n    def add_prefix_suffix(\n        self, prefix: Optional[str] = None, suffix: Optional[str] = None\n    ) -&gt; \"System\":\n        if prefix is None:\n            prefix = \"\"\n        if suffix is None:\n            suffix = \"\"\n        new_link_names = [prefix + name + suffix for name in self.link_names]\n        return self.replace(link_names=new_link_names)\n\n    @staticmethod\n    def deep_equal(a, b):\n        if type(a) is not type(b):\n            return False\n        if isinstance(a, _Base):\n            return System.deep_equal(a.__dict__, b.__dict__)\n        if isinstance(a, dict):\n            if a.keys() != b.keys():\n                return False\n            return all(System.deep_equal(a[k], b[k]) for k in a.keys())\n        if isinstance(a, (list, tuple)):\n            if len(a) != len(b):\n                return False\n            return all(System.deep_equal(a[i], b[i]) for i in range(len(a)))\n        if isinstance(a, (np.ndarray, jnp.ndarray, jax.Array)):\n            return jnp.array_equal(a, b)\n        return a == b\n</code></pre>"},{"location":"api/system/#x_xy.base.System.idx_map","title":"<code>idx_map(type)</code>","text":"<p>type: is either <code>l</code> or <code>q</code> or <code>d</code></p> Source code in <code>x_xy/base.py</code> <pre><code>def idx_map(self, type: str) -&gt; dict:\n    \"type: is either `l` or `q` or `d`\"\n    from x_xy import scan_sys\n\n    dict_int_slices = {}\n\n    def f(_, idx_map, name: str, link_idx: int):\n        dict_int_slices[name] = idx_map[type](link_idx)\n\n    scan_sys(self, f, \"ll\", self.link_names, list(range(self.num_links())))\n\n    return dict_int_slices\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.from_xml.load_sys_from_str","title":"<code>load_sys_from_str(xml_str)</code>","text":"<p>Load system from string input.</p> <p>Parameters:</p> Name Type Description Default <code>xml_str</code> <code>str</code> <p>XML Presentation of the system.</p> required <p>Returns:</p> Type Description <code>System</code> <p>base.System: Loaded system.</p> Source code in <code>x_xy/io/xml/from_xml.py</code> <pre><code>def load_sys_from_str(xml_str: str) -&gt; base.System:\n\"\"\"Load system from string input.\n\n    Args:\n        xml_str (str): XML Presentation of the system.\n\n    Returns:\n        base.System: Loaded system.\n    \"\"\"\n    xml_tree = ElementTree.fromstring(xml_str)\n    worldbody = _initial_setup(xml_tree)\n\n    # check that &lt;x_xy model=\"...\"&gt; syntax is correct\n    assert xml_tree.tag == \"x_xy\", (\n        \"The root element in the xml of a x_xy model must be `x_xy`.\"\n        \" Look up the examples under  x_xy/io/examples/*.xml to get started\"\n    )\n    model_name = xml_tree.attrib.get(\"model\", None)\n\n    # default options\n    options = {\"gravity\": DEFAULT_GRAVITY, \"dt\": DEFAULT_DT}\n    options_xml = _find_assert_unique(xml_tree, \"options\")\n    options.update({} if options_xml is None else options_xml.attrib)\n\n    # convert scalar array to float\n    # if this is uncommented, it leads to `ConcretizationTypeError`s\n    # options[\"dt\"] = float(options[\"dt\"])\n\n    links = {}\n    link_parents = {}\n    link_names = {}\n    link_types = {}\n    geoms = {}\n    armatures = {}\n    dampings = {}\n    spring_stiffnesses = {}\n    spring_zeropoints = {}\n    global_link_idx = -1\n\n    def process_body(body: ElementTree, parent: int):\n        nonlocal global_link_idx\n        global_link_idx += 1\n        current_link_idx = global_link_idx\n        current_link_typ = body.attrib[\"joint\"]\n\n        link_parents[current_link_idx] = parent\n        link_types[current_link_idx] = current_link_typ\n        link_names[current_link_idx] = body.attrib[\"name\"]\n\n        transform = abstract.AbsTrans.from_xml(body.attrib)\n        pos_min, pos_max = abstract.AbsPosMinMax.from_xml(body.attrib, transform.pos)\n        links[current_link_idx] = base.Link(transform, pos_min, pos_max)\n\n        q_size = base.Q_WIDTHS[current_link_typ]\n        qd_size = base.QD_WIDTHS[current_link_typ]\n\n        (\n            damping,\n            armature,\n            stiffness,\n            zeropoint,\n        ) = abstract.AbsDampArmaStiffZero.from_xml(\n            body.attrib, q_size, qd_size, current_link_typ\n        )\n\n        armatures[current_link_idx] = armature\n        dampings[current_link_idx] = damping\n        spring_stiffnesses[current_link_idx] = stiffness\n        spring_zeropoints[current_link_idx] = zeropoint\n\n        geoms[current_link_idx] = _extract_geoms_from_body_xml(body, current_link_idx)\n\n        for subbodies in body.findall(\"body\"):\n            process_body(subbodies, current_link_idx)\n\n        return\n\n    for body in worldbody.findall(\"body\"):\n        process_body(body, -1)\n\n    def assert_order_then_to_list(d: dict) -&gt; list:\n        assert [i for i in d] == list(range(len(d)))\n        return [d[i] for i in d]\n\n    links = assert_order_then_to_list(links)\n    links = links[0].batch(*links[1:])\n    dampings = jnp.concatenate(assert_order_then_to_list(dampings))\n    armatures = jnp.concatenate(assert_order_then_to_list(armatures))\n    spring_stiffnesses = jnp.concatenate(assert_order_then_to_list(spring_stiffnesses))\n    spring_zeropoints = jnp.concatenate(assert_order_then_to_list(spring_zeropoints))\n\n    # add all geoms directly connected to worldbody\n    flat_geoms = [geom for geoms in assert_order_then_to_list(geoms) for geom in geoms]\n    flat_geoms += _extract_geoms_from_body_xml(worldbody, -1)\n\n    sys = base.System(\n        link_parents=assert_order_then_to_list(link_parents),\n        links=links,\n        link_types=assert_order_then_to_list(link_types),\n        link_damping=dampings,\n        link_armature=armatures,\n        link_spring_stiffness=spring_stiffnesses,\n        link_spring_zeropoint=spring_zeropoints,\n        dt=options[\"dt\"],\n        geoms=flat_geoms,\n        gravity=options[\"gravity\"],\n        link_names=assert_order_then_to_list(link_names),\n        model_name=model_name,\n    )\n\n    return parse_system(sys)\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.from_xml.load_sys_from_xml","title":"<code>load_sys_from_xml(xml_path)</code>","text":"Source code in <code>x_xy/io/xml/from_xml.py</code> <pre><code>def load_sys_from_xml(xml_path: str):\n    return load_sys_from_str(_load_xml(xml_path))\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.to_xml.save_sys_to_str","title":"<code>save_sys_to_str(sys)</code>","text":"Source code in <code>x_xy/io/xml/to_xml.py</code> <pre><code>def save_sys_to_str(sys: base.System) -&gt; str:\n    if not jnp.all(sys.links.joint_params == 0.0):\n        warnings.warn(\n            \"The system has `sys.links.joint_params` unequal to the default value (of\"\n            \" zeros). This will not be preserved in the xml.\"\n        )\n    global_index_map = {qd: sys.idx_map(qd) for qd in [\"q\", \"d\"]}\n\n    # Create root element\n    x_xy = Element(\"x_xy\")\n    x_xy.set(\"model\", sys.model_name)\n\n    options = SubElement(x_xy, \"options\")\n    options.set(\"dt\", str(sys.dt))\n    options.set(\"gravity\", _to_str(sys.gravity))\n\n    # Create worldbody\n    worldbody = SubElement(x_xy, \"worldbody\")\n\n    def process_link(link_idx: int, parent_elem: Element):\n        link = sys.links[link_idx]\n        link_typ = sys.link_types[link_idx]\n        link_name = sys.link_names[link_idx]\n\n        # Create body element\n        body = SubElement(parent_elem, \"body\")\n        body.set(\"joint\", link_typ)\n        body.set(\"name\", link_name)\n\n        # Set attributes\n        abstract.AbsTrans.to_xml(body, link.transform1)\n        abstract.AbsPosMinMax.to_xml(body, link.pos_min, link.pos_max)\n        abstract.AbsDampArmaStiffZero.to_xml(\n            body,\n            sys.link_damping[global_index_map[\"d\"][link_name]],\n            sys.link_armature[global_index_map[\"d\"][link_name]],\n            sys.link_spring_stiffness[global_index_map[\"d\"][link_name]],\n            sys.link_spring_zeropoint[global_index_map[\"q\"][link_name]],\n            base.Q_WIDTHS[link_typ],\n            base.QD_WIDTHS[link_typ],\n            link_typ,\n        )\n\n        # Add geometry elements\n        geoms = sys.geoms\n        for geom in geoms:\n            if geom.link_idx == link_idx:\n                geom_elem = SubElement(body, \"geom\")\n                abstract_class = abstract.geometry_to_abstract[type(geom)]\n                abstract_class.to_xml(geom_elem, geom)\n\n        # Recursively process child links\n        for child_idx, parent_idx in enumerate(sys.link_parents):\n            if parent_idx == link_idx:\n                process_link(child_idx, body)\n\n    for root_link_idx, parent_idx in enumerate(sys.link_parents):\n        if parent_idx == -1:\n            process_link(root_link_idx, worldbody)\n\n    # Pretty print xml\n    xml_str = parseString(tostring(x_xy)).toprettyxml(indent=\"  \")\n    return xml_str\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.to_xml.save_sys_to_xml","title":"<code>save_sys_to_xml(sys, xml_path)</code>","text":"Source code in <code>x_xy/io/xml/to_xml.py</code> <pre><code>def save_sys_to_xml(sys: base.System, xml_path: str) -&gt; None:\n    xml_str = save_sys_to_str(sys)\n    with open(xml_path, \"w\") as f:\n        f.write(xml_str)\n</code></pre>"},{"location":"api/system/#x_xy.io.examples.load_example","title":"<code>load_example(name)</code>","text":"<p>Load example from examples dir.</p> Source code in <code>x_xy/io/examples.py</code> <pre><code>def load_example(name: str):\n    \"Load example from examples dir.\"\n\n    xml_path = parse_path(EXAMPLES_DIR, name, extension=\"xml\")\n    return load_sys_from_xml(xml_path)\n</code></pre>"},{"location":"api/system/#x_xy.scan.scan_sys","title":"<code>scan_sys(sys, f, in_types, *args, reverse=False)</code>","text":"<p>Scan <code>f</code> along each link in system whilst carrying along state.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>description</p> required <code>f</code> <code>Callable[..., Y]</code> <p>f(y: Y, *args) -&gt; y</p> required <code>in_types</code> <code>str</code> <p>string specifying the type of each input arg: 'l' is an input to be split according to link ranges 'q' is an input to be split according to q ranges 'd' is an input to be split according to qd ranges</p> required <code>args</code> <p>Arguments passed to <code>f</code>, and split to match the link.</p> <code>()</code> <code>reverse</code> <code>bool</code> <p>If <code>true</code> from leaves to root. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ys</code> <p>Stacked output y of f.</p> Source code in <code>x_xy/scan.py</code> <pre><code>def scan_sys(\n    sys: base.System, f: Callable, in_types: str, *args, reverse: bool = False\n):\n\"\"\"Scan `f` along each link in system whilst carrying along state.\n\n    Args:\n        sys (base.System): _description_\n        f (Callable[..., Y]): f(y: Y, *args) -&gt; y\n        in_types: string specifying the type of each input arg:\n            'l' is an input to be split according to link ranges\n            'q' is an input to be split according to q ranges\n            'd' is an input to be split according to qd ranges\n        args: Arguments passed to `f`, and split to match the link.\n        reverse (bool, optional): If `true` from leaves to root. Defaults to False.\n\n    Returns:\n        ys: Stacked output y of f.\n    \"\"\"\n\n    assert len(args) == len(in_types)\n\n    order = range(sys.num_links())\n    q_idx, qd_idx = 0, 0\n    q_idxs, qd_idxs = {}, {}\n    for link_idx, link_type in zip(order, sys.link_types):\n        # build map from\n        # link-idx -&gt; q_idx\n        # link-idx -&gt; qd_idx\n        q_idxs[link_idx] = slice(q_idx, q_idx + base.Q_WIDTHS[link_type])\n        qd_idxs[link_idx] = slice(qd_idx, qd_idx + base.QD_WIDTHS[link_type])\n        q_idx += base.Q_WIDTHS[link_type]\n        qd_idx += base.QD_WIDTHS[link_type]\n\n    idx_map = {\n        \"l\": lambda link_idx: link_idx,\n        \"q\": lambda link_idx: q_idxs[link_idx],\n        \"d\": lambda link_idx: qd_idxs[link_idx],\n    }\n\n    if reverse:\n        order = range(sys.num_links() - 1, -1, -1)\n\n    y, ys = None, []\n    for link_idx in order:\n        args_link = [arg[idx_map[t](link_idx)] for arg, t in zip(args, in_types)]\n        y = f(y, idx_map, *args_link)\n        ys.append(y)\n\n    if reverse:\n        ys.reverse()\n\n    ys = tree_utils.tree_batch(ys, backend=\"jax\")\n    return ys\n</code></pre>"},{"location":"api/transform/","title":"Transform","text":""},{"location":"api/transform/#x_xy.base.Transform","title":"<code>Transform</code>","text":"<p>Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B, where B is located relative to A at <code>pos</code> in frame A and <code>rot</code> is the relative quaternion from A to B.</p> Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass Transform(_Base):\n\"\"\"Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B,\n    where B is located relative to A at `pos` in frame A and `rot` is the\n    relative quaternion from A to B.\"\"\"\n\n    pos: Vector\n    rot: Quaternion\n\n    @classmethod\n    def create(cls, pos=None, rot=None):\n        assert not (pos is None and rot is None), \"One must be given.\"\n        shape_rot = rot.shape[:-1] if rot is not None else ()\n        shape_pos = pos.shape[:-1] if pos is not None else ()\n\n        if pos is None:\n            pos = jnp.zeros(shape_rot + (3,))\n        if rot is None:\n            rot = jnp.array([1.0, 0, 0, 0])\n            rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape_pos + (1,))\n\n        assert pos.shape[:-1] == rot.shape[:-1]\n\n        return Transform(pos, rot)\n\n    @classmethod\n    def zero(cls, shape=()) -&gt; \"Transform\":\n\"\"\"Returns a zero transform with a batch shape.\"\"\"\n        pos = jnp.zeros(shape + (3,))\n        rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape + (1,))\n        return Transform(pos, rot)\n\n    def as_matrix(self) -&gt; jax.Array:\n        E = maths.quat_to_3x3(self.rot)\n        return maths.spatial.quadrants(aa=E, bb=E) @ maths.spatial.xlt(self.pos)\n</code></pre>"},{"location":"api/transform/#x_xy.base.Transform.zero","title":"<code>zero(shape=())</code>  <code>classmethod</code>","text":"<p>Returns a zero transform with a batch shape.</p> Source code in <code>x_xy/base.py</code> <pre><code>@classmethod\ndef zero(cls, shape=()) -&gt; \"Transform\":\n\"\"\"Returns a zero transform with a batch shape.\"\"\"\n    pos = jnp.zeros(shape + (3,))\n    rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape + (1,))\n    return Transform(pos, rot)\n</code></pre>"},{"location":"api/transform/#x_xy.algebra.transform.transform_mul","title":"<code>transform_mul(t2, t1)</code>","text":"<p>Chains two transformations <code>t1</code> and <code>t2</code>. t1: Pl\u00fccker A -&gt; Pl\u00fccker B, t2: Pl\u00fccker B -&gt; Pl\u00fccker C =&gt; Returns: Pl\u00fccker A -&gt; Pl\u00fccker C</p> Source code in <code>x_xy/algebra/transform.py</code> <pre><code>def transform_mul(t2: base.Transform, t1: base.Transform) -&gt; base.Transform:\n\"\"\"Chains two transformations `t1` and `t2`.\n    t1: Pl\u00fccker A -&gt; Pl\u00fccker B,\n    t2: Pl\u00fccker B -&gt; Pl\u00fccker C\n    =&gt;\n    Returns: Pl\u00fccker A -&gt; Pl\u00fccker C\n    \"\"\"\n    pos = t1.pos + maths.rotate(t2.pos, maths.quat_inv(t1.rot))\n    rot = maths.quat_mul(t2.rot, t1.rot)\n    return base.Transform(pos, rot)\n</code></pre>"},{"location":"api/transform/#x_xy.algebra.transform.transform_inv","title":"<code>transform_inv(t)</code>","text":"<p>Inverts the transform. A -&gt; B becomes B -&gt; A</p> Source code in <code>x_xy/algebra/transform.py</code> <pre><code>def transform_inv(t: base.Transform) -&gt; base.Transform:\n    \"Inverts the transform. A -&gt; B becomes B -&gt; A\"\n    pos = maths.rotate(-t.pos, t.rot)\n    rot = maths.quat_inv(t.rot)\n    return base.Transform(pos, rot)\n</code></pre>"},{"location":"notebooks/batched_simulation/","title":"Batched simulation","text":"<p>This example is available as a jupyter notebook here.</p> <p><code>System</code> object is a registered Jax-PyTree. This means it's a nested array.</p> <p>This enables us to stack multiple systems (or states) to enable vectorized operations.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\n\n\nxml_str = \"\"\"\n&lt;x_xy model=\"double_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"upper\" euler=\"0 90 0\" joint=\"ry\" damping=\"2\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"lower\" pos=\"1 0 0\" joint=\"ry\" damping=\"2\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nstate = x_xy.State.create(sys)\n</code></pre> <pre><code># second system with gravity disabled\nsys_nograv = sys.replace(gravity = sys.gravity * 0.0)\nsys_batched = sys.batch(sys_nograv)\n\nnext_state_batched = jax.vmap(x_xy.step, in_axes=(0, None))(sys_batched, state)\n</code></pre> <pre><code># note how the state of the system without gravity has not changed at all\nnext_state_batched.q\n</code></pre> <pre>\n<code>Array([[-1.7982468e-10,  2.3305433e-10],\n       [ 0.0000000e+00,  0.0000000e+00]], dtype=float32)</code>\n</pre> <pre><code>second_state = x_xy.State.create(sys, qd=jnp.ones((2,)))\nstate_batched = state.batch(second_state)\nnext_state_batched = jax.vmap(x_xy.step, in_axes=(None, 0))(sys, state_batched)\n</code></pre> <pre><code>next_state_batched.q\n</code></pre> <pre>\n<code>Array([[-1.7982468e-10,  2.3305433e-10],\n       [ 1.0048340e-02,  9.8215193e-03]], dtype=float32)</code>\n</pre> <p>Batched kinematic simulation is done using either <code>x_xy.batch_generator</code> or <code>x_xy.offline_generator</code>.</p> <pre><code>gen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nbatchsize = 8\ngen_batched = x_xy.batch_generator(gen, batchsizes=batchsize)\nseed = 1\nqs, xs = gen_batched(jax.random.PRNGKey(seed))\n</code></pre> <pre><code>qs.shape\n</code></pre> <pre>\n<code>(8, 1000, 2)</code>\n</pre> <pre><code>\n</code></pre>"},{"location":"notebooks/batched_simulation/#batched-dynamical-simulation","title":"Batched Dynamical Simulation","text":""},{"location":"notebooks/batched_simulation/#batched-system","title":"Batched System","text":"<p>I.e. simulating two different system with the same initial state.</p>"},{"location":"notebooks/batched_simulation/#batched-state","title":"Batched State","text":""},{"location":"notebooks/batched_simulation/#batched-kinematic-simulation","title":"Batched Kinematic Simulation","text":""},{"location":"notebooks/control/","title":"Control","text":"<p>This example is available as a jupyter notebook here.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\n</code></pre> <p>The <code>step</code> function also takes generalized forces <code>tau</code> applied to the degrees of freedom its third input <code>step(sys, state, taus)</code>.</p> <p>Let's consider an inverted pendulum on a cart, and apply a left-right force onto the cart such that the pole stays in the upright position.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"inv_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;defaults&gt;\n        &lt;geom edge_color=\"black\" color=\"white\"/&gt;\n    &lt;/defaults&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"cart\" joint=\"px\" damping=\"0.01\"&gt;\n            &lt;geom type=\"box\" mass=\"1\" dim=\"0.4 0.1 0.1\"/&gt;\n            &lt;body name=\"pendulum\" joint=\"ry\" euler=\"0 -90 0\" damping=\"0.01\"&gt;\n                &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.5 0 0\" dim=\"1 0.1 0.1\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nstate = x_xy.State.create(sys, q=jnp.array([0.0, 0.2])) \n\nxs = []\nT = 10.0\nfor t in range(int(T / sys.dt)):\n    measurement_noise = np.random.normal() * 5\n    phi = jnp.rad2deg(state.q[1]) + measurement_noise\n    cart_motor_input = 0.1 * phi * abs(phi)\n    taus = jnp.clip(jnp.array([cart_motor_input, 0.0]), -10, 10) \n    state = jax.jit(x_xy.step)(sys, state, taus)\n    xs.append(state.x)\n</code></pre> <pre><code>def show_video(sys, xs: list[x_xy.Transform]):\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render(sys, [xs[i] for i in range(0, len(xs), 4)], camera=\"c\", add_cameras={-1: '&lt;camera name=\"c\" mode=\"targetbody\" target=\"0\" pos=\"0 -2 2\"/&gt;'})\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01&lt;00:00, 242.17it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>xml_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"pendulum\" joint=\"ry\" euler=\"0 90 0\" damping=\"0.01\" pos=\"0 0 1\"&gt;\n            &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.5 0 0\" dim=\"1 0.1 0.1\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nP, D = jnp.array([10.0]), jnp.array([1.0])\n\ndef simulate_pd_control(sys, P, D):\n    controller = x_xy.pd_control(P, D)\n    # reference signal\n    q_ref = jnp.ones((1000, 1)) * jnp.pi / 2\n    controller_state = controller.init(sys, q_ref)\n    state = x_xy.State.create(sys) \n\n    xs = []\n    T = 5.0\n    for t in range(int(T / sys.dt)):\n        controller_state, taus = jax.jit(controller.apply)(controller_state, sys, state)\n        state = jax.jit(x_xy.step)(sys, state, taus)\n        xs.append(state.x)\n    return xs\n</code></pre> <pre><code>xs = simulate_pd_control(sys, P, D)\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00&lt;00:00, 254.63it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Note the steady state error. This is because we have gravity and no Integral part (so no PID control).</p> <p>If we remove gravity the steady state error also vanishes (as is expected.)</p> <pre><code>sys_nograv = sys.replace(gravity = sys.gravity * 0.0)\nxs = simulate_pd_control(sys_nograv, P, D)\nshow_video(sys_nograv, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00&lt;00:00, 248.42it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/control/#balance-an-inverted-pendulum-on-a-cart","title":"Balance an inverted Pendulum on a cart","text":""},{"location":"notebooks/control/#pd-control","title":"PD Control","text":""},{"location":"notebooks/custom_joint_type/","title":"Custom joint type","text":"<p>This example is available as a jupyter notebook here.</p> <p>In this notebook we will define a new joint type that is a hinge joint with a random joint axes direction.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\n\nimport mediapy as media\n</code></pre> <p>We will give this new joint type the identifier <code>rr</code> (random revolute).</p> <pre><code>from x_xy.algorithms.jcalc import _draw_rxyz\n\n\n# we use this `params` input to specify the joint-axes, if we later then randomize the attribute of the system object\n# we will have the effect of a hinge joint with a randomized joint axes direction\n\n# set the dimensionality of the attribute to 3 for each joint / link in the system.\n# This is save because the library itself does not use this attribute at all\nx_xy.base.update_n_joint_params(3)\n\ndef _rr_transform(q, params):\n    axis = params\n    q = jnp.squeeze(q)\n    rot = x_xy.maths.quat_rot_axis(axis, q)\n    return x_xy.Transform.create(rot=rot)\n\n# we don't specify the motion vectors; They are required for dynamic simulation\nrr_joint = x_xy.JointModel(_rr_transform, rcmg_draw_fn=_draw_rxyz)\n\n# qd_width is zero because we have not specified the motion vectors\nx_xy.register_new_joint_type(\"rr\", rr_joint, q_width=1, qd_width=0)\n</code></pre> <pre><code>xml_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"pendulum\" joint=\"rr\"&gt;\n            &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.25 0 0\" dim=\"0.5 0.1 0.1\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n</code></pre> <pre><code>def setup_fn_randomize_joint_axes(key, sys: x_xy.System) -&gt; x_xy.System:\n    \"Randomizes the `sys.links.joint_params` attribute, which is used as joint-axis direction.\"\n    @jax.vmap\n    def _draw_random_joint_axis(key):\n        return x_xy.maths.rotate(jnp.array([1.0, 0, 0]), x_xy.maths.quat_random(key))\n\n    joint_axes = _draw_random_joint_axis(jax.random.split(key, sys.num_links()))\n    return sys.replace(links=sys.links.replace(joint_params=joint_axes))\n\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, ang0_min=0.0, ang0_max=0.0), \n                           setup_fn=setup_fn_randomize_joint_axes)\n_, xs = gen(jax.random.PRNGKey(1))\n</code></pre> <pre><code>def show_video(sys, xs: x_xy.Transform):\n    # right now `xs` is a batched `Transform` object\n    # so convert to a list of unbatched `Transform` object which is what `render_frames` expects.\n    xs = [xs[i] for i in range(xs.shape())]\n\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render(sys, [xs[i] for i in range(0, len(xs), 4)], camera=\"target\")\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:00&lt;00:00, 265.98it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>And now with a different seed, the joint axis (and motion) is different.</p> <pre><code>_, xs = gen(jax.random.PRNGKey(3))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:00&lt;00:00, 277.61it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/custom_joint_type/#defining-a-custom-joint-type","title":"Defining a custom Joint Type","text":""},{"location":"notebooks/error_quaternion/","title":"Error quaternion","text":"<p>In this notebook we will talk about what functions you need to do ML with quaternions. After all the purpose of this library is to create training data.</p> <p>Typically, this involves quaternions as target values (to be predicted), similar to an orientation estimation filter (like VQF).</p> <p>So, suppose you want to train some ML model that predicts a quaternion \\(\\hat{q} = f_\\theta(X)\\).</p> <pre><code>import x_xy\nimport jax \nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n</code></pre> <pre><code># suppose a 6D IMU input\nfeature_dim = 6\n\nparams = jax.random.normal(jax.random.PRNGKey(1), (4, feature_dim))\ndef neural_network(params, X):\n    q_unnormalized = params@X\n    norm = jnp.linalg.norm(q_unnormalized)\n    return q_unnormalized / norm\n\n\ndef loss_fn(params, X, y):\n    q, qhat = y, neural_network(params, X)\n    # squared angle error\n    return x_xy.maths.angle_error(q, qhat)**2\n</code></pre> <p>But this is dangerous as this might lead to NaNs.</p> <pre><code>X = jnp.zeros((6,))\ny = jnp.array([1.0, 0, 0, 0])\nloss_fn(params, X, y)\n</code></pre> <pre>\n<code>Array(nan, dtype=float32)</code>\n</pre> <p>We could try to fix is by adding a small number in the divison.</p> <pre><code># suppose a 6D IMU input\nfeature_dim = 6\n\nparams = jax.random.normal(jax.random.PRNGKey(1), (4, feature_dim))\ndef neural_network(params, X):\n    q_unnormalized = params@X\n    norm = jnp.linalg.norm(q_unnormalized)\n    eps = 1e-8\n    return q_unnormalized / (norm + eps)\n\n\ndef loss_fn(params, X, y):\n    q, qhat = y, neural_network(params, X)\n    # squared angle error\n    return x_xy.maths.angle_error(q, qhat)**2\n\nX = jnp.zeros((6,))\ny = jnp.array([1.0, 0, 0, 0])\nloss_fn(params, X, y)\n</code></pre> <pre>\n<code>Array(0., dtype=float32)</code>\n</pre> <p>But, still the gradient required for backpropagation gives NaNs.</p> <pre><code>jax.grad(loss_fn)(params, X, y)\n</code></pre> <pre>\n<code>Array([[nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan]], dtype=float32)</code>\n</pre> <p>The solution is a little involved. TLDR; Use <code>x_xy.maths.safe_normalize</code></p> <pre><code># suppose a 6D IMU input\nfeature_dim = 6\n\nparams = jax.random.normal(jax.random.PRNGKey(1), (4, feature_dim))\ndef neural_network(params, X):\n    q_unnormalized = params@X\n    return x_xy.maths.safe_normalize(q_unnormalized)\n\n\ndef loss_fn(params, X, y):\n    q, qhat = y, neural_network(params, X)\n    # squared angle error\n    return x_xy.maths.angle_error(q, qhat)**2\n\nX = jnp.zeros((6,))\ny = jnp.array([1.0, 0, 0, 0])\nloss_fn(params, X, y)\n</code></pre> <pre>\n<code>Array(0., dtype=float32)</code>\n</pre> <pre><code>jax.grad(loss_fn)(params, X, y)\n</code></pre> <pre>\n<code>Array([[0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.]], dtype=float32)</code>\n</pre> <p>Let's take a closer look at the function <code>x_xy.maths.angle_error</code> which was used in the <code>loss_fn</code> in the above.</p> <p>What is the behaviour of the error function (sort of the metric) between two quaternions as one approaches the other?</p> <p>A first implementation might look like this:</p> <pre><code>def quat_error(q, qhat):\n    q_error = x_xy.maths.quat_mul(x_xy.maths.quat_inv(q), qhat)\n    phi = 2 * jnp.arccos(q_error[0])\n    return jnp.abs(phi)\n</code></pre> <p>Let's reduce this function to the critical operation <code>phi = ...</code> and let's assume, without loss of generality, that the target quaternion is the identity quaternion.</p> <p>Then, this effectively becomes about extracting the angle from a quaternion safely.</p> <pre><code>def quat_angle(q):\n    return 2 * jnp.arccos(q[0])\n</code></pre> <pre><code>input_angles = jnp.linspace(-0.005, 0.005, num=1000)\n\ndef input_to_output_angles_incorrect(angle):\n    q = x_xy.maths.quat_rot_axis(jnp.array([1.0, 0, 0]), angle)\n    return quat_angle(q)\n\ndef input_to_output_angles_correct(angle):\n    q = x_xy.maths.quat_rot_axis(jnp.array([1.0, 0, 0]), angle)\n    return x_xy.maths.quat_angle(q)\n</code></pre> <pre><code>plt.plot(input_angles, jax.vmap(input_to_output_angles_incorrect)(input_angles), label=\"incorrect\")\nplt.plot(input_angles, jax.vmap(input_to_output_angles_correct)(input_angles), label=\"correct\")\nplt.legend()\nplt.show()\n</code></pre> <p>As one might expect, the gradients are also much more stable.</p> <pre><code>plt.plot(input_angles, jax.vmap(jax.grad(input_to_output_angles_incorrect))(input_angles), label=\"incorrect\")\nplt.plot(input_angles, jax.vmap(jax.grad(input_to_output_angles_correct))(input_angles), label=\"correct\")\nplt.legend()\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"notebooks/error_quaternion/#the-error-quaternion-required-for-ml-purposes","title":"The error quaternion (required for ML purposes)","text":""},{"location":"notebooks/error_quaternion/#how-to-get-a-quaternion-as-network-output","title":"How to get a quaternion as network output?","text":"<p>That's easy enough. You normalize a four dimensional vector.</p>"},{"location":"notebooks/error_quaternion/#a-closer-look-at-the-function-x_xymathsangle_error","title":"A closer look at the function <code>x_xy.maths.angle_error</code>","text":""},{"location":"notebooks/error_quaternion/#pytorch-library-for-quaternion-operations","title":"Pytorch library for quaternion operations","text":"<p>These functions are for JAX, but the following should work for PyTorch -&gt; https://naver.github.io/roma/</p>"},{"location":"notebooks/experimental_data/","title":"Experimental data","text":"<pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\n\ndef show_video(sys, xs: x_xy.Transform) -&gt; None:\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render(sys, [xs[i] for i in range(0, xs.shape(), 4)], camera=\"c\",\n                         height=480, width=640, add_cameras={-1: '&lt;camera name=\"c\" mode=\"targetbody\" target=\"3\" pos=\".5 -.5 1.25\"/&gt;'})\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n</code></pre> <p>Experimental data and system definitions of the experimental setup are located in the sub-package <code>exp_data</code></p> <pre><code>from x_xy.subpkgs import exp\n</code></pre> <p>Multiple experimental trials will be made available. Right now only the trial with identifiers <code>S_04/6</code> is available.</p> <pre><code>exp_id = \"S_06\"\nsys = exp.load_sys(exp_id)\n</code></pre> <p>Let's first take a look at the system that was used in the experiments.</p> <pre><code>state = x_xy.State.create(sys)\n# update the maximal coordinates\nxs = x_xy.forward_kinematics(sys, state)[1].x.batch()\n</code></pre> <pre><code>show_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 48.62it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>As you can see a five segment kinematic chain was moved, and for each segment IMU measurements and OMC ground truth is available.</p> <p>Let's load this (no simulated) IMU and OMC data.</p> <pre><code># `canonical` is the identifier of the first motion pattern performed in this trial\n# `shaking` is the identifier of the last motion pattern performed in this trial\ndata = exp.load_data(exp_id, motion_start=\"canonical\", motion_stop=\"shaking\")\n</code></pre> <pre><code>data.keys()\n</code></pre> <pre>\n<code>dict_keys(['seg1', 'seg2', 'seg3', 'seg4', 'seg5'])</code>\n</pre> <pre><code>data[\"seg1\"].keys()\n</code></pre> <pre>\n<code>dict_keys(['imu_flex', 'imu_rigid', 'marker1', 'marker2', 'marker3', 'marker4', 'quat'])</code>\n</pre> <pre><code>data[\"seg1\"][\"imu_rigid\"].keys()\n</code></pre> <pre>\n<code>dict_keys(['acc', 'gyr', 'mag'])</code>\n</pre> <p>The quaternion <code>quat</code> is to be interpreted as the rotation from segment to an arbitrary OMC inertial frame.</p> <p>The position <code>marker1</code> is to be interpreted as the position vector from arbitrary OMC inertial frame to a specific marker (marker 1) on the respective segment (vector given in the OMC inertial frame).</p> <p>Then, for each segment actually two IMUs are attached to it. One is rigidly attached, one is non-rigidly attached (via foam).</p> <p>Also, how long is the trial?</p> <pre><code>data[\"seg1\"][\"marker1\"].shape\n</code></pre> <pre>\n<code>(32500, 3)</code>\n</pre> <p>It's 325 seconds of data.</p> <p>Let's take a look at the motion of the whole trial.</p> <p>To render it, we need maximal coordinates <code>xs</code> of all links in the system. Luckily, there exists a function inside sub-package <code>sim2real</code> that does this already (but please check out the source).</p> <pre><code>from x_xy.subpkgs import sim2real\n\n# this function is required because we have four markers per segment, so four positions\n# that we could use as the position of the frame for that segment. Inside the xml string\n# there is at the bottom comments that define which marker should be used for which segment\n# because they are close\nlink_name_pos_rot = exp.link_name_pos_rot_data(data, exp.load_xml_str(\"S_06\"))\n\nxs = sim2real.xs_from_raw(sys, link_name_pos_rot, qinv=True)\n</code></pre> <pre><code>show_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 8125/8125 [00:57&lt;00:00, 142.21it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Perfect. This is a rendered animation of the real experimental motion that was performed. You can see that the spacing between segments is not perfect.</p> <p>This is because in our idealistic system model joints have no spatial dimension but in reality they have. The entire setup is 3D printed, and the joints are also several centimeters long.</p> <p>The segments are 20cm long.</p> <p>We can use this experimental data to validate our simulated approaches or validate ML models that are learned on simulated training data.</p> <pre><code>\n</code></pre>"},{"location":"notebooks/experimental_data/#loading-and-working-with-experimental-data","title":"Loading and working with experimental data","text":""},{"location":"notebooks/getting_started/","title":"Getting started","text":"<p>This example is available as a jupyter notebook here.</p> <p>And on Google Colab here</p> <p>Setup the environment if this is executed on Google Colab.</p> <p>Make sure to change the runtime type to <code>GPU</code>. To do this go to <code>Runtime</code> -&gt; <code>Change runtime type</code> -&gt; <code>GPU</code></p> <p>Otherwise, rendering won't work in Google Colab.</p> <pre><code>import os\n\ntry:\n    import google.colab\n    IN_COLAB = True\nexcept:\n    IN_COLAB = False\n\nif IN_COLAB:\n    os.system(\"pip install --quiet 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'\")\n    os.system(\"pip install --quiet mediapy\")\n    os.system(\"pip install --quiet matplotlib\")\n</code></pre> <pre><code>import x_xy\n# automatically detects colab or not\nx_xy.utils.setup_colab_env()\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\n</code></pre> <p>Systems are defined with the following xml syntax.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"double_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"upper\" euler=\"0 90 0\" joint=\"ry\" damping=\"2\" pos=\"0 0 2\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"lower\" pos=\"1 0 0\" joint=\"ry\" damping=\"2\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n</code></pre> <p>With this xml description of the system, we are ready to load the system using <code>load_sys_from_str</code>. We can also save this to a text-file <code>double_pendulum.xml</code> and load with <code>load_sys_from_xml</code>.</p> <pre><code>sys = x_xy.load_sys_from_str(xml_str)\n</code></pre> <pre><code>sys.model_name\n</code></pre> <pre>\n<code>'double_pendulum'</code>\n</pre> <p>System objects have many attributes. You may refer to the API documentation for more details.</p> <pre><code>sys.link_names\n</code></pre> <pre>\n<code>['upper', 'lower']</code>\n</pre> <p>Let's start with the most obvious. A physical simulation. We refer to it as \"dynamical simulation\", in contrast to what we do a little later which is a purely kinematic simulation.</p> <p>First, we have to create the dynamical state of the system. It is defined by the all degrees of freedom in the system and their velocities. Here, we have two revolute joints (one degree of freedom). Thus, the minimal coordinates vector \\(q\\) and minimal velocity vector \\(q'\\) has two dimensions.</p> <pre><code>state = x_xy.State.create(sys)\n</code></pre> <pre><code>state.q\n</code></pre> <pre>\n<code>Array([0., 0.], dtype=float32)</code>\n</pre> <pre><code>state.qd\n</code></pre> <pre>\n<code>Array([0., 0.], dtype=float32)</code>\n</pre> <pre><code>next_state = x_xy.step(sys, state)\n</code></pre> <p>Massive speedups if we use <code>jax.jit</code> to jit-compile the function.</p> <pre><code>%timeit x_xy.step(sys, state)\n</code></pre> <pre>\n<code>339 ms \u00b1 15 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code>\n</pre> <pre><code>%timeit jax.jit(x_xy.step)(sys, state)\n</code></pre> <pre>\n<code>94.6 \u00b5s \u00b1 42.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code>\n</pre> <p>Let's unroll the dynamics for multiple timesteps.</p> <pre><code>T = 10.0\nxs = []\nfor _ in range(int(T / sys.dt)):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n</code></pre> <p>Next, let's render the frames and create an animation.</p> <pre><code>frames = x_xy.render(sys, xs, camera=\"targetfar\")\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03&lt;00:00, 250.57it/s]\n</code>\n</pre> <pre><code>def show_video(frames: list[np.ndarray], dt: float):\n    assert dt == 0.01\n    # frames are at 100 Hz, but let's create an animation at 25Hz\n    media.show_video([frames[i][..., :3] for i in range(0, len(frames), 4)], fps=25)\n\nshow_video(frames, sys.dt)\n</code></pre>        This browser does not support the video tag.        <p>Hmm, pretty boring. Let's get the pendulum into an configuration with some potential energy.</p> <p>All we have to change is the initial state <code>state.q</code>.</p> <pre><code>state = x_xy.State.create(sys, q=jnp.array([jnp.pi / 2, 0]))\n</code></pre> <pre><code>T = 10.0\nxs = []\nfor _ in range(int(T / sys.dt)):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n\nframes = x_xy.render(sys, xs, camera=\"targetfar\")\nshow_video(frames, sys.dt)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:04&lt;00:00, 249.70it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>That's more like it!</p> <p>Next, we will take a look at \"kinematic simulation\".</p> <p>Let's start with why you would want this. </p> <p>Imagine we want to learn a filter that estimates some quantity of interest from some sensor input. </p> <p>Then, we could try to create many random motions, record the measured sensor input, and the ground truth quantity of interest target values. </p> <p>This is then used as training data for a Machine Learning model.</p> <p>The general interface to kinematic simulation is via <code>x_xy.build_generator</code>.</p> <p>This function creates a function (of type <code>Generator</code>) that maps a PRNG seed to, e.g., <code>X, y</code> data.</p> <pre><code>gen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nseed = 1\n_, xs = gen(jax.random.PRNGKey(seed))\n</code></pre> <pre><code># right now `xs` is a batched `Transform` object\n# so convert to a list of unbatched `Transform` object which is what `render_frames` expects.\nxs_list = [xs[i] for i in range(xs.shape())]\n</code></pre> <pre><code>frames = x_xy.render(sys, xs_list, camera=\"targetfar\")\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:04&lt;00:00, 246.81it/s]\n</code>\n</pre> <p>This is now completely random, but unphysical motion. It's only kinematics, but that is okay for creating training data.</p> <pre><code>show_video(frames, sys.dt)\n</code></pre>        This browser does not support the video tag.        <p>We are interested in simulating IMU data as input <code>X</code>, and estimating quaternions as target <code>y</code>.</p> <p>We can easily simulate an IMU with only the trajectory of maximal coordinates <code>xs</code>.</p> <p>Suppose, we want to simulate an IMU right that is placed on the <code>lower</code> segment and right at the revolute joint.</p> <p>This is exactly where the coordinate system of the <code>lower</code> segment is placed.</p> <p>Right now the <code>xs</code> trajectory contains both coordinate sytems of <code>upper</code> and <code>lower</code>.</p> <pre><code># (n_timesteps, n_links, 3)\nxs.pos.shape\n</code></pre> <pre>\n<code>(1000, 2, 3)</code>\n</pre> <pre><code># (n_timesteps, n_links, 4)\nxs.rot.shape\n</code></pre> <pre>\n<code>(1000, 2, 4)</code>\n</pre> <p>From the axis with length two, the 0th entry is for <code>upper</code> and the 1st entry is for <code>lower</code>.</p> <pre><code>sys.name_to_idx(\"upper\")\n</code></pre> <pre>\n<code>0</code>\n</pre> <pre><code>sys.name_to_idx(\"lower\")\n</code></pre> <pre>\n<code>1</code>\n</pre> <pre><code>xs_lower = xs.take(1, axis=1)\n</code></pre> <pre><code>imu_lower = x_xy.imu(xs_lower, sys.gravity, sys.dt)\n</code></pre> <pre><code>imu_lower.keys()\n</code></pre> <pre>\n<code>dict_keys(['acc', 'gyr'])</code>\n</pre> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), imu_lower[\"gyr\"], label=[\"x\", \"y\", \"z\"])\nplt.ylabel(\"gyro [rad / s]\")\nplt.xlabel(\"time [s]\")\nplt.legend()\nplt.show()\n</code></pre> <p>As you can see it's a two-dimensional problem, which is why only one (<code>y</code>) is non-zero.</p> <p>Let's consider a larger kinematic chain in free 3D space.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"three_segment_kinematic_chain\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\" pos=\"0 0 2\"&gt;\n            &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"seg1\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"-0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"-0.5 0 0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rz\" pos=\"1 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.5 0 -0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nseed = 1\n_, xs = gen(jax.random.PRNGKey(seed))\nxs_list = [xs[i] for i in range(xs.shape())]\nframes = x_xy.render(sys, xs_list, camera=\"targetfar\")\nshow_video(frames, sys.dt)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:04&lt;00:00, 203.91it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>We can modify the <code>build_generator</code> with a custom <code>finalize_fn</code> which determines what output the generator generates.</p> <p>The two orange boxes on segment 1 and segment 3 are modelling our two IMUs. This will be the network's input <code>X</code> data.</p> <p>As target we will try to estimate both relative orientations as <code>y</code> data.</p> <pre><code>def finalize_fn(key: jax.Array, q: jax.Array, xs: x_xy.Transform, sys: x_xy.System):\n    xs_by_name = lambda name: xs.take(sys.name_to_idx(name), axis=1)\n    X = {\n        \"seg1\": x_xy.imu(xs_by_name(\"imu1\"), sys.gravity, sys.dt),\n        \"seg3\": x_xy.imu(xs_by_name(\"imu2\"), sys.gravity, sys.dt),\n    }\n\n    xs_seg1 = xs_by_name(\"seg1\")\n    xs_seg2 = xs_by_name(\"seg2\")\n    xs_seg3 = xs_by_name(\"seg3\")\n\n    # all `xs` transforms are to be interpreted as \"from epsilon to segment\"\n    xs_from_seg2_to_seg1 = x_xy.transform_mul(xs_seg1, x_xy.transform_inv(xs_seg2))\n    xs_from_seg3_to_seg2 = x_xy.transform_mul(xs_seg2, x_xy.transform_inv(xs_seg3))\n\n    y = {\n        # we only estimate the orientation, so extract the quaternion from the transform (transform.rot)\n        \"seg2\": xs_from_seg2_to_seg1.rot,\n        \"seg3\": xs_from_seg3_to_seg2.rot\n    }\n    return X, y\n\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5), finalize_fn=finalize_fn)\nseed = 1\nX, y = gen(jax.random.PRNGKey(seed))\n</code></pre> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), X[\"seg1\"][\"gyr\"], label=[\"x\", \"y\", \"z\"])\nplt.ylabel(\"gyro [rad / s]\")\nplt.xlabel(\"time [s]\")\nplt.title(\"IMU 1 Gyroscope\")\nplt.legend()\nplt.show()\n</code></pre> <p>Now, the IMU is non-zero in all three <code>x/y/z</code> components.</p> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), y[\"seg2\"], label=[\"w\", \"x\", \"y\", \"z\"])\nplt.xlabel(\"time [s]\")\nplt.title(\"Relative quaternion from seg2 to seg1\")\nplt.legend()\nplt.show()\n</code></pre> <p>Note how the relative quaternion is only around the y-axis. Can you see why? (Hint: Check the defining <code>xml_str</code>.)</p> <pre><code>\n</code></pre>"},{"location":"notebooks/getting_started/#dynamical-simulation","title":"Dynamical Simulation","text":""},{"location":"notebooks/getting_started/#kinematic-simulation","title":"Kinematic Simulation","text":""},{"location":"notebooks/getting_started/#x-y-training-data-attaching-sensors","title":"<code>X, y</code> Training data / Attaching sensors","text":""},{"location":"notebooks/imu_modeling/","title":"Imu modeling","text":"<pre><code>from x_xy.subpkgs import exp\nimport matplotlib.pyplot as plt\nimport jax\nimport x_xy\nimport jax.numpy as jnp\n\nhz = 100\n\ndef load_data(seg: str, t1: float, t2: float, motion: str = \"fast\"):\n\n    data = exp.load_data(\"S_06\", motion)[seg]\n\n    # extract a small window from long time series for plotting\n    pos, rot, imu_data = jax.tree_map(lambda arr: arr[int(t1 * hz): int(t2 * hz)], (data[\"pos\"], data[\"quat\"], data[\"imu_rigid\"]))\n\n    # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation\n    xs = x_xy.Transform.create(pos, rot)\n    return pos, rot, xs, imu_data\n\n\nt1, t2 = 3.0, 8.0\npos, rot, xs, imu_data = load_data(\"seg1\", t1, t2)\n</code></pre> <p>Remove gravity from accelerometer to better compare.</p> <pre><code>def linear_acceleration(xs: x_xy.Transform, acc: jax.Array) -&gt; jax.Array:\n    q_E2Imu = xs.rot\n    q_Imu2E = x_xy.maths.quat_inv(q_E2Imu)\n    gravity = jnp.array([0, 0, 9.81])\n    acc_E_nograv = x_xy.maths.rotate(acc, q_Imu2E) - gravity\n    return x_xy.maths.rotate(acc_E_nograv, q_E2Imu)\n\nimu_data[\"acc\"] = linear_acceleration(xs, imu_data[\"acc\"])\n</code></pre> <pre><code>def plot_imu(imu_data: dict):\n    fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n    ts = jnp.arange(t1, t2, step=1 / hz)\n    axes[0].plot(ts, imu_data[\"acc\"], label=[\"x\", \"y\", \"z\"])\n    axes[1].plot(ts, imu_data[\"gyr\"], label=[\"x\", \"y\", \"z\"])\n    for ax in axes:\n        ax.grid()\n        ax.set_xlabel(\"time [s]\")\n        ax.legend()\n    axes[0].set_title(\"Acc\")\n    axes[1].set_title(\"Gyr\")\n\nplot_imu(imu_data)\n</code></pre> <pre><code>imu_data = x_xy.imu(xs, gravity=jnp.zeros((3,)), dt=1 / hz)\nplot_imu(imu_data)\n</code></pre> <p>Accelerometer doesn't look too great! We need low-pass filtering. Two options:</p> <pre><code>imu_data = x_xy.imu(xs, gravity=jnp.zeros((3,)), dt=1 / hz, quasi_physical=True)\nplot_imu(imu_data)\n</code></pre> <pre><code>imu_data = x_xy.imu(xs, gravity=jnp.zeros((3,)), dt=1 / hz, low_pass_filter_pos_f_cutoff=15.0)\nplot_imu(imu_data)\n</code></pre> <pre><code>from scipy.optimize import minimize\n\ndef optimize_parameters(seg: str, motion: str):\n\n    # include all `fast` data in the optimization\n    t1, t2 = 0.0, 500.0\n    pos, rot, xs, imu_data = load_data(seg, t1, t2, motion)\n    imu_data[\"acc\"] = linear_acceleration(xs, imu_data[\"acc\"])\n\n    @jax.jit\n    def objective(params):\n        f_cutoff, alpha, offset = params\n\n        # probably move about 5cm negative x-axis in local CS for e.g. segment 1\n        pos_offset = x_xy.maths.rotate(x_xy.maths.rotate(pos, rot) + jnp.array([offset, 0, 0]), x_xy.maths.quat_inv(rot))\n        xs_offset = xs.replace(pos=pos_offset)\n        imu = x_xy.imu(xs_offset, jnp.zeros((3,)), 1 / hz, low_pass_filter_pos_f_cutoff=f_cutoff, low_pass_filter_rot_alpha=alpha)\n\n        return jnp.mean((imu_data[\"acc\"] - imu[\"acc\"])**2) + jnp.mean((imu_data[\"gyr\"] - imu[\"gyr\"])**2)\n\n    return minimize(objective, jnp.array([5.0, 1.0, 0.0]), method=\"Nelder-Mead\")\n</code></pre> <pre><code>for seg in [\"seg1\", \"seg2\", \"seg3\", \"seg4\", \"seg5\"]:\n    print(optimize_parameters(seg, \"fast\"))\n</code></pre> <pre>\n<code>       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.38156038522720337\n             x: [ 1.500e+01  5.623e-01 -4.776e-02]\n           nit: 100\n          nfev: 204\n final_simplex: (array([[ 1.500e+01,  5.623e-01, -4.776e-02],\n                       [ 1.500e+01,  5.623e-01, -4.776e-02],\n                       [ 1.500e+01,  5.623e-01, -4.776e-02],\n                       [ 1.500e+01,  5.623e-01, -4.776e-02]]), array([ 3.816e-01,  3.816e-01,  3.816e-01,  3.816e-01]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.19639326632022858\n             x: [ 1.583e+01  5.625e-01  1.125e-01]\n           nit: 107\n          nfev: 212\n final_simplex: (array([[ 1.583e+01,  5.625e-01,  1.125e-01],\n                       [ 1.583e+01,  5.625e-01,  1.125e-01],\n                       [ 1.583e+01,  5.625e-01,  1.125e-01],\n                       [ 1.583e+01,  5.625e-01,  1.125e-01]]), array([ 1.964e-01,  1.964e-01,  1.964e-01,  1.964e-01]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.15156306326389313\n             x: [ 1.511e+01  5.674e-01  1.197e-01]\n           nit: 94\n          nfev: 185\n final_simplex: (array([[ 1.511e+01,  5.674e-01,  1.197e-01],\n                       [ 1.511e+01,  5.674e-01,  1.197e-01],\n                       [ 1.511e+01,  5.674e-01,  1.197e-01],\n                       [ 1.511e+01,  5.674e-01,  1.197e-01]]), array([ 1.516e-01,  1.516e-01,  1.516e-01,  1.516e-01]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.2534048855304718\n             x: [ 1.518e+01  6.136e-01  1.135e-01]\n           nit: 110\n          nfev: 217\n final_simplex: (array([[ 1.518e+01,  6.136e-01,  1.135e-01],\n                       [ 1.518e+01,  6.136e-01,  1.135e-01],\n                       [ 1.518e+01,  6.136e-01,  1.135e-01],\n                       [ 1.518e+01,  6.136e-01,  1.135e-01]]), array([ 2.534e-01,  2.534e-01,  2.534e-01,  2.534e-01]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.3209015429019928\n             x: [ 1.544e+01  5.507e-01  1.144e-01]\n           nit: 97\n          nfev: 189\n final_simplex: (array([[ 1.544e+01,  5.507e-01,  1.144e-01],\n                       [ 1.544e+01,  5.507e-01,  1.144e-01],\n                       [ 1.544e+01,  5.507e-01,  1.144e-01],\n                       [ 1.544e+01,  5.507e-01,  1.144e-01]]), array([ 3.209e-01,  3.209e-01,  3.209e-01,  3.209e-01]))\n</code>\n</pre> <pre><code>for seg in [\"seg1\", \"seg2\", \"seg3\", \"seg4\", \"seg5\"]:\n    print(optimize_parameters(seg, \"slow\"))\n</code></pre> <pre>\n<code>       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.05660155788064003\n             x: [ 1.318e+01  5.559e-01 -4.799e-02]\n           nit: 87\n          nfev: 177\n final_simplex: (array([[ 1.318e+01,  5.559e-01, -4.799e-02],\n                       [ 1.318e+01,  5.559e-01, -4.799e-02],\n                       [ 1.318e+01,  5.559e-01, -4.799e-02],\n                       [ 1.318e+01,  5.559e-01, -4.799e-02]]), array([ 5.660e-02,  5.660e-02,  5.661e-02,  5.661e-02]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.02298727259039879\n             x: [ 1.453e+01  5.282e-01  1.055e-01]\n           nit: 84\n          nfev: 174\n final_simplex: (array([[ 1.453e+01,  5.282e-01,  1.055e-01],\n                       [ 1.453e+01,  5.282e-01,  1.055e-01],\n                       [ 1.453e+01,  5.282e-01,  1.055e-01],\n                       [ 1.453e+01,  5.282e-01,  1.055e-01]]), array([ 2.299e-02,  2.299e-02,  2.299e-02,  2.300e-02]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.013075611554086208\n             x: [ 1.237e+01  4.849e-01  1.249e-01]\n           nit: 82\n          nfev: 173\n final_simplex: (array([[ 1.237e+01,  4.849e-01,  1.249e-01],\n                       [ 1.237e+01,  4.849e-01,  1.249e-01],\n                       [ 1.237e+01,  4.849e-01,  1.249e-01],\n                       [ 1.237e+01,  4.849e-01,  1.249e-01]]), array([ 1.308e-02,  1.308e-02,  1.308e-02,  1.308e-02]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.012152391485869884\n             x: [ 1.057e+01  5.120e-01  1.202e-01]\n           nit: 91\n          nfev: 185\n final_simplex: (array([[ 1.057e+01,  5.120e-01,  1.202e-01],\n                       [ 1.057e+01,  5.120e-01,  1.202e-01],\n                       [ 1.057e+01,  5.120e-01,  1.202e-01],\n                       [ 1.057e+01,  5.120e-01,  1.202e-01]]), array([ 1.215e-02,  1.215e-02,  1.215e-02,  1.215e-02]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.06411495804786682\n             x: [ 1.262e+01  5.616e-01  1.098e-01]\n           nit: 98\n          nfev: 201\n final_simplex: (array([[ 1.262e+01,  5.616e-01,  1.098e-01],\n                       [ 1.262e+01,  5.616e-01,  1.098e-01],\n                       [ 1.262e+01,  5.616e-01,  1.098e-01],\n                       [ 1.262e+01,  5.616e-01,  1.098e-01]]), array([ 6.411e-02,  6.412e-02,  6.412e-02,  6.413e-02]))\n</code>\n</pre> <pre><code>\n</code></pre>"},{"location":"notebooks/imu_modeling/#on-what-imus-measure","title":"On \"what IMUs measure\"","text":""},{"location":"notebooks/imu_modeling/#real-world-imu","title":"Real-world IMU","text":""},{"location":"notebooks/imu_modeling/#vanilla-simulated-imu","title":"Vanilla simulated IMU","text":""},{"location":"notebooks/imu_modeling/#quasi-physical-simulation-strategy","title":"Quasi-physical simulation strategy","text":""},{"location":"notebooks/imu_modeling/#butterworth-filtering","title":"Butterworth filtering","text":""},{"location":"notebooks/imu_modeling/#optimize-low-pass-filter-parameters","title":"Optimize low-pass-filter parameters","text":""},{"location":"notebooks/morph_system/","title":"Morph system","text":"<pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\n\ndef show_video(sys, xs: x_xy.Transform) -&gt; None:\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render(sys, [xs[i] for i in range(0, xs.shape(), 4)], camera=\"targetfar\", height=480, width=640)\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n</code></pre> <p>In this system the middle segment <code>seg2</code> acts as \"anchor\".</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"three_segment_kinematic_chain\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\" pos=\"0 0 1\"&gt;\n            &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\" color=\"self\"/&gt;\n            &lt;body name=\"seg1\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"-0.5 0 0\" dim=\"1 0.25 0.2\" color=\"self\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"-0.5 0 0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rz\" pos=\"1 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\" color=\"self\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.5 0 -0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, dang_max_free_spherical=0.1, dpos_max=0.1))\n_, xs = gen(jax.random.PRNGKey(1))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01&lt;00:00, 180.20it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Can you see what i mean? The middle segment has all the \"global rotation and translation\".</p> <p>Let's move the anchor to <code>seg1</code> but without changing the xml syntax. This can be done with the subpackage <code>sys_composer</code>.</p> <pre><code>from x_xy.subpkgs import sys_composer\n</code></pre> <pre><code># the new parents of seg2, seg1, imu1, seg3, imu2 are ...\nnew_parents = [\"seg1\", -1, \"seg1\", \"seg2\", \"seg3\"]\nsys = sys_composer.morph_system(sys, new_parents=new_parents)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, dang_max_free_spherical=0.1, dpos_max=0.1))\n_, xs = gen(jax.random.PRNGKey(1))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01&lt;00:00, 184.32it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Pretty cool, ha? :)</p> <pre><code>\n</code></pre>"},{"location":"notebooks/morph_system/#different-anchors-explains-sys_composermorph_system","title":"Different Anchors (explains sys_composer.morph_system)","text":""}]}