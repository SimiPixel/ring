{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#x_xy_v2","title":"<code>x_xy_v2</code>","text":""},{"location":"#installation","title":"Installation","text":"<p>Supports <code>Python=3.10/3.11</code> (tested).</p> <p>Install with <code>pip</code> using</p> <p><code>pip install 'x_xy[all] @ git+https://github.com/SimiPixel/x_xy_v2'</code></p> <p>Typically, this will install <code>jax</code> as cpu-only version. Afterwards, gpu-enabled version can be installed with <pre><code>pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n</code></pre></p> <p>or with (if NVIDIA driver is a little older) <pre><code>pip install --upgrade \"jax[cuda11_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n</code></pre></p>"},{"location":"#installation-of-extras","title":"Installation of Extras","text":"<p>Seperates dependencies neatly per subpackage. E.g. the dependencies for subpkg <code>omc</code> can be installed via</p> <p><code>pip install 'x_xy[omc] @ git+https://github.com/SimiPixel/x_xy_v2'</code></p> <p>Also available installs are</p> <p><code>pip install 'x_xy @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base; only subpackages <code>sys_composer</code> and <code>sim2real</code> work, no rendering)</p> <p><code>pip install 'x_xy[omc] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+omc)</p> <p><code>pip install 'x_xy[ml] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ml)</p> <p><code>pip install 'x_xy[exp] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+exp)</p> <p><code>pip install 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ mujoco rendering backend)</p> <p><code>pip install 'x_xy[vis] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ vispy rendering backend)</p> <p><code>pip install 'x_xy[all] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (everything works)</p> <p><code>pip install 'x_xy[all_muj] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (everything works but not vispy rendering only mujoco rendering)</p> <p><code>pip install 'x_xy[dev] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ development dependencies)</p> <p>Can also be combined, e.g. <code>pip install 'x_xy[ml,omc] @ git+https://github.com/SimiPixel/x_xy_v2'</code> (base+ml+omc)</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Available here.</p>"},{"location":"#known-fixes","title":"Known fixes","text":""},{"location":"#offscreen-rendering-with-mujoco","title":"Offscreen rendering with Mujoco","text":"<p>mujoco.FatalError: an OpenGL platform library has not been loaded into this process, this most likely means that a valid OpenGL context has not been created before mjr_makeContext was called</p> <p>Solution:</p> <pre><code>import os\nos.environ[\"MUJOCO_GL\"] = \"egl\"\n</code></pre>"},{"location":"#publications","title":"Publications","text":"<p>The following publications utilize this software library, and refer to it as the Random Chain Motion Generator (RCMG) (more specifically the function <code>x_xy.build_generator</code>):</p> <ul> <li>RNN-based Observability Analysis for Magnetometer-Free Sparse Inertial Motion Tracking</li> <li>Plug-and-Play Sparse Inertial Motion Tracking With Sim-to-Real Transfer</li> <li>RNN-based State and Parameter Estimation for Sparse Magnetometer-free Inertial Motion Tracking</li> </ul>"},{"location":"#other-useful-ressources","title":"Other useful ressources","text":"<p>Particularly useful is the following publication from Roy Featherstone - A Beginner\u2019s Guide to 6-D Vectors (Part 2)</p>"},{"location":"#contact","title":"Contact","text":"<p>Simon Bachhuber (simon.bachhuber@fau.de)</p>"},{"location":"api/maths/","title":"x_xy.maths","text":""},{"location":"api/maths/#x_xy.maths.quat.quat_mul","title":"<code>quat_mul(u, v)</code>","text":"<p>Multiplies two quaternions.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4),(4)-&gt;(4)\")\ndef quat_mul(u: jnp.ndarray, v: jnp.ndarray) -&gt; jnp.ndarray:\n    \"Multiplies two quaternions.\"\n    q = jnp.array(\n        [\n            u[0] * v[0] - u[1] * v[1] - u[2] * v[2] - u[3] * v[3],\n            u[0] * v[1] + u[1] * v[0] + u[2] * v[3] - u[3] * v[2],\n            u[0] * v[2] - u[1] * v[3] + u[2] * v[0] + u[3] * v[1],\n            u[0] * v[3] + u[1] * v[2] - u[2] * v[1] + u[3] * v[0],\n        ]\n    )\n    return q\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_inv","title":"<code>quat_inv(q)</code>","text":"<p>Calculates the inverse of quaternion q.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_inv(q: jnp.ndarray) -&gt; jnp.ndarray:\n    \"Calculates the inverse of quaternion q.\"\n    return q * jnp.array([1.0, -1, -1, -1])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_random","title":"<code>quat_random(key, batch_shape=(), maxval=jnp.pi)</code>","text":"<p>Provides a random unit quaternion, sampled uniformly</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_random(\n    key: jrand.PRNGKey, batch_shape: tuple = (), maxval: float = jnp.pi\n) -&gt; jax.Array:\n\"\"\"Provides a random *unit* quaternion, sampled uniformly\"\"\"\n    shape = batch_shape + (4,)\n    qs = safe_normalize(jrand.normal(key, shape))\n\n    def _scale_angle():\n        axis, angle = quat_to_rot_axis(qs)\n        angle_scaled = angle * maxval / jnp.pi\n        return quat_rot_axis(axis, angle_scaled)\n\n    return jax.lax.cond(maxval == jnp.pi, lambda: qs, _scale_angle)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.unit_quats_like","title":"<code>unit_quats_like(array)</code>","text":"<p>Array of unit quaternions of identical shape.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def unit_quats_like(array):\n    \"Array of *unit* quaternions of identical shape.\"\n    if array.shape[-1] != 4:\n        raise Exception()\n\n    return jnp.ones(array.shape[:-1])[..., None] * jnp.array([1.0, 0, 0, 0])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_rot_axis","title":"<code>quat_rot_axis(axis, angle)</code>","text":"<p>Construct a unit quaternion that describes rotating around <code>axis</code> by <code>angle</code> (radians).</p> <p>This is the interpretation of rotating the vector and not the frame. For the interpretation of rotating the frame and not the vector, you should use angle -&gt; -angle. NOTE: Usually, we actually want the second interpretation. Think about it, we use quaternions to re-express vectors in other frames. But the vectors stay the same. We only transform them to a common frames.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3),()-&gt;(4)\")\ndef quat_rot_axis(axis: jnp.ndarray, angle: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Construct a *unit* quaternion that describes rotating around\n    `axis` by `angle` (radians).\n\n    This is the interpretation of rotating the vector and *not*\n    the frame.\n    For the interpretation of rotating the frame and *not* the\n    vector, you should use angle -&gt; -angle.\n    NOTE: Usually, we actually want the second interpretation. Think about it,\n    we use quaternions to re-express vectors in other frames. But the\n    vectors stay the same. We only transform them to a common frames.\n    \"\"\"\n    assert axis.shape == (3,)\n    assert angle.shape == ()\n\n    axis = safe_normalize(axis)\n    # NOTE: CONVENTION\n    # 23.04.23\n    # this fixes the issue of prismatic joints being inverted w.r.t.\n    # gravity vector.\n    # The reason is that it inverts the way how revolute joints behave\n    # Such that prismatic joints work by inverting gravity\n    angle *= -1.0\n    s, c = jnp.sin(angle / 2), jnp.cos(angle / 2)\n    return jnp.array([c, *(axis * s)])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_rot_axis","title":"<code>quat_to_rot_axis(q)</code>","text":"<p>Extract unit-axis and angle from quaternion <code>q</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3),()\")\ndef quat_to_rot_axis(q):\n    \"Extract unit-axis and angle from quaternion `q`.\"\n    angle = quat_angle(q)\n    # NOTE: CONVENTION\n    angle *= -1.0\n    axis = safe_normalize(q[1:])\n    return axis, angle\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_euler","title":"<code>quat_euler(angles, intrinsic=True, convention='zyx')</code>","text":"<p>Construct a unit quaternion from Euler angles (radians).</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_euler(angles, intrinsic=True, convention=\"zyx\"):\n    \"Construct a *unit* quaternion from Euler angles (radians).\"\n\n    @partial(jnp.vectorize, signature=\"(3)-&gt;(4)\")\n    def _quat_euler(angles):\n        xunit = jnp.array([1.0, 0.0, 0.0])\n        yunit = jnp.array([0.0, 1.0, 0.0])\n        zunit = jnp.array([0.0, 0.0, 1.0])\n\n        axes_map = {\n            \"x\": xunit,\n            \"y\": yunit,\n            \"z\": zunit,\n        }\n\n        q1 = quat_rot_axis(axes_map[convention[0]], angles[0])\n        q2 = quat_rot_axis(axes_map[convention[1]], angles[1])\n        q3 = quat_rot_axis(axes_map[convention[2]], angles[2])\n\n        if intrinsic:\n            return quat_mul(q3, quat_mul(q2, q1))\n        else:\n            return quat_mul(q1, quat_mul(q2, q3))\n\n    return _quat_euler(angles)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_euler","title":"<code>quat_to_euler(q)</code>","text":"<p>Converts quaternions to euler rotations in radians.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3)\")\ndef quat_to_euler(q: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts quaternions to euler rotations in radians.\"\"\"\n    # this follows the Tait-Bryan intrinsic rotation formalism: x-y'-z''\n\n    # NOTE: CONVENTION\n    q = quat_inv(q)\n\n    z = jnp.arctan2(\n        -2 * q[1] * q[2] + 2 * q[0] * q[3],\n        q[1] * q[1] + q[0] * q[0] - q[3] * q[3] - q[2] * q[2],\n    )\n    # TODO: Investigate why quaternions go so big we need to clip.\n    y = safe_arcsin(jnp.clip(2 * q[1] * q[3] + 2 * q[0] * q[2], -1.0, 1.0))\n    x = jnp.arctan2(\n        -2 * q[2] * q[3] + 2 * q[0] * q[1],\n        q[3] * q[3] - q[2] * q[2] - q[1] * q[1] + q[0] * q[0],\n    )\n\n    return jnp.array([x, y, z])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_from_3x3","title":"<code>quat_from_3x3(m)</code>","text":"<p>Converts 3x3 rotation matrix to unit quaternion.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3,3)-&gt;(4)\")\ndef quat_from_3x3(m: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts 3x3 rotation matrix to *unit* quaternion.\"\"\"\n    w = jnp.sqrt(1 + m[0, 0] + m[1, 1] + m[2, 2]) / 2.0\n    x = (m[2][1] - m[1][2]) / (w * 4)\n    y = (m[0][2] - m[2][0]) / (w * 4)\n    z = (m[1][0] - m[0][1]) / (w * 4)\n    return jnp.array([w, x, y, z])\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_to_3x3","title":"<code>quat_to_3x3(q)</code>","text":"<p>Converts unit quaternion to 3x3 rotation matrix.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(3,3)\")\ndef quat_to_3x3(q: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Converts *unit* quaternion to 3x3 rotation matrix.\"\"\"\n    d = jnp.dot(q, q)\n    w, x, y, z = q\n    s = 2 / d\n    xs, ys, zs = x * s, y * s, z * s\n    wx, wy, wz = w * xs, w * ys, w * zs\n    xx, xy, xz = x * xs, x * ys, x * zs\n    yy, yz, zz = y * ys, y * zs, z * zs\n\n    return jnp.array(\n        [\n            jnp.array([1 - (yy + zz), xy - wz, xz + wy]),\n            jnp.array([xy + wz, 1 - (xx + zz), yz - wx]),\n            jnp.array([xz - wy, yz + wx, 1 - (xx + yy)]),\n        ]\n    )\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_project","title":"<code>quat_project(q, k)</code>","text":"<p>Decompose quaternion into a primary rotation around axis <code>k</code> such that the residual rotation's angle is minimized.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Array</code> <p>Quaternion to decompose.</p> required <code>k</code> <code>Array</code> <p>Primary axis direction.</p> required <p>Returns:</p> Type Description <code>tuple[Array, Array]</code> <p>tuple[jax.Array, jax.Array]: Primary quaternion, residual quaternion</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4),(3)-&gt;(4),(4)\")\ndef quat_project(q: jax.Array, k: jax.Array) -&gt; tuple[jax.Array, jax.Array]:\n\"\"\"Decompose quaternion into a primary rotation around axis `k` such that\n    the residual rotation's angle is minimized.\n\n    Args:\n        q (jax.Array): Quaternion to decompose.\n        k (jax.Array): Primary axis direction.\n\n    Returns:\n        tuple[jax.Array, jax.Array]: Primary quaternion, residual quaternion\n    \"\"\"\n    phi_pri = 2 * jnp.arctan2(q[1:] @ k, q[0])\n    # NOTE: CONVENTION\n    q_pri = quat_rot_axis(k, -phi_pri)\n    q_res = quat_mul(q, quat_inv(q_pri))\n    return q_pri, q_res\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_avg","title":"<code>quat_avg(qs)</code>","text":"<p>Tolga Birdal's algorithm.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_avg(qs: jax.Array):\n    \"Tolga Birdal's algorithm.\"\n    if qs.ndim == 1:\n        qs = qs[None, :]\n    assert qs.ndim == 2\n    return jnp.linalg.eigh(\n        jnp.einsum(\"ij,ik,i-&gt;...jk\", qs, qs, jnp.ones((qs.shape[0],)))\n    )[1][:, -1]\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_lowpassfilter","title":"<code>quat_lowpassfilter(qs, cutoff_freq=20.0, samp_freq=100.0, filtfilt=False)</code>","text":"Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_lowpassfilter(\n    qs: jax.Array,\n    cutoff_freq: float = 20.0,\n    samp_freq: float = 100.0,\n    filtfilt: bool = False,\n) -&gt; jax.Array:\n    assert qs.ndim == 2\n    assert qs.shape[1] == 4\n\n    if filtfilt:\n        qs = quat_lowpassfilter(qs, cutoff_freq, samp_freq, filtfilt=False)\n        qs = quat_lowpassfilter(jnp.flip(qs, 0), cutoff_freq, samp_freq, filtfilt=False)\n        return jnp.flip(qs, 0)\n\n    omega_times_Ts = 2 * jnp.pi * cutoff_freq / samp_freq\n    alpha = omega_times_Ts / (1 + omega_times_Ts)\n\n    def f(y, x):\n        # error quaternion; current state -&gt; target\n        q_err = quat_mul(x, quat_inv(y))\n        # scale down error quaternion\n        axis, angle = quat_to_rot_axis(q_err)\n        # ensure angle &gt;= 0\n        axis, angle = jax.lax.cond(\n            angle &lt; 0,\n            lambda axis, angle: (-axis, -angle),\n            lambda axis, angle: (axis, angle),\n            axis,\n            angle,\n        )\n        angle_scaled = angle * alpha\n        q_err_scaled = quat_rot_axis(axis, angle_scaled)\n        # move small step toward error quaternion\n        y = quat_mul(q_err_scaled, y)\n        return y, y\n\n    qs_filtered = jax.lax.scan(f, qs[0], qs[1:])[1]\n\n    # padd with first value, such that length remains equal\n    qs_filtered = jnp.vstack((qs[0:1], qs_filtered))\n\n    # renormalize due to float32 numerical errors accumulating\n    return qs_filtered / jnp.linalg.norm(qs_filtered, axis=-1, keepdims=True)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.rotate","title":"<code>rotate(vector, quat)</code>","text":"<p>Rotates a vector <code>vector</code> by a unit quaternion <code>quat</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(3),(4)-&gt;(3)\")\ndef rotate(vector: jnp.ndarray, quat: jnp.ndarray):\n\"\"\"Rotates a vector `vector` by a *unit* quaternion `quat`.\"\"\"\n    qvec = jnp.array([0, *vector])\n    return rotate_quat(qvec, quat)[1:4]\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.rotate_quat","title":"<code>rotate_quat(q, quat)</code>","text":"<p>Rotate quaternion <code>q</code> by <code>quat</code></p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def rotate_quat(q: jax.Array, quat: jax.Array):\n    \"Rotate quaternion `q` by `quat`\"\n    return quat_mul(quat, quat_mul(q, quat_inv(quat)))\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.rotate_matrix","title":"<code>rotate_matrix(matrix, quat)</code>","text":"<p>Rotate matrix <code>matrix</code> by a unit quaternion <code>quat</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def rotate_matrix(matrix: jax.Array, quat: jax.Array):\n    \"Rotate matrix `matrix` by a *unit* quaternion `quat`.\"\n    E = quat_to_3x3(quat)\n    return E @ matrix @ E.T\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_angle","title":"<code>quat_angle(q)</code>","text":"<p>Extract rotation angle (radians) of quaternion <code>q</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;()\")\ndef quat_angle(q):\n    \"Extract rotation angle (radians) of quaternion `q`.\"\n    phi = 2 * jnp.arctan2(safe_norm(q[1:])[0], q[0])\n    return wrap_to_pi(phi)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_angle_constantAxisOverTime","title":"<code>quat_angle_constantAxisOverTime(qs)</code>","text":"Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_angle_constantAxisOverTime(qs):\n    assert qs.ndim == 2\n    assert qs.shape[-1] == 4\n\n    l2norm = lambda x: jnp.sqrt(jnp.sum(x**2, axis=-1))\n\n    axis = safe_normalize(qs[:, 1:])\n    angle = quat_angle(qs)[:, None]\n    convention = axis[0]\n    cond = (l2norm(convention - axis) &gt; l2norm(convention + axis))[..., None]\n    return jnp.where(cond, -angle, angle)[:, 0]\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.angle_error","title":"<code>angle_error(q, qhat)</code>","text":"<p>Absolute angle in radians between <code>q</code> and <code>qhat</code>.</p> Source code in <code>x_xy/maths/quat.py</code> <pre><code>def angle_error(q, qhat):\n    \"Absolute angle in radians between `q` and `qhat`.\"\n    return jnp.abs(quat_angle(quat_mul(quat_inv(q), qhat)))\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_inclinationAngle","title":"<code>quat_inclinationAngle(q)</code>","text":"Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_inclinationAngle(q: jax.Array):\n    head, incl = quat_project(q, jnp.array([0.0, 0, 1]))\n    return quat_angle(incl)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.quat_headingAngle","title":"<code>quat_headingAngle(q)</code>","text":"Source code in <code>x_xy/maths/quat.py</code> <pre><code>def quat_headingAngle(q: jax.Array):\n    head, incl = quat_project(q, jnp.array([0.0, 0, 1]))\n    return quat_angle(head)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.safe.safe_norm","title":"<code>safe_norm(x)</code>","text":"<p>Grad-safe for x=0.0. Norm along last axis.</p> Source code in <code>x_xy/maths/safe.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(k)-&gt;(1)\")\ndef safe_norm(x):\n\"\"\"Grad-safe for x=0.0. Norm along last axis.\"\"\"\n    assert x.ndim == 1\n\n    is_zero = jnp.all(jnp.isclose(x, 0.0), axis=-1, keepdims=False)\n    return jax.lax.cond(\n        is_zero,\n        lambda x: jnp.array([0.0], dtype=x.dtype),\n        lambda x: jnp.linalg.norm(x, keepdims=True),\n        x,\n    )\n</code></pre>"},{"location":"api/maths/#x_xy.maths.safe.safe_normalize","title":"<code>safe_normalize(x)</code>","text":"<p>Execution- and Grad-safe for x=0.0. Normalizes along last axis.</p> Source code in <code>x_xy/maths/safe.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(k)-&gt;(k)\")\ndef safe_normalize(x):\n\"\"\"Execution- and Grad-safe for x=0.0. Normalizes along last axis.\"\"\"\n    assert x.ndim == 1\n\n    is_zero = jnp.allclose(x, 0.0)\n    return jax.lax.cond(\n        is_zero,\n        lambda x: jnp.zeros_like(x),\n        lambda x: x / jnp.where(is_zero, 1.0, safe_norm(x)),\n        x,\n    )\n</code></pre>"},{"location":"api/maths/#x_xy.maths.safe.safe_arccos","title":"<code>safe_arccos(x)</code>","text":"<p>Trigonometric inverse cosine, element-wise with safety clipping in grad.</p> Source code in <code>x_xy/maths/safe.py</code> <pre><code>@custom_jvp\ndef safe_arccos(x: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Trigonometric inverse cosine, element-wise with safety clipping in grad.\"\"\"\n    return jnp.arccos(x)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.safe.safe_arcsin","title":"<code>safe_arcsin(x)</code>","text":"<p>Trigonometric inverse sine, element-wise with safety clipping in grad.</p> Source code in <code>x_xy/maths/safe.py</code> <pre><code>@custom_jvp\ndef safe_arcsin(x: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Trigonometric inverse sine, element-wise with safety clipping in grad.\"\"\"\n    return jnp.arcsin(x)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.basic.wrap_to_pi","title":"<code>wrap_to_pi(phi)</code>","text":"<p>Wraps angle <code>phi</code> (radians) to interval [-pi, pi].</p> Source code in <code>x_xy/maths/basic.py</code> <pre><code>def wrap_to_pi(phi):\n    \"Wraps angle `phi` (radians) to interval [-pi, pi].\"\n    return (phi + jnp.pi) % (2 * jnp.pi) - jnp.pi\n</code></pre>"},{"location":"api/maths/#x_xy.maths.quat.ensure_positive_w","title":"<code>ensure_positive_w(q)</code>","text":"Source code in <code>x_xy/maths/quat.py</code> <pre><code>@partial(jnp.vectorize, signature=\"(4)-&gt;(4)\")\ndef ensure_positive_w(q):\n    return jnp.where(q[0] &lt; 0, -q, q)\n</code></pre>"},{"location":"api/maths/#x_xy.maths.basic.unit_vectors","title":"<code>unit_vectors(xyz)</code>","text":"Source code in <code>x_xy/maths/basic.py</code> <pre><code>def unit_vectors(xyz: int | str):\n    if isinstance(xyz, str):\n        xyz = {\"x\": 0, \"y\": 1, \"z\": 2}[xyz]\n    return [x_unit_vector, y_unit_vector, z_unit_vector][xyz]\n</code></pre>"},{"location":"api/maths/#x_xy.maths.basic.x_unit_vector","title":"<code>x_unit_vector = jnp.array([1.0, 0, 0])</code>  <code>module-attribute</code>","text":""},{"location":"api/maths/#x_xy.maths.basic.y_unit_vector","title":"<code>y_unit_vector = jnp.array([0.0, 1, 0])</code>  <code>module-attribute</code>","text":""},{"location":"api/maths/#x_xy.maths.basic.z_unit_vector","title":"<code>z_unit_vector = jnp.array([0.0, 0, 1])</code>  <code>module-attribute</code>","text":""},{"location":"api/x_xy/","title":"x_xy","text":""},{"location":"api/x_xy/#x_xy.base.System","title":"<code>System</code>","text":"Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass System(_Base):\n    link_parents: list[int] = struct.field(False)\n    links: Link\n    link_types: list[str] = struct.field(False)\n    link_damping: jax.Array\n    link_armature: jax.Array\n    link_spring_stiffness: jax.Array\n    link_spring_zeropoint: jax.Array\n    # simulation timestep size\n    dt: float = struct.field(False)\n    # geometries in the system\n    geoms: list[Geometry]\n    # root / base acceleration offset\n    gravity: jax.Array = struct.field(default_factory=lambda: jnp.array([0, 0, -9.81]))\n\n    integration_method: str = struct.field(\n        False, default_factory=lambda: \"semi_implicit_euler\"\n    )\n    mass_mat_iters: int = struct.field(False, default_factory=lambda: 0)\n\n    link_names: list[str] = struct.field(False, default_factory=lambda: [])\n\n    model_name: Optional[str] = struct.field(False, default_factory=lambda: None)\n\n    def num_links(self) -&gt; int:\n        return len(self.link_parents)\n\n    def q_size(self) -&gt; int:\n        return sum([Q_WIDTHS[typ] for typ in self.link_types])\n\n    def qd_size(self) -&gt; int:\n        return sum([QD_WIDTHS[typ] for typ in self.link_types])\n\n    def name_to_idx(self, name: str) -&gt; int:\n        return self.link_names.index(name)\n\n    def idx_to_name(self, idx: int) -&gt; str:\n        assert idx &gt;= 0, \"Worldbody index has no name.\"\n        return self.link_names[idx]\n\n    def idx_map(self, type: str) -&gt; dict:\n        \"type: is either `l` or `q` or `d`\"\n        from x_xy import scan_sys\n\n        dict_int_slices = {}\n\n        def f(_, idx_map, name: str, link_idx: int):\n            dict_int_slices[name] = idx_map[type](link_idx)\n\n        scan_sys(self, f, \"ll\", self.link_names, list(range(self.num_links())))\n\n        return dict_int_slices\n\n    def parent_name(self, name: str) -&gt; str:\n        return self.idx_to_name(self.link_parents[self.name_to_idx(name)])\n\n    def add_prefix(self, prefix: str = \"\") -&gt; \"System\":\n        return self.replace(link_names=[prefix + name for name in self.link_names])\n\n    def change_model_name(self, name: str) -&gt; \"System\":\n        return self.replace(model_name=name)\n\n    def rename_link(self, old_name: str, new_name) -&gt; \"System\":\n        old_idx = self.name_to_idx(old_name)\n        new_link_names = self.link_names.copy()\n        new_link_names[old_idx] = new_name\n        return self.replace(link_names=new_link_names)\n\n    def add_prefix_suffix(\n        self, prefix: Optional[str] = None, suffix: Optional[str] = None\n    ) -&gt; \"System\":\n        if prefix is None:\n            prefix = \"\"\n        if suffix is None:\n            suffix = \"\"\n        new_link_names = [prefix + name + suffix for name in self.link_names]\n        return self.replace(link_names=new_link_names)\n\n    @staticmethod\n    def deep_equal(a, b):\n        if type(a) is not type(b):\n            return False\n        if isinstance(a, _Base):\n            return System.deep_equal(a.__dict__, b.__dict__)\n        if isinstance(a, dict):\n            if a.keys() != b.keys():\n                return False\n            return all(System.deep_equal(a[k], b[k]) for k in a.keys())\n        if isinstance(a, (list, tuple)):\n            if len(a) != len(b):\n                return False\n            return all(System.deep_equal(a[i], b[i]) for i in range(len(a)))\n        if isinstance(a, (np.ndarray, jnp.ndarray, jax.Array)):\n            return jnp.array_equal(a, b)\n        return a == b\n\n    def _replace_free_with_cor(self) -&gt; \"System\":\n        # check that\n        # - all free joints connect to -1\n        # - all joints connecting to -1 are free joints\n        for i, p in enumerate(self.link_parents):\n            link_type = self.link_types[i]\n            if (p == -1 and link_type != \"free\") or (link_type == \"free\" and p != -1):\n                raise InvalidSystemError(\n                    f\"link={self.idx_to_name(i)}, parent={self.idx_to_name(p)},\"\n                    f\" joint={link_type}\"\n                )\n\n        def logic_replace_free_with_cor(name, olt, ola, old, ols, olz):\n            # by default new is equal to old\n            nlt, nla, nld, nls, nlz = olt, ola, old, ols, olz\n\n            # old link type == free\n            if olt == \"free\":\n                # cor joint is (free, p3d) stacked\n                nlt = \"cor\"\n                # entries of old armature are 3*ang (spherical), 3*pos (p3d)\n                nla = jnp.concatenate((ola, ola[3:]))\n                nld = jnp.concatenate((old, old[3:]))\n                nls = jnp.concatenate((ols, ols[3:]))\n                nlz = jnp.concatenate((olz, olz[4:]))\n\n            return nlt, nla, nld, nls, nlz\n\n        return _update_sys_if_replace_joint_type(self, logic_replace_free_with_cor)\n\n    def freeze(self, name: str | list[str]):\n        if isinstance(name, list):\n            sys = self\n            for n in name:\n                sys = sys.freeze(n)\n            return sys\n\n        def logic_freeze(link_name, olt, ola, old, ols, olz):\n            nlt, nla, nld, nls, nlz = olt, ola, old, ols, olz\n\n            if link_name == name:\n                nlt = \"frozen\"\n                nla = nld = nls = nlz = jnp.array([])\n\n            return nlt, nla, nld, nls, nlz\n\n        return _update_sys_if_replace_joint_type(self, logic_freeze)\n</code></pre>"},{"location":"api/x_xy/#x_xy.base.System.idx_map","title":"<code>idx_map(type)</code>","text":"<p>type: is either <code>l</code> or <code>q</code> or <code>d</code></p> Source code in <code>x_xy/base.py</code> <pre><code>def idx_map(self, type: str) -&gt; dict:\n    \"type: is either `l` or `q` or `d`\"\n    from x_xy import scan_sys\n\n    dict_int_slices = {}\n\n    def f(_, idx_map, name: str, link_idx: int):\n        dict_int_slices[name] = idx_map[type](link_idx)\n\n    scan_sys(self, f, \"ll\", self.link_names, list(range(self.num_links())))\n\n    return dict_int_slices\n</code></pre>"},{"location":"api/x_xy/#x_xy.io.xml.from_xml.load_sys_from_str","title":"<code>load_sys_from_str(xml_str)</code>","text":"<p>Load system from string input.</p> <p>Parameters:</p> Name Type Description Default <code>xml_str</code> <code>str</code> <p>XML Presentation of the system.</p> required <p>Returns:</p> Type Description <code>System</code> <p>base.System: Loaded system.</p> Source code in <code>x_xy/io/xml/from_xml.py</code> <pre><code>def load_sys_from_str(xml_str: str) -&gt; base.System:\n\"\"\"Load system from string input.\n\n    Args:\n        xml_str (str): XML Presentation of the system.\n\n    Returns:\n        base.System: Loaded system.\n    \"\"\"\n    xml_tree = ElementTree.fromstring(xml_str)\n    worldbody = _initial_setup(xml_tree)\n\n    # check that &lt;x_xy model=\"...\"&gt; syntax is correct\n    assert xml_tree.tag == \"x_xy\", (\n        \"The root element in the xml of a x_xy model must be `x_xy`.\"\n        \" Look up the examples under  x_xy/io/examples/*.xml to get started\"\n    )\n    model_name = xml_tree.attrib.get(\"model\", None)\n\n    # default options\n    options = {\"gravity\": DEFAULT_GRAVITY, \"dt\": DEFAULT_DT}\n    options_xml = _find_assert_unique(xml_tree, \"options\")\n    options.update({} if options_xml is None else options_xml.attrib)\n\n    # convert scalar array to float\n    # if this is uncommented, it leads to `ConcretizationTypeError`s\n    # options[\"dt\"] = float(options[\"dt\"])\n\n    links = {}\n    link_parents = {}\n    link_names = {}\n    link_types = {}\n    geoms = {}\n    armatures = {}\n    dampings = {}\n    spring_stiffnesses = {}\n    spring_zeropoints = {}\n    global_link_idx = -1\n\n    def process_body(body: ElementTree, parent: int):\n        nonlocal global_link_idx\n        global_link_idx += 1\n        current_link_idx = global_link_idx\n        current_link_typ = body.attrib[\"joint\"]\n\n        link_parents[current_link_idx] = parent\n        link_types[current_link_idx] = current_link_typ\n        link_names[current_link_idx] = body.attrib[\"name\"]\n\n        transform = abstract.AbsTrans.from_xml(body.attrib)\n        pos_min, pos_max = abstract.AbsPosMinMax.from_xml(body.attrib, transform.pos)\n        links[current_link_idx] = base.Link(transform, pos_min, pos_max)\n\n        q_size = base.Q_WIDTHS[current_link_typ]\n        qd_size = base.QD_WIDTHS[current_link_typ]\n\n        (\n            damping,\n            armature,\n            stiffness,\n            zeropoint,\n        ) = abstract.AbsDampArmaStiffZero.from_xml(\n            body.attrib, q_size, qd_size, current_link_typ\n        )\n\n        armatures[current_link_idx] = armature\n        dampings[current_link_idx] = damping\n        spring_stiffnesses[current_link_idx] = stiffness\n        spring_zeropoints[current_link_idx] = zeropoint\n\n        geoms[current_link_idx] = _extract_geoms_from_body_xml(body, current_link_idx)\n\n        for subbodies in body.findall(\"body\"):\n            process_body(subbodies, current_link_idx)\n\n        return\n\n    for body in worldbody.findall(\"body\"):\n        process_body(body, -1)\n\n    def assert_order_then_to_list(d: dict) -&gt; list:\n        assert [i for i in d] == list(range(len(d)))\n        return [d[i] for i in d]\n\n    links = assert_order_then_to_list(links)\n    links = links[0].batch(*links[1:])\n    dampings = jnp.concatenate(assert_order_then_to_list(dampings))\n    armatures = jnp.concatenate(assert_order_then_to_list(armatures))\n    spring_stiffnesses = jnp.concatenate(assert_order_then_to_list(spring_stiffnesses))\n    spring_zeropoints = jnp.concatenate(assert_order_then_to_list(spring_zeropoints))\n\n    # add all geoms directly connected to worldbody\n    flat_geoms = [geom for geoms in assert_order_then_to_list(geoms) for geom in geoms]\n    flat_geoms += _extract_geoms_from_body_xml(worldbody, -1)\n\n    sys = base.System(\n        link_parents=assert_order_then_to_list(link_parents),\n        links=links,\n        link_types=assert_order_then_to_list(link_types),\n        link_damping=dampings,\n        link_armature=armatures,\n        link_spring_stiffness=spring_stiffnesses,\n        link_spring_zeropoint=spring_zeropoints,\n        dt=float(options[\"dt\"]),\n        geoms=flat_geoms,\n        gravity=options[\"gravity\"],\n        link_names=assert_order_then_to_list(link_names),\n        model_name=model_name,\n    )\n\n    return parse_system(sys)\n</code></pre>"},{"location":"api/x_xy/#x_xy.io.xml.from_xml.load_sys_from_xml","title":"<code>load_sys_from_xml(xml_path)</code>","text":"Source code in <code>x_xy/io/xml/from_xml.py</code> <pre><code>def load_sys_from_xml(xml_path: str):\n    return load_sys_from_str(_load_xml(xml_path))\n</code></pre>"},{"location":"api/x_xy/#x_xy.io.xml.to_xml.save_sys_to_str","title":"<code>save_sys_to_str(sys)</code>","text":"Source code in <code>x_xy/io/xml/to_xml.py</code> <pre><code>def save_sys_to_str(sys: base.System) -&gt; str:\n    if not jnp.all(sys.links.joint_params == 0.0):\n        warnings.warn(\n            \"The system has `sys.links.joint_params` unequal to the default value (of\"\n            \" zeros). This will not be preserved in the xml.\"\n        )\n    global_index_map = {qd: sys.idx_map(qd) for qd in [\"q\", \"d\"]}\n\n    # Create root element\n    x_xy = Element(\"x_xy\")\n    x_xy.set(\"model\", sys.model_name)\n\n    options = SubElement(x_xy, \"options\")\n    options.set(\"dt\", str(sys.dt))\n    options.set(\"gravity\", _to_str(sys.gravity))\n\n    # Create worldbody\n    worldbody = SubElement(x_xy, \"worldbody\")\n\n    def process_link(link_idx: int, parent_elem: Element):\n        link = sys.links[link_idx]\n        link_typ = sys.link_types[link_idx]\n        link_name = sys.link_names[link_idx]\n\n        # Create body element\n        body = SubElement(parent_elem, \"body\")\n        body.set(\"joint\", link_typ)\n        body.set(\"name\", link_name)\n\n        # Set attributes\n        abstract.AbsTrans.to_xml(body, link.transform1)\n        abstract.AbsPosMinMax.to_xml(body, link.pos_min, link.pos_max)\n        abstract.AbsDampArmaStiffZero.to_xml(\n            body,\n            sys.link_damping[global_index_map[\"d\"][link_name]],\n            sys.link_armature[global_index_map[\"d\"][link_name]],\n            sys.link_spring_stiffness[global_index_map[\"d\"][link_name]],\n            sys.link_spring_zeropoint[global_index_map[\"q\"][link_name]],\n            base.Q_WIDTHS[link_typ],\n            base.QD_WIDTHS[link_typ],\n            link_typ,\n        )\n\n        # Add geometry elements\n        geoms = sys.geoms\n        for geom in geoms:\n            if geom.link_idx == link_idx:\n                geom_elem = SubElement(body, \"geom\")\n                abstract_class = abstract.geometry_to_abstract[type(geom)]\n                abstract_class.to_xml(geom_elem, geom)\n\n        # Recursively process child links\n        for child_idx, parent_idx in enumerate(sys.link_parents):\n            if parent_idx == link_idx:\n                process_link(child_idx, body)\n\n    for root_link_idx, parent_idx in enumerate(sys.link_parents):\n        if parent_idx == -1:\n            process_link(root_link_idx, worldbody)\n\n    # Pretty print xml\n    xml_str = parseString(tostring(x_xy)).toprettyxml(indent=\"  \")\n    return xml_str\n</code></pre>"},{"location":"api/x_xy/#x_xy.io.xml.to_xml.save_sys_to_xml","title":"<code>save_sys_to_xml(sys, xml_path)</code>","text":"Source code in <code>x_xy/io/xml/to_xml.py</code> <pre><code>def save_sys_to_xml(sys: base.System, xml_path: str) -&gt; None:\n    xml_str = save_sys_to_str(sys)\n    with open(xml_path, \"w\") as f:\n        f.write(xml_str)\n</code></pre>"},{"location":"api/x_xy/#x_xy.io.examples.load_example","title":"<code>load_example(name)</code>","text":"<p>Load example from examples dir.</p> Source code in <code>x_xy/io/examples.py</code> <pre><code>def load_example(name: str):\n    \"Load example from examples dir.\"\n\n    xml_path = parse_path(EXAMPLES_DIR, name, extension=\"xml\")\n    return load_sys_from_xml(xml_path)\n</code></pre>"},{"location":"api/x_xy/#x_xy.scan.scan_sys","title":"<code>scan_sys(sys, f, in_types, *args, reverse=False)</code>","text":"<p>Scan <code>f</code> along each link in system whilst carrying along state.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>description</p> required <code>f</code> <code>Callable[..., Y]</code> <p>f(y: Y, *args) -&gt; y</p> required <code>in_types</code> <code>str</code> <p>string specifying the type of each input arg: 'l' is an input to be split according to link ranges 'q' is an input to be split according to q ranges 'd' is an input to be split according to qd ranges</p> required <code>args</code> <p>Arguments passed to <code>f</code>, and split to match the link.</p> <code>()</code> <code>reverse</code> <code>bool</code> <p>If <code>true</code> from leaves to root. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ys</code> <p>Stacked output y of f.</p> Source code in <code>x_xy/scan.py</code> <pre><code>def scan_sys(\n    sys: base.System, f: Callable, in_types: str, *args, reverse: bool = False\n):\n\"\"\"Scan `f` along each link in system whilst carrying along state.\n\n    Args:\n        sys (base.System): _description_\n        f (Callable[..., Y]): f(y: Y, *args) -&gt; y\n        in_types: string specifying the type of each input arg:\n            'l' is an input to be split according to link ranges\n            'q' is an input to be split according to q ranges\n            'd' is an input to be split according to qd ranges\n        args: Arguments passed to `f`, and split to match the link.\n        reverse (bool, optional): If `true` from leaves to root. Defaults to False.\n\n    Returns:\n        ys: Stacked output y of f.\n    \"\"\"\n\n    assert len(args) == len(in_types)\n\n    order = range(sys.num_links())\n    q_idx, qd_idx = 0, 0\n    q_idxs, qd_idxs = {}, {}\n    for link_idx, link_type in zip(order, sys.link_types):\n        # build map from\n        # link-idx -&gt; q_idx\n        # link-idx -&gt; qd_idx\n        q_idxs[link_idx] = slice(q_idx, q_idx + base.Q_WIDTHS[link_type])\n        qd_idxs[link_idx] = slice(qd_idx, qd_idx + base.QD_WIDTHS[link_type])\n        q_idx += base.Q_WIDTHS[link_type]\n        qd_idx += base.QD_WIDTHS[link_type]\n\n    idx_map = {\n        \"l\": lambda link_idx: link_idx,\n        \"q\": lambda link_idx: q_idxs[link_idx],\n        \"d\": lambda link_idx: qd_idxs[link_idx],\n    }\n\n    if reverse:\n        order = range(sys.num_links() - 1, -1, -1)\n\n    y, ys = None, []\n    for link_idx in order:\n        args_link = [arg[idx_map[t](link_idx)] for arg, t in zip(args, in_types)]\n        y = f(y, idx_map, *args_link)\n        ys.append(y)\n\n    if reverse:\n        ys.reverse()\n\n    ys = tree_utils.tree_batch(ys, backend=\"jax\")\n    return ys\n</code></pre>"},{"location":"api/x_xy/#x_xy.base.State","title":"<code>State</code>","text":"<p>The static and dynamic state of a system in minimal and maximal coordinates. Use <code>.create()</code> to create this object.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Array</code> <p>System state in minimal coordinates (equals <code>sys.q_size()</code>)</p> required <code>qd</code> <code>Array</code> <p>System velocity in minimal coordinates (equals <code>sys.qd_size()</code>)</p> required <code>x</code> <p>(Transform): Maximal coordinates of all links. From epsilon-to-link.</p> required <code>mass_mat_inv</code> <code>Array</code> <p>Inverse of the mass matrix. Internal usage.</p> required Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass State(_Base):\n\"\"\"The static and dynamic state of a system in minimal and maximal coordinates.\n    Use `.create()` to create this object.\n\n    Args:\n        q (jax.Array): System state in minimal coordinates (equals `sys.q_size()`)\n        qd (jax.Array): System velocity in minimal coordinates (equals `sys.qd_size()`)\n        x: (Transform): Maximal coordinates of all links. From epsilon-to-link.\n        mass_mat_inv (jax.Array): Inverse of the mass matrix. Internal usage.\n    \"\"\"\n\n    q: jax.Array\n    qd: jax.Array\n    x: Transform\n    mass_mat_inv: jax.Array\n\n    @classmethod\n    def create(\n        cls, sys: System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None\n    ):\n\"\"\"Create state of system.\n\n        Args:\n            sys (System): The system for which to create a state.\n            q (jax.Array, optional): The joint values of the system. Defaults to None.\n            Which then defaults to zeros.\n            qd (jax.Array, optional): The joint velocities of the system.\n            Defaults to None. Which then defaults to zeros.\n\n        Returns:\n            (State): Create State object.\n        \"\"\"\n        # to avoid circular imports\n        from x_xy import scan_sys\n\n        if q is None:\n            q = jnp.zeros((sys.q_size(),))\n\n            # free, cor, spherical joints are not zeros but have unit quaternions\n            def replace_by_unit_quat(_, idx_map, link_typ, link_idx):\n                nonlocal q\n\n                if link_typ in [\"free\", \"cor\", \"spherical\"]:\n                    q_idxs_link = idx_map[\"q\"](link_idx)\n                    q = q.at[q_idxs_link.start].set(1.0)\n\n            scan_sys(\n                sys,\n                replace_by_unit_quat,\n                \"ll\",\n                sys.link_types,\n                list(range(sys.num_links())),\n            )\n\n        if qd is None:\n            qd = jnp.zeros((sys.qd_size(),))\n        x = Transform.zero((sys.num_links(),))\n        return cls(q, qd, x, jnp.diag(jnp.ones((sys.qd_size(),))))\n</code></pre>"},{"location":"api/x_xy/#x_xy.base.State.create","title":"<code>create(sys, q=None, qd=None)</code>  <code>classmethod</code>","text":"<p>Create state of system.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>The system for which to create a state.</p> required <code>q</code> <code>Array</code> <p>The joint values of the system. Defaults to None.</p> <code>None</code> <code>qd</code> <code>Array</code> <p>The joint velocities of the system.</p> <code>None</code> <p>Returns:</p> Type Description <code>State</code> <p>Create State object.</p> Source code in <code>x_xy/base.py</code> <pre><code>@classmethod\ndef create(\n    cls, sys: System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None\n):\n\"\"\"Create state of system.\n\n    Args:\n        sys (System): The system for which to create a state.\n        q (jax.Array, optional): The joint values of the system. Defaults to None.\n        Which then defaults to zeros.\n        qd (jax.Array, optional): The joint velocities of the system.\n        Defaults to None. Which then defaults to zeros.\n\n    Returns:\n        (State): Create State object.\n    \"\"\"\n    # to avoid circular imports\n    from x_xy import scan_sys\n\n    if q is None:\n        q = jnp.zeros((sys.q_size(),))\n\n        # free, cor, spherical joints are not zeros but have unit quaternions\n        def replace_by_unit_quat(_, idx_map, link_typ, link_idx):\n            nonlocal q\n\n            if link_typ in [\"free\", \"cor\", \"spherical\"]:\n                q_idxs_link = idx_map[\"q\"](link_idx)\n                q = q.at[q_idxs_link.start].set(1.0)\n\n        scan_sys(\n            sys,\n            replace_by_unit_quat,\n            \"ll\",\n            sys.link_types,\n            list(range(sys.num_links())),\n        )\n\n    if qd is None:\n        qd = jnp.zeros((sys.qd_size(),))\n    x = Transform.zero((sys.num_links(),))\n    return cls(q, qd, x, jnp.diag(jnp.ones((sys.qd_size(),))))\n</code></pre>"},{"location":"api/x_xy/#x_xy.base.Transform","title":"<code>Transform</code>","text":"<p>Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B, where B is located relative to A at <code>pos</code> in frame A and <code>rot</code> is the relative quaternion from A to B.</p> Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass Transform(_Base):\n\"\"\"Represents the Transformation from Pl\u00fccker A to Pl\u00fccker B,\n    where B is located relative to A at `pos` in frame A and `rot` is the\n    relative quaternion from A to B.\"\"\"\n\n    pos: Vector\n    rot: Quaternion\n\n    @classmethod\n    def create(cls, pos=None, rot=None):\n        assert not (pos is None and rot is None), \"One must be given.\"\n        shape_rot = rot.shape[:-1] if rot is not None else ()\n        shape_pos = pos.shape[:-1] if pos is not None else ()\n\n        if pos is None:\n            pos = jnp.zeros(shape_rot + (3,))\n        if rot is None:\n            rot = jnp.array([1.0, 0, 0, 0])\n            rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape_pos + (1,))\n\n        assert pos.shape[:-1] == rot.shape[:-1]\n\n        return Transform(pos, rot)\n\n    @classmethod\n    def zero(cls, shape=()) -&gt; \"Transform\":\n\"\"\"Returns a zero transform with a batch shape.\"\"\"\n        pos = jnp.zeros(shape + (3,))\n        rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape + (1,))\n        return Transform(pos, rot)\n\n    def as_matrix(self) -&gt; jax.Array:\n        E = maths.quat_to_3x3(self.rot)\n        return maths.spatial.quadrants(aa=E, bb=E) @ maths.spatial.xlt(self.pos)\n</code></pre>"},{"location":"api/x_xy/#x_xy.base.Transform.zero","title":"<code>zero(shape=())</code>  <code>classmethod</code>","text":"<p>Returns a zero transform with a batch shape.</p> Source code in <code>x_xy/base.py</code> <pre><code>@classmethod\ndef zero(cls, shape=()) -&gt; \"Transform\":\n\"\"\"Returns a zero transform with a batch shape.\"\"\"\n    pos = jnp.zeros(shape + (3,))\n    rot = jnp.tile(jnp.array([1.0, 0.0, 0.0, 0.0]), shape + (1,))\n    return Transform(pos, rot)\n</code></pre>"},{"location":"api/x_xy/#x_xy.algebra.transform.transform_mul","title":"<code>transform_mul(t2, t1)</code>","text":"<p>Chains two transformations <code>t1</code> and <code>t2</code>. t1: Pl\u00fccker A -&gt; Pl\u00fccker B, t2: Pl\u00fccker B -&gt; Pl\u00fccker C =&gt; Returns: Pl\u00fccker A -&gt; Pl\u00fccker C</p> Source code in <code>x_xy/algebra/transform.py</code> <pre><code>def transform_mul(t2: base.Transform, t1: base.Transform) -&gt; base.Transform:\n\"\"\"Chains two transformations `t1` and `t2`.\n    t1: Pl\u00fccker A -&gt; Pl\u00fccker B,\n    t2: Pl\u00fccker B -&gt; Pl\u00fccker C\n    =&gt;\n    Returns: Pl\u00fccker A -&gt; Pl\u00fccker C\n    \"\"\"\n    pos = t1.pos + maths.rotate(t2.pos, maths.quat_inv(t1.rot))\n    rot = maths.quat_mul(t2.rot, t1.rot)\n    return base.Transform(pos, rot)\n</code></pre>"},{"location":"api/x_xy/#x_xy.algebra.transform.transform_inv","title":"<code>transform_inv(t)</code>","text":"<p>Inverts the transform. A -&gt; B becomes B -&gt; A</p> Source code in <code>x_xy/algebra/transform.py</code> <pre><code>def transform_inv(t: base.Transform) -&gt; base.Transform:\n    \"Inverts the transform. A -&gt; B becomes B -&gt; A\"\n    pos = maths.rotate(-t.pos, t.rot)\n    rot = maths.quat_inv(t.rot)\n    return base.Transform(pos, rot)\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.step","title":"<code>step(sys, state, taus=None, n_substeps=1)</code>","text":"Source code in <code>x_xy/algorithms/dynamics.py</code> <pre><code>def step(\n    sys: base.System,\n    state: base.State,\n    taus: Optional[jax.Array] = None,\n    n_substeps: int = 1,\n) -&gt; base.State:\n    assert sys.q_size() == state.q.size\n    if taus is None:\n        taus = jnp.zeros_like(state.qd)\n    assert sys.qd_size() == state.qd.size == taus.size\n    assert (\n        sys.integration_method.lower() == \"semi_implicit_euler\"\n    ), \"Currently, nothing else then `semi_implicit_euler` implemented.\"\n\n    sys = sys.replace(dt=sys.dt / n_substeps)\n\n    for _ in range(n_substeps):\n        # update kinematics before stepping; this means that the `x` in `state`\n        # will lag one step behind but otherwise we would have to return\n        # the system object which would be awkward\n        sys, state = forward_kinematics(sys, state)\n        state = _integration_methods[sys.integration_method.lower()](sys, state, taus)\n\n    return state\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.forward_kinematics","title":"<code>forward_kinematics(sys, state)</code>","text":"<p>Perform forward kinematics in system. - Updates <code>transform</code> and <code>transform2</code> in <code>sys</code> - Updates <code>x</code> in <code>state</code></p> Source code in <code>x_xy/algorithms/kinematics.py</code> <pre><code>def forward_kinematics(\n    sys: base.System, state: base.State\n) -&gt; Tuple[base.System, base.State]:\n\"\"\"Perform forward kinematics in system.\n    - Updates `transform` and `transform2` in `sys`\n    - Updates `x` in `state`\n    \"\"\"\n    x, sys = forward_kinematics_transforms(sys, state.q)\n    state = state.replace(x=x)\n    return sys, state\n</code></pre>"},{"location":"api/x_xy/#x_xy.rendering.render","title":"<code>render(sys, xs=None, camera=None, show_pbar=True, backend='mujoco', **scene_kwargs)</code>","text":"<p>Render frames from system and trajectory of maximal coordinates <code>xs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System to render.</p> required <code>xs</code> <code>Transform | list[Transform]</code> <p>Single or time-series</p> <code>None</code> <code>show_pbar</code> <code>bool</code> <p>Whether or not to show a progress bar.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ndarray]</code> <p>list[np.ndarray]: Stacked rendered frames. Length == len(xs).</p> Source code in <code>x_xy/rendering/base_render.py</code> <pre><code>def render(\n    sys: base.System,\n    xs: Optional[base.Transform | list[base.Transform]] = None,\n    camera: Optional[str] = None,\n    show_pbar: bool = True,\n    backend: str = \"mujoco\",\n    **scene_kwargs,\n) -&gt; list[np.ndarray]:\n\"\"\"Render frames from system and trajectory of maximal coordinates `xs`.\n\n    Args:\n        sys (base.System): System to render.\n        xs (base.Transform | list[base.Transform]): Single or time-series\n        of maximal coordinates `xs`.\n        show_pbar (bool, optional): Whether or not to show a progress bar.\n        Defaults to True.\n\n    Returns:\n        list[np.ndarray]: Stacked rendered frames. Length == len(xs).\n    \"\"\"\n    if backend == \"mujoco\":\n        from x_xy.rendering.mujoco_render import MujocoScene\n\n        scene = MujocoScene(**scene_kwargs)\n    elif backend == \"vispy\":\n        import vispy\n\n        if \"vispy_backend\" in scene_kwargs:\n            vispy_backend = scene_kwargs.pop(\"vispy_backend\")\n        else:\n            vispy_backend = \"pyqt6\"\n        vispy.use(vispy_backend)\n\n        from x_xy.rendering.vispy_render import VispyScene\n\n        scene = VispyScene(**scene_kwargs)\n    else:\n        raise NotImplementedError\n\n    # mujoco does not implement the xyz Geometry; instead replace it with\n    # three capsule Geometries\n    geoms = sys.geoms\n    if backend == \"mujoco\":\n        geoms = _replace_xyz_geoms(geoms)\n\n    # convert all colors to rgbas\n    geoms_rgba = [_color_to_rgba(geom) for geom in geoms]\n\n    if xs is None:\n        xs = forward_kinematics(sys, base.State.create(sys))[1].x\n\n    xs = to_list(xs)\n\n    n_links = sys.num_links()\n\n    def data_check(x):\n        assert (\n            x.pos.ndim == x.rot.ndim == 2\n        ), f\"Expected shape = (n_links, 3/4). Got pos.shape{x.pos.shape}, \"\n        \"rot.shape={x.rot.shape}\"\n        assert (\n            x.pos.shape[0] == x.rot.shape[0] == n_links\n        ), \"Number of links does not match\"\n\n    for x in xs:\n        data_check(x)\n\n    scene.init(geoms_rgba)\n\n    frames = []\n    for x in tqdm.tqdm(xs, \"Rendering frames..\", disable=not show_pbar):\n        scene.update(x)\n        frames.append(scene.render(camera=camera))\n\n    return frames\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.generator.base.build_generator","title":"<code>build_generator(sys, config=RCMG_Config(), setup_fn=lambda , : sys, finalize_fn=lambda , , , : (q, x), randomize_positions=False)</code>","text":"Source code in <code>x_xy/algorithms/generator/base.py</code> <pre><code>def build_generator(\n    sys: base.System,\n    config: RCMG_Config = RCMG_Config(),\n    setup_fn: SETUP_FN = lambda key, sys: sys,\n    finalize_fn: FINALIZE_FN = lambda key, q, x, sys: (q, x),\n    randomize_positions: bool = False,\n) -&gt; Generator:\n    assert config.is_feasible()\n\n    return GeneratorPipe(\n        GeneratorTrafoSetupFn(setup_fn),\n        GeneratorTrafoRandomizePositions()\n        if randomize_positions\n        else (lambda gen: gen),\n        GeneratorTrafoFinalizeFn(finalize_fn),\n        GeneratorTrafoRemoveInputExtras(sys),\n        GeneratorTrafoRemoveOutputExtras(),\n    )(config)\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.jcalc.RCMG_Config","title":"<code>RCMG_Config</code>  <code>dataclass</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>@dataclass\nclass RCMG_Config:\n    T: float = 60.0  # length of random motion\n    t_min: float = 0.05  # min time between two generated angles\n    t_max: float | TimeDependentFloat = 0.30  # max time ..\n\n    dang_min: float | TimeDependentFloat = 0.1  # minimum angular velocity in rad/s\n    dang_max: float | TimeDependentFloat = 3.0  # maximum angular velocity in rad/s\n\n    # minimum angular velocity of euler angles used for `free and spherical joints`\n    dang_min_free_spherical: float | TimeDependentFloat = 0.1\n    dang_max_free_spherical: float | TimeDependentFloat = 3.0\n\n    # max min allowed actual delta values in radians\n    delta_ang_min: float | TimeDependentFloat = 0.0\n    delta_ang_max: float | TimeDependentFloat = 2 * jnp.pi\n    delta_ang_min_free_spherical: float | TimeDependentFloat = 0.0\n    delta_ang_max_free_spherical: float | TimeDependentFloat = 2 * jnp.pi\n\n    dpos_min: float | TimeDependentFloat = 0.001  # speed of translation\n    dpos_max: float | TimeDependentFloat = 0.7\n    pos_min: float | TimeDependentFloat = -2.5\n    pos_max: float | TimeDependentFloat = +2.5\n\n    # used by both `random_angle_*` and `random_pos_*`\n    # only used if `randomized_interpolation` is set\n    cdf_bins_min: int = 5\n    # by default equal to `cdf_bins_min`\n    cdf_bins_max: Optional[int] = None\n\n    # flags\n    randomized_interpolation_angle: bool = False\n    randomized_interpolation_position: bool = False\n    interpolation_method: str = \"cosine\"\n    range_of_motion_hinge: bool = True\n    range_of_motion_hinge_method: str = \"uniform\"\n\n    # initial value of joints\n    ang0_min: float = -jnp.pi\n    ang0_max: float = jnp.pi\n    pos0_min: float = 0.0\n    pos0_max: float = 0.0\n\n    # cor (center of rotation) custom fields\n    cor: bool = False\n    cor_t_min: float = 0.2\n    cor_t_max: float | TimeDependentFloat = 2.0\n    cor_dpos_min: float | TimeDependentFloat = 0.00001\n    cor_dpos_max: float | TimeDependentFloat = 0.5\n    cor_pos_min: float | TimeDependentFloat = -0.4\n    cor_pos_max: float | TimeDependentFloat = 0.4\n\n    def is_feasible(self) -&gt; bool:\n        return _is_feasible_config1(self)\n\n    def to_nomotion_config(self) -&gt; \"RCMG_Config\":\n        kwargs = asdict(self)\n        for key in [\n            \"dang_min\",\n            \"dang_max\",\n            \"delta_ang_min\",\n            \"dang_min_free_spherical\",\n            \"dang_max_free_spherical\",\n            \"delta_ang_min_free_spherical\",\n            \"dpos_min\",\n            \"dpos_max\",\n        ]:\n            kwargs[key] = 0.0\n        nomotion_config = RCMG_Config(**kwargs)\n        assert nomotion_config.is_feasible()\n        return nomotion_config\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.jcalc.concat_configs","title":"<code>concat_configs(configs, boundaries)</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>def concat_configs(configs: list[RCMG_Config], boundaries: list[float]) -&gt; RCMG_Config:\n    assert len(configs) == (\n        len(boundaries) + 1\n    ), \"length of `boundaries` should be one less than length of `configs`\"\n    boundaries = jnp.array(boundaries, dtype=float)\n\n    def new_value(field: str):\n        scalar_options = jnp.array([getattr(c, field) for c in configs])\n\n        def scalar(t):\n            return jax.lax.dynamic_index_in_dim(\n                scalar_options, _find_interval(t, boundaries), keepdims=False\n            )\n\n        return scalar\n\n    hints = get_type_hints(RCMG_Config())\n    attrs = RCMG_Config().__dict__\n    is_time_dependent_field = lambda key: hints[key] == (float | TimeDependentFloat)\n    time_dependent_fields = [key for key in attrs if is_time_dependent_field(key)]\n    time_independent_fields = [key for key in attrs if not is_time_dependent_field(key)]\n\n    for time_dep_field in time_independent_fields:\n        field_values = set([getattr(config, time_dep_field) for config in configs])\n        assert (\n            len(field_values) == 1\n        ), f\"RCMG_Config.{time_dep_field}={field_values}. Should be one unique value..\"\n\n    changes = {field: new_value(field) for field in time_dependent_fields}\n    return replace(configs[0], **changes)\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.generator.batch.batch_generators_lazy","title":"<code>batch_generators_lazy(generators, batchsizes=1, stochastic=False, single_call_opt=False)</code>","text":"<p>Create a large generator by stacking multiple generators lazily. NOTE: If <code>stochastic</code> then <code>batchsizes</code> must be a single integer.</p> Source code in <code>x_xy/algorithms/generator/batch.py</code> <pre><code>def batch_generators_lazy(\n    generators: Generator | list[Generator],\n    batchsizes: int | list[int] = 1,\n    stochastic: bool = False,\n    single_call_opt: bool = False,\n) -&gt; BatchedGenerator:\n\"\"\"Create a large generator by stacking multiple generators lazily.\n    NOTE: If `stochastic` then `batchsizes` must be a single integer.\n    \"\"\"\n\n    if not isinstance(generators, list):\n        # test if generator is already batched, then this is a no-op\n        key = jax.random.PRNGKey(0)\n        X, *_ = generators(key)\n        ndim = tree_utils.tree_ndim(X)\n        if ndim &gt; 2:\n            warnings.warn(f\"`generators` seem already batched. ndim={ndim}\")\n            return generators\n\n    if single_call_opt:\n        warnings.warn(\n            \"Unfortunately, the flag `single_call_opt` seems to always\"\n            \" decrease performance.\"\n        )\n        return _single_call_optimized(\n            generators=generators, batchsizes=batchsizes, stochastic=stochastic\n        )\n\n    generators = utils.to_list(generators)\n\n    if stochastic:\n        assert isinstance(batchsizes, int)\n        bs_total = batchsizes\n        pmap, vmap = utils.distribute_batchsize(bs_total)\n    else:\n        generators, batchsizes = _process_sizes_batchsizes_generators(\n            generators, batchsizes\n        )\n\n        batch_arr_nonstoch = _build_batch_matrix(batchsizes)\n        bs_total = len(batch_arr_nonstoch)\n        pmap, vmap = utils.distribute_batchsize(bs_total)\n        batch_arr_nonstoch = batch_arr_nonstoch.reshape((pmap, vmap))\n\n    pmap_trafo = jax.pmap\n    # single GPU node, then do jit + vmap instead of pmap\n    # this allows e.g. better NAN debugging capabilities\n    if pmap == 1:\n        pmap_trafo = lambda f: jax.jit(jax.vmap(f))\n\n    @pmap_trafo\n    @jax.vmap\n    def _generator(key, which_gen: int):\n        return jax.lax.switch(which_gen, generators, key)\n\n    def generator(key):\n        if stochastic:\n            key, consume = jax.random.split(key)\n            batch_arr = jax.random.choice(\n                consume, jnp.arange(len(generators)), shape=(pmap, vmap)\n            )\n        else:\n            batch_arr = batch_arr_nonstoch\n\n        pmap_vmap_keys = jax.random.split(key, bs_total).reshape((pmap, vmap, 2))\n        data = _generator(pmap_vmap_keys, batch_arr)\n\n        # merge pmap and vmap axis\n        data = utils.merge_batchsize(data, pmap, vmap)\n\n        return data\n\n    return generator\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.generator.batch.batch_generators_eager","title":"<code>batch_generators_eager(generators, sizes, batchsize, shuffle=True, drop_last=True, seed=1, transfer_to_cpu=True)</code>","text":"<p>Eagerly create a large precomputed generator by calling multiple generators and stacking their output.</p> Source code in <code>x_xy/algorithms/generator/batch.py</code> <pre><code>def batch_generators_eager(\n    generators: Generator | list[Generator],\n    sizes: int | list[int],\n    batchsize: int,\n    shuffle: bool = True,\n    drop_last: bool = True,\n    seed: int = 1,\n    transfer_to_cpu: bool = True,\n) -&gt; BatchedGenerator:\n\"\"\"Eagerly create a large precomputed generator by calling multiple generators\n    and stacking their output.\"\"\"\n\n    data = batch_generators_eager_to_list(\n        generators, sizes, seed=seed, transfer_to_cpu=transfer_to_cpu\n    )\n    return batched_generator_from_list(data, batchsize, shuffle, drop_last, seed=seed)\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.generator.batch.batch_generators_eager_to_list","title":"<code>batch_generators_eager_to_list(generators, sizes, seed=1, transfer_to_cpu=True)</code>","text":"<p>Returns list of unbatched sequences.</p> Source code in <code>x_xy/algorithms/generator/batch.py</code> <pre><code>def batch_generators_eager_to_list(\n    generators: Generator | list[Generator],\n    sizes: int | list[int],\n    seed: int = 1,\n    transfer_to_cpu: bool = True,\n) -&gt; list[tree_utils.PyTree]:\n    \"Returns list of unbatched sequences.\"\n    generators, sizes = _process_sizes_batchsizes_generators(generators, sizes)\n\n    key = jax.random.PRNGKey(seed)\n    data = []\n    for gen, size in tqdm(zip(generators, sizes), desc=\"eager data generation\"):\n        key, consume = jax.random.split(key)\n        sample = batch_generators_lazy(gen, size)(consume)\n        if transfer_to_cpu:\n            sample = jax.device_put(sample, jax.devices(\"cpu\")[0])\n        data.extend([jax.tree_map(lambda a: a[i], sample) for i in range(size)])\n    return data\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.generator.batch.batched_generator_from_list","title":"<code>batched_generator_from_list(data, batchsize, shuffle=True, drop_last=True, seed=1)</code>","text":"Source code in <code>x_xy/algorithms/generator/batch.py</code> <pre><code>def batched_generator_from_list(\n    data: list,\n    batchsize: int,\n    shuffle: bool = True,\n    drop_last: bool = True,\n    seed: int = 1,\n) -&gt; BatchedGenerator:\n    assert drop_last, \"Not `drop_last` is currently not implemented.\"\n    assert len(data) &gt;= batchsize\n\n    N, i = len(data) // batchsize, 0\n    random.seed(seed)\n\n    def generator(key: jax.Array):\n        nonlocal i\n        del key\n        if shuffle and i == 0:\n            random.shuffle(data)\n\n        start, stop = i * batchsize, (i + 1) * batchsize\n        batch = tree_batch(data[start:stop], backend=\"jax\")\n        i = (i + 1) % N\n        return batch\n\n    return generator\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.generator.utils.make_normalizer_from_generator","title":"<code>make_normalizer_from_generator(generator, approx_with_large_batchsize=512)</code>","text":"<p>Returns a pure function that normalizes <code>X</code>.</p> Source code in <code>x_xy/algorithms/generator/utils.py</code> <pre><code>def make_normalizer_from_generator(\n    generator: BatchedGenerator, approx_with_large_batchsize: int = 512\n) -&gt; Normalizer:\n    \"Returns a pure function that normalizes `X`.\"\n\n    # probe generator for its batchsize\n    X, _ = generator(KEY)\n    bs = tree_utils.tree_shape(X)\n    assert tree_utils.tree_ndim(X) == 3, \"`generator` must be batched.\"\n\n    # how often do we have to query the generator\n    number_of_gen_calls = math.ceil(approx_with_large_batchsize / bs)\n\n    Xs, key = [], KEY\n    for _ in range(number_of_gen_calls):\n        key, consume = jax.random.split(key)\n        Xs.append(generator(consume)[0])\n    Xs = tree_utils.tree_batch(Xs, True, \"jax\")\n    # permute 0-th axis, since batchsize of generator might be larger than\n    # `approx_with_large_batchsize`, then we would not get a representative\n    # subsample otherwise\n    Xs = jax.tree_map(lambda arr: jax.random.permutation(KEY_PERMUTATION, arr), Xs)\n    Xs = tree_utils.tree_slice(Xs, start=0, slice_size=approx_with_large_batchsize)\n\n    # obtain statistics\n    mean = jax.tree_map(lambda arr: jnp.mean(arr, axis=(0, 1)), Xs)\n    std = jax.tree_map(lambda arr: jnp.std(arr, axis=(0, 1)), Xs)\n\n    eps = 1e-8\n\n    def normalizer(X):\n        return jax.tree_map(lambda a, b, c: (a - b) / (c + eps), X, mean, std)\n\n    return normalizer\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.pd_control","title":"<code>pd_control(P, D)</code>","text":"<p>Computes tau using a PD controller. Returns a pair of (init, apply) functions.</p> <p>NOTE: Gains around ~10_000 are good for spherical joints, everything else ~250-300 works just fine. Damping should be about 2500 for spherical joints, and about 25 for everything else.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>Array</code> <p>jax.Array of P gains. Shape: (sys_init.qd_size())</p> required <code>D</code> <code>Array</code> <p>jax.Array of D gains. Shape: (sys_init.qd_size()) where <code>sys_init</code> is the system that recorded the reference trajectory <code>q_ref</code></p> required <p>Pair of (init, apply) functions</p> Name Type Description <code>init</code> <p>(sys, q_ref) -&gt; controller_state</p> <code>apply</code> <p>(controller_state, sys, state) -&gt; controller_state, tau</p> Example <p>gains = jnp.array([250.0] * sys1.qd_size()) controller = pd_control(gains, gains) q_ref = rcmg(sys1) cs = controller.init(sys1, q_ref) for t in range(1000):     cs, tau = controller.apply(cs, sys2, state)     state = dynamics.step(sys2, state, tau)</p> Source code in <code>x_xy/algorithms/control.py</code> <pre><code>def pd_control(P: jax.Array, D: jax.Array):\n\"\"\"Computes tau using a PD controller. Returns a pair of (init, apply) functions.\n\n    NOTE: Gains around ~10_000 are good for spherical joints, everything else ~250-300\n    works just fine. Damping should be about 2500 for spherical joints, and\n    about 25 for everything else.\n\n    Args:\n        P: jax.Array of P gains. Shape: (sys_init.qd_size())\n        D: jax.Array of D gains. Shape: (sys_init.qd_size()) where `sys_init` is the\n            system that recorded the reference trajectory `q_ref`\n\n    Returns: Pair of (init, apply) functions\n        init: (sys, q_ref) -&gt; controller_state\n        apply: (controller_state, sys, state) -&gt; controller_state, tau\n\n    Example:\n        &gt;&gt;&gt; gains = jnp.array([250.0] * sys1.qd_size())\n        &gt;&gt;&gt; controller = pd_control(gains, gains)\n        &gt;&gt;&gt; q_ref = rcmg(sys1)\n        &gt;&gt;&gt; cs = controller.init(sys1, q_ref)\n        &gt;&gt;&gt; for t in range(1000):\n        &gt;&gt;&gt;     cs, tau = controller.apply(cs, sys2, state)\n        &gt;&gt;&gt;     state = dynamics.step(sys2, state, tau)\n    \"\"\"\n\n    def init(sys: base.System, q_ref: jax.Array) -&gt; dict:\n        assert sys.q_size() == q_ref.shape[1], f\"q_ref.shape = {q_ref.shape}\"\n        assert sys.qd_size() == P.size == D.size\n\n        q_qd_ref = {}\n        P_as_dict = {}\n        D_as_dict = {}\n\n        def f(_, __, q_ref_link, name, typ, P_link, D_link):\n            q_ref_link = q_ref_link.T\n\n            if typ in [\"free\", \"cor\"]:\n                dq = _derivative_quaternion(q_ref_link[:, :4], sys.dt)\n                qd_ref = jnp.hstack((dq, _derivative(q_ref_link[:, 4:], sys.dt)))\n            elif typ == \"spherical\":\n                qd_ref = _derivative_quaternion(q_ref_link, sys.dt)\n            else:\n                qd_ref = _derivative(q_ref_link, sys.dt)\n            q_qd_ref[name] = (q_ref_link, qd_ref)\n            P_as_dict[name] = P_link\n            D_as_dict[name] = D_link\n\n        scan_sys(sys, f, \"qlldd\", q_ref.T, sys.link_names, sys.link_types, P, D)\n        return PDControllerState(0, q_qd_ref, P_as_dict, D_as_dict)\n\n    def apply(\n        controller_state: PDControllerState, sys: base.System, state: base.State\n    ) -&gt; jax.Array:\n        taus = jnp.zeros((sys.qd_size()))\n        q_qd_ref = jax.tree_map(\n            lambda arr: jax.lax.dynamic_index_in_dim(\n                arr, controller_state.i, keepdims=False\n            ),\n            controller_state.q_qd_ref,\n        )\n\n        def f(_, idx_map, idx, name, typ, q_curr, qd_curr):\n            nonlocal taus\n\n            if name not in controller_state.q_qd_ref:\n                return\n\n            q_ref, qd_ref = q_qd_ref[name]\n            if typ in [\"free\", \"cor\"]:\n                P_term = jnp.concatenate(\n                    (\n                        _p_control_quaternion(q_curr[:4], q_ref[:4]),\n                        q_ref[4:] - q_curr[4:],\n                    )\n                )\n            elif typ == \"spherical\":\n                P_term = _p_control_quaternion(q_curr, q_ref)\n            elif typ in [\"rx\", \"ry\", \"rz\", \"rr\"]:\n                # q_ref comes from rcmg. Thus, it is already wrapped\n                # TODO: Currently state.q is not wrapped. Change that?\n                P_term = maths.wrap_to_pi(q_ref - maths.wrap_to_pi(q_curr))\n            elif typ in [\"px\", \"py\", \"pz\"]:\n                P_term = q_ref - q_curr\n            elif typ == \"frozen\":\n                return\n            else:\n                raise NotImplementedError(\n                    f\"pd control of joint type {typ} is not yet implemented.\"\n                )\n\n            D_term = qd_ref - qd_curr\n\n            P_link = controller_state.P_gains[name]\n            D_link = controller_state.D_gains[name]\n\n            tau = P_link * P_term + D_link * D_term\n            taus = taus.at[idx_map[\"d\"](idx)].set(tau)\n\n        scan_sys(\n            sys,\n            f,\n            \"lllqd\",\n            list(range(sys.num_links())),\n            sys.link_names,\n            sys.link_types,\n            state.q,\n            state.qd,\n        )\n\n        return controller_state.replace(i=controller_state.i + 1), taus\n\n    return SimpleNamespace(init=init, apply=apply)\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.sensors.imu","title":"<code>imu(xs, gravity, dt, key=None, noisy=False, smoothen_degree=None, delay=None, random_s2s_ori=None, quasi_physical=False, low_pass_filter_pos_f_cutoff=None, low_pass_filter_rot_alpha=None, has_magnetometer=False, magvec=None)</code>","text":"<p>Simulates a 6D IMU, <code>xs</code> should be Transforms from eps-to-imu. NOTE: <code>smoothen_degree</code> is used as window size for moving average. NOTE: If <code>smoothen_degree</code> is given, and <code>delay</code> is not, then delay is chosen such moving average window is delayed to just be causal.</p> Source code in <code>x_xy/algorithms/sensors.py</code> <pre><code>def imu(\n    xs: base.Transform,\n    gravity: jax.Array,\n    dt: float,\n    key: Optional[jax.random.PRNGKey] = None,\n    noisy: bool = False,\n    smoothen_degree: Optional[int] = None,\n    delay: Optional[int] = None,\n    random_s2s_ori: Optional[float] = None,\n    quasi_physical: bool = False,\n    low_pass_filter_pos_f_cutoff: Optional[float] = None,\n    low_pass_filter_rot_alpha: Optional[bool] = None,\n    has_magnetometer: bool = False,\n    magvec: Optional[jax.Array] = None,\n) -&gt; dict:\n\"\"\"Simulates a 6D IMU, `xs` should be Transforms from eps-to-imu.\n    NOTE: `smoothen_degree` is used as window size for moving average.\n    NOTE: If `smoothen_degree` is given, and `delay` is not, then delay is chosen\n    such moving average window is delayed to just be causal.\n    \"\"\"\n    assert xs.ndim() == 2\n\n    if random_s2s_ori is not None:\n        assert key is not None, \"`random_s2s_ori` requires a random seed via `key`\"\n        # `xs` are now from eps-to-segment, so add another final rotation from\n        # segment-to-sensor where this transform is only rotational\n        key, consume = jax.random.split(key)\n        xs_s2s = base.Transform.create(\n            rot=maths.quat_random(consume, maxval=random_s2s_ori)\n        )\n        xs = jax.vmap(algebra.transform_mul, in_axes=(None, 0))(xs_s2s, xs)\n\n    if quasi_physical:\n        xs = _quasi_physical_simulation(xs, dt)\n\n    if low_pass_filter_pos_f_cutoff is not None:\n        xs = xs.replace(pos=_butterworth(xs.pos, 1 / dt, low_pass_filter_pos_f_cutoff))\n\n    if low_pass_filter_rot_alpha is not None:\n        xs = xs.replace(rot=maths.quat_lowpassfilter(xs.rot, low_pass_filter_rot_alpha))\n\n    measurements = {\"acc\": accelerometer(xs, gravity, dt), \"gyr\": gyroscope(xs.rot, dt)}\n\n    if has_magnetometer:\n        if magvec is None:\n            assert key is not None\n            key, consume = jax.random.split(key)\n            magvec = _draw_random_magvec(consume)\n        measurements[\"mag\"] = magnetometer(xs.rot, magvec)\n\n    if smoothen_degree is not None:\n        measurements = jax.tree_map(\n            lambda arr: _moving_average(arr, smoothen_degree),\n            measurements,\n        )\n\n        # if you low-pass filter the imu measurements through a moving average which\n        # effectively uses future values, then it also makes sense to delay the imu\n        # measurements by this amount such that no future information is used\n        if delay is None:\n            half_window = (smoothen_degree - 1) // 2\n            delay = half_window\n\n    if delay is not None and delay &gt; 0:\n        measurements = jax.tree_map(\n            lambda arr: (jnp.pad(arr, ((delay, 0), (0, 0)))[:-delay]), measurements\n        )\n\n    if noisy:\n        assert key is not None, \"For noisy sensors random seed `key` must be provided.\"\n        measurements = add_noise_bias(key, measurements)\n\n    return measurements\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.sensors.rel_pose","title":"<code>rel_pose(sys_scan, xs, sys_xs=None)</code>","text":"<p>Relative pose of the entire system. <code>sys_scan</code> defines the parent-child ordering, relative pose is from child to parent in local coordinates. Bodies that connect to the base are skipped (that would be absolute pose).</p> <p>Parameters:</p> Name Type Description Default <code>sys_scan</code> <code>System</code> <p>System defining parent-child ordering.</p> required <code>xs</code> <code>Transform</code> <p>Body transforms from base to body.</p> required <code>sys_xs</code> <code>System</code> <p>System that defines the stacking order of <code>xs</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Child-to-parent quaternions</p> Source code in <code>x_xy/algorithms/sensors.py</code> <pre><code>def rel_pose(\n    sys_scan: base.System, xs: base.Transform, sys_xs: Optional[base.System] = None\n) -&gt; dict:\n\"\"\"Relative pose of the entire system. `sys_scan` defines the parent-child ordering,\n    relative pose is from child to parent in local coordinates. Bodies that connect\n    to the base are skipped (that would be absolute pose).\n\n    Args:\n        sys_scan (base.System): System defining parent-child ordering.\n        xs (base.Transform): Body transforms from base to body.\n        sys_xs (base.System): System that defines the stacking order of `xs`.\n\n    Returns:\n        dict: Child-to-parent quaternions\n    \"\"\"\n    if sys_xs is None:\n        sys_xs = sys_scan\n\n    if xs.pos.ndim == 3:\n        # swap (n_timesteps, n_links) axes\n        xs = xs.transpose([1, 0, 2])\n\n    assert xs.batch_dim() == sys_xs.num_links()\n\n    qrel = lambda q1, q2: maths.quat_mul(q1, maths.quat_inv(q2))\n\n    y = {}\n\n    def pose_child_to_parent(_, __, name_i: str, p: int):\n        # body connects to base\n        if p == -1:\n            return\n\n        name_p = sys_scan.idx_to_name(p)\n\n        # find the transforms of those named bodies\n        i = sys_xs.name_to_idx(name_i)\n        p = sys_xs.name_to_idx(name_p)\n\n        # get those transforms\n        q1, q2 = xs.take(p).rot, xs.take(i).rot\n\n        y[name_i] = qrel(q1, q2)\n\n    scan_sys(\n        sys_scan, pose_child_to_parent, \"ll\", sys_scan.link_names, sys_scan.link_parents\n    )\n\n    return y\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.sensors.joint_axes","title":"<code>joint_axes(sys, xs, sys_xs, key=None, noisy=False, from_sys=False)</code>","text":"Source code in <code>x_xy/algorithms/sensors.py</code> <pre><code>def joint_axes(\n    sys: base.System,\n    xs: base.Transform,\n    sys_xs: base.System,\n    key: Optional[jax.Array] = None,\n    noisy: bool = False,\n    from_sys: bool = False,\n):\n    if from_sys:\n        N = xs.shape(axis=0)\n        X = _joint_axes_from_sys(sys, N)\n    else:\n        X = _joint_axes_from_xs(sys, xs, sys_xs)\n\n    if noisy:\n        assert key is not None\n        for name in X:\n            key, c1, c2 = jax.random.split(key, 3)\n            bias = maths.quat_random(c1, maxval=jnp.deg2rad(5.0))\n            noise = maths.quat_random(c2, (N,), maxval=jnp.deg2rad(2.0))\n            dist = maths.quat_mul(noise, bias)\n            X[name][\"joint_axes\"] = maths.rotate(X[name][\"joint_axes\"], dist)\n\n    return X\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.jcalc.register_new_joint_type","title":"<code>register_new_joint_type(joint_type, joint_model, q_width, qd_width=None, overwrite=False)</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>def register_new_joint_type(\n    joint_type: str,\n    joint_model: JointModel,\n    q_width: int,\n    qd_width: Optional[int] = None,\n    overwrite: bool = False,\n):\n    exists = joint_type in _joint_types\n    if exists and overwrite:\n        for dic in [base.Q_WIDTHS, base.QD_WIDTHS, _joint_types]:\n            dic.pop(joint_type)\n    else:\n        assert (\n            not exists\n        ), f\"joint type `{joint_type}`already exists, use `overwrite=True`\"\n\n    if qd_width is None:\n        qd_width = q_width\n\n    assert len(joint_model.motion) == qd_width\n    _joint_types.update({joint_type: joint_model})\n    base.Q_WIDTHS.update({joint_type: q_width})\n    base.QD_WIDTHS.update({joint_type: qd_width})\n</code></pre>"},{"location":"api/x_xy/#x_xy.algorithms.jcalc.JointModel","title":"<code>JointModel</code>  <code>dataclass</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>@dataclass\nclass JointModel:\n    # (q, params) -&gt; Transform\n    transform: Callable[[jax.Array, jax.Array], base.Transform]\n    # len(motion) == len(qd)\n    # if callable: joint_params -&gt; base.Motion\n    motion: list[base.Motion | Callable[[jax.Array], base.Motion]] = field(\n        default_factory=lambda: []\n    )\n    # (config, key_t, key_value, params) -&gt; jax.Array\n    rcmg_draw_fn: Optional[DRAW_FN] = None\n</code></pre>"},{"location":"api/x_xy/#x_xy.base.update_n_joint_params","title":"<code>update_n_joint_params(n_joint_params=None)</code>","text":"<p>If None then reset to default value.</p> Source code in <code>x_xy/base.py</code> <pre><code>def update_n_joint_params(n_joint_params: Optional[int] = None) -&gt; None:\n    \"If None then reset to default value.\"\n    global _N_JOINT_PARAMS\n    global _DEFAULT_N_JOINT_PARAMS\n    if n_joint_params is None:\n        _N_JOINT_PARAMS = _DEFAULT_N_JOINT_PARAMS\n    else:\n        _N_JOINT_PARAMS = n_joint_params\n</code></pre>"},{"location":"api/subpkgs/exp/","title":"exp","text":""},{"location":"api/subpkgs/exp/#x_xy.subpkgs.exp.exp.load_data","title":"<code>load_data(exp_id, motion_start=None, motion_stop=None, left_padd=0.0, right_padd=0.0, resample_to_hz=100.0)</code>","text":"Source code in <code>x_xy/subpkgs/exp/exp.py</code> <pre><code>def load_data(\n    exp_id: str,\n    motion_start: Optional[str] = None,\n    motion_stop: Optional[str] = None,\n    left_padd: float = 0.0,\n    right_padd: float = 0.0,\n    resample_to_hz: float = 100.0,\n) -&gt; dict:\n    trial_data = joblib.load(x_xy.utils.download_from_repo(f\"data/{exp_id}.joblib\"))\n\n    metadata = _read_yaml(\"metadata.yaml\")[exp_id]\n    timings = metadata[\"timings\"]\n    hz_imu, hz_omc = float(metadata[\"hz\"][\"imu\"]), float(metadata[\"hz\"][\"omc\"])\n\n    trial_data = omc.resample(\n        trial_data,\n        hz_in=omc.hz_helper(trial_data.keys(), hz_imu=hz_imu, hz_omc=hz_omc),\n        hz_out=resample_to_hz,\n        vecinterp_method=\"cubic\",\n    )\n    trial_data = omc.crop_tail(trial_data, resample_to_hz, strict=True, verbose=False)\n\n    if motion_start is not None:\n        assert (\n            motion_start in timings\n        ), f\"`{motion_start}` is not one of {load_timings(exp_id).keys()}\"\n\n        motion_sequence = list(timings.keys())\n        next_motion_i = motion_sequence.index(motion_start) + 1\n        assert next_motion_i &lt; len(motion_sequence)\n\n        if motion_stop is None:\n            motion_stop = motion_sequence[next_motion_i]\n\n        assert (\n            motion_stop in timings\n        ), f\"`{motion_stop}` is not one of {load_timings(exp_id).keys()}\"\n\n        assert motion_sequence.index(motion_start) &lt; motion_sequence.index(\n            motion_stop\n        ), \"Empty sequence, stop &lt;= start\"\n\n        t1 = timings[motion_start] - left_padd\n        # ensure that t1 &gt;= 0\n        t1 = max(t1, 0.0)\n        t2 = timings[motion_stop] + right_padd\n\n        trial_data = _crop_sequence(trial_data, 1 / resample_to_hz, t1=t1, t2=t2)\n    else:\n        assert motion_stop is None\n\n    return trial_data\n</code></pre>"},{"location":"api/subpkgs/exp/#x_xy.subpkgs.exp.exp.load_sys","title":"<code>load_sys(exp_id, preprocess_sys=None, morph_yaml_key=None, delete_after_morph=None, replace_rxyz=None)</code>","text":"Source code in <code>x_xy/subpkgs/exp/exp.py</code> <pre><code>def load_sys(\n    exp_id: str,\n    preprocess_sys: Optional[Callable] = None,\n    morph_yaml_key: Optional[str] = None,\n    delete_after_morph: Optional[list[str]] = None,\n    replace_rxyz: Optional[str] = None,\n) -&gt; x_xy.base.System:\n    xml_path = _relative_to_this_file(_id2xml[exp_id])\n    sys = x_xy.io.load_sys_from_xml(xml_path)\n\n    if preprocess_sys is not None:\n        sys = preprocess_sys(sys)\n\n    if replace_rxyz is not None:\n        sys = _replace_rxyz_with(sys, replace_rxyz)\n\n    if morph_yaml_key is not None:\n        new_parents = _morph_new_parents_from_xml_file(xml_path)[morph_yaml_key]\n        sys = sys_composer.morph_system(sys, new_parents)\n\n    if delete_after_morph is not None:\n        sys = sys_composer.delete_subsystem(sys, delete_after_morph)\n\n    return sys\n</code></pre>"},{"location":"api/subpkgs/ml/","title":"ml","text":""},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.rnno.make_rnno","title":"<code>make_rnno(sys=None, hidden_state_dim=400, message_dim=200, cell_type='gru', stack_rnn_cells=1, send_message_n_layers=1, send_message_method='mlp', send_message_init=hk.initializers.Orthogonal(), send_message_stop_grads=False, send_message_afterwards_layernorm=False, link_output_dim=4, link_output_normalize=True, link_output_transform=None, layernorm=False, keep_toRoot_output=False)</code>","text":"<p>Expects batched inputs.</p> Source code in <code>x_xy/subpkgs/ml/rnno.py</code> <pre><code>def make_rnno(\n    sys: Optional[base.System] = None,\n    hidden_state_dim: int = 400,\n    message_dim: int = 200,\n    cell_type: str = \"gru\",\n    stack_rnn_cells: int = 1,\n    send_message_n_layers: int = 1,\n    send_message_method: str = \"mlp\",\n    send_message_init: hk.initializers.Initializer = hk.initializers.Orthogonal(),\n    send_message_stop_grads: bool = False,\n    send_message_afterwards_layernorm: bool = False,\n    link_output_dim: int = 4,\n    link_output_normalize: bool = True,\n    link_output_transform: Optional[Callable] = None,\n    layernorm: bool = False,\n    keep_toRoot_output: bool = False,\n) -&gt; SimpleNamespace:\n    \"Expects batched inputs.\"\n\n    if sys is None:\n        return make_non_social_version(make_rnno, kwargs=locals())\n\n    if cell_type == \"gru\":\n        cell = hk.GRU\n        hidden_state_dtype = jnp.float32\n        hidden_state_init = hidden_state_dim\n    elif cell_type == \"lstm\":\n        cell = LSTM\n        hidden_state_init = hidden_state_dim * 2\n        hidden_state_dtype = jnp.float32\n    elif cell_type == \"lru\":\n        cell = LRU\n        hidden_state_init = hidden_state_dim\n        hidden_state_dtype = jnp.complex64\n    else:\n        raise NotImplementedError\n\n    if link_output_normalize:\n        assert link_output_transform is None\n        link_output_transform = safe_normalize\n    else:\n        if link_output_transform is None:\n            link_output_transform = lambda x: x\n\n    @hk.without_apply_rng\n    @hk.transform_with_state\n    def forward(X):\n        if send_message_method == \"mlp\":\n            send_msg = hk.nets.MLP(\n                [hidden_state_dim] * send_message_n_layers + [message_dim]\n            )\n        elif send_message_method == \"matrix\":\n            matrix = hk.get_state(\n                \"send_msg_matrix\",\n                [message_dim, hidden_state_dim],\n                init=send_message_init,\n            )\n            send_msg = lambda hidden_state: matrix @ hidden_state\n        else:\n            raise NotImplementedError\n\n        inner_cell = StackedRNNCell(\n            cell, hidden_state_dim, stack_rnn_cells, layernorm=layernorm\n        )\n        send_output = hk.nets.MLP([hidden_state_dim, link_output_dim])\n        state = hk.get_state(\n            \"inner_cell_state\",\n            [sys.num_links(), stack_rnn_cells, hidden_state_init],\n            init=jnp.zeros,\n            dtype=hidden_state_dtype,\n        )\n\n        y, state = hk.dynamic_unroll(\n            _make_rnno_cell_apply_fn(\n                sys,\n                inner_cell,\n                send_msg,\n                send_output,\n                hidden_state_dim,\n                message_dim,\n                send_message_stop_grads,\n                output_transform=link_output_transform,\n                message_layernorm=send_message_afterwards_layernorm,\n                keep_toRoot_output=keep_toRoot_output,\n            ),\n            X,\n            state,\n        )\n        hk.set_state(\"inner_cell_state\", state)\n        return y\n\n    def init(key, X):\n        \"X.shape (bs, timesteps, features)\"\n        X = tree_utils.to_2d_if_3d(X, strict=True)\n        return forward.init(key, X)\n\n    def apply(params, state, X):\n\"\"\"\n        params: (features)\n        state.shape (bs, features)\n        X.shape (bs, timesteps, features)\n\n        Returns: (yhat, state)\n        yhat.shape (bs, timesteps, features)\n        state.shape (bs, features)\n        \"\"\"\n        assert tree_utils.tree_ndim(X) == 3\n        return jax.vmap(forward.apply, in_axes=(None, 0, 0))(params, state, X)\n\n    return SimpleNamespace(init=init, apply=apply)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.lru.make_lru_observer","title":"<code>make_lru_observer(sys=None, hidden_state_dim_lru=192, hidden_state_dim_encoder=96, hidden_state_dim_decoder=96, embed_dim=192, n_residual_blocks=2, layernorm=False, keep_toRoot_output=False, link_output_dim=4, link_output_normalize=True, link_output_transform=None)</code>","text":"Source code in <code>x_xy/subpkgs/ml/lru.py</code> <pre><code>def make_lru_observer(\n    sys: Optional[System] = None,\n    hidden_state_dim_lru: int = 192,\n    hidden_state_dim_encoder: int = 96,\n    hidden_state_dim_decoder: int = 96,\n    embed_dim: int = 192,\n    n_residual_blocks: int = 2,\n    layernorm: bool = False,\n    keep_toRoot_output: bool = False,\n    link_output_dim: int = 4,\n    link_output_normalize: bool = True,\n    link_output_transform: Optional[Callable] = None,\n):\n    if sys is None:\n        return make_non_social_version(make_lru_observer, kwargs=locals())\n\n    assert sys.num_links() &lt; _MAX_OUTPUT_N_LINKS\n\n    if link_output_normalize:\n        assert link_output_transform is None\n        link_output_transform = maths.safe_normalize\n    else:\n        if link_output_transform is None:\n            link_output_transform = lambda x: x\n\n    dummy_state = jnp.zeros((1,))\n    lru_observer = LRU_Observer(\n        sys=sys,\n        output_dim=link_output_dim,\n        hidden_state_dim_lru=hidden_state_dim_lru,\n        hidden_state_dim_encoder=hidden_state_dim_encoder,\n        hidden_state_dim_decoder=hidden_state_dim_decoder,\n        embed_dim=embed_dim,\n        n_residual_blocks=n_residual_blocks,\n        layernorm=layernorm,\n        link_output_transform=link_output_transform,\n    )\n\n    def init(key, X):\n        params = lru_observer.init(key, X)\n        return params, dummy_state\n\n    def apply(params, state, X):\n        yhat = lru_observer.apply(params, X)\n        if not keep_toRoot_output:\n            for i, name in enumerate(sys.link_names):\n                if sys.link_parents[i] == -1:\n                    yhat.pop(name)\n        return yhat, state\n\n    return SimpleNamespace(init=init, apply=apply)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.base.AbstractFilter","title":"<code>AbstractFilter</code>","text":"Source code in <code>x_xy/subpkgs/ml/base.py</code> <pre><code>class AbstractFilter(ABC):\n    def _predict_2d(self, X: dict, sys: x_xy.System | None) -&gt; dict:\n        X = tree_utils.add_batch_dim(X)\n        y = self._predict_3d(X, sys)\n        return tree_utils.tree_slice(y, 0)\n\n    @abstractmethod\n    def _predict_3d(self, X: dict, sys: x_xy.System | None) -&gt; dict:\n        pass\n\n    def predict(self, X: dict, sys: x_xy.System | None) -&gt; dict:\n        \"X.shape = (bs, timesteps, features) or (timesteps, features)\"\n        if tree_utils.tree_ndim(X) == 2:\n            return self._predict_2d(X, sys)\n        else:\n            return self._predict_3d(X, sys)\n\n    @property\n    def name(self) -&gt; str:\n        if not hasattr(self, \"_name\"):\n            raise NotImplementedError\n\n        if self._name is None:\n            raise RuntimeError(\"No `name` was given.\")\n        return self._name\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.base.AbstractFilter.predict","title":"<code>predict(X, sys)</code>","text":"<p>X.shape = (bs, timesteps, features) or (timesteps, features)</p> Source code in <code>x_xy/subpkgs/ml/base.py</code> <pre><code>def predict(self, X: dict, sys: x_xy.System | None) -&gt; dict:\n    \"X.shape = (bs, timesteps, features) or (timesteps, features)\"\n    if tree_utils.tree_ndim(X) == 2:\n        return self._predict_2d(X, sys)\n    else:\n        return self._predict_3d(X, sys)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.base.AbstractFilter2d","title":"<code>AbstractFilter2d</code>","text":"<p>Same as <code>AbstractFilter</code> but have to define <code>_predict_2d</code></p> Source code in <code>x_xy/subpkgs/ml/base.py</code> <pre><code>class AbstractFilter2d(AbstractFilter):\n    \"Same as `AbstractFilter` but have to define `_predict_2d`\"\n\n    @abstractmethod\n    def _predict_2d(self, X: dict, sys: System | None) -&gt; dict:\n        pass\n\n    def _predict_3d(self, X: dict, sys: System | None) -&gt; dict:\n        N = tree_utils.tree_shape(X)\n        ys = []\n        for i in range(N):\n            ys.append(self._predict_2d(tree_utils.tree_slice(X, i), sys))\n        return tree_utils.tree_batch(ys)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.base.InitApplyFnFilter","title":"<code>InitApplyFnFilter</code>","text":"Source code in <code>x_xy/subpkgs/ml/base.py</code> <pre><code>class InitApplyFnFilter(AbstractFilter):\n    def __init__(\n        self,\n        init_apply_fn_factory: Callable[[x_xy.System], SimpleNamespace],\n        name: Optional[str] = None,\n        params: Optional[str | tree_utils.PyTree] = None,\n        key: jax.Array = jax.random.PRNGKey(1),\n        lpf: Optional[float] = None,\n    ):\n        self._name = name\n        self.key = key\n        self.params = self._load_params(params)\n        self.init_apply_fn_factory = init_apply_fn_factory\n        self.lpf = lpf\n\n    def _predict_3d(self, X: dict, sys: System | None) -&gt; dict:\n        init_apply_fn = self.init_apply_fn_factory(sys)\n        params, state = init_apply_fn.init(self.key, X)\n        params = params if self.params is None else self.params\n        bs = tree_utils.tree_shape(X)\n        state = jax.tree_map(lambda arr: jnp.repeat(arr[None], bs, axis=0), state)\n        yhat = init_apply_fn.apply(params, state, X)[0]\n\n        if self.lpf is not None:\n            yhat = jax.tree_map(\n                jax.vmap(\n                    lambda q: x_xy.maths.quat_lowpassfilter(q, self.lpf, filtfilt=True)\n                ),\n                yhat,\n            )\n\n        return yhat\n\n    @staticmethod\n    def _load_params(params: str | tree_utils.PyTree | None):\n        if params is None:\n            return None\n        if isinstance(params, str):\n            return load(params)\n        return params\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.train.train","title":"<code>train(generator, n_episodes, network, optimizer=None, tbp=1000, tbp_skip=0, tbp_skip_keep_grads=False, loggers=[], callbacks=[], initial_params=None, initial_params_pretrained=None, key_network=key_network, key_generator=key_generator, callback_save_params=None, callback_save_params_track_metrices=None, callback_kill_if_grads_larger=None, callback_kill_if_nan=False, callback_kill_after_episode=None, callback_kill_after_seconds=None, callback_kill_tag=None, loss_fn=_default_loss_fn, metrices=_default_metrices)</code>","text":"<p>Trains RNNO</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>Callable</code> <p>output of the rcmg-module</p> required <code>n_episodes</code> <code>int</code> <p>number of episodes to train for</p> required <code>network</code> <code>TransformedWithState</code> <p>RNNO network</p> required <code>optimizer</code> <code>_type_</code> <p>optimizer, see optimizer.py module</p> <code>None</code> <code>tbp</code> <code>int</code> <p>Truncated backpropagation through time step size</p> <code>1000</code> <code>tbp_skip</code> <code>int</code> <p>Skip <code>tbp_skip</code> number of first steps per epoch.</p> <code>0</code> <code>tbp_skip_keep_grads</code> <code>bool</code> <p>Keeps grads between first <code>tbp_skip</code> steps per epoch.</p> <code>False</code> <code>loggers</code> <code>list[Logger]</code> <p>list of Loggers used to log the training progress.</p> <code>[]</code> <code>callbacks</code> <code>list[TrainingLoopCallback]</code> <p>callbacks of the TrainingLoop.</p> <code>[]</code> <code>initial_params</code> <code>Optional[str]</code> <p>If given uses as initial parameters.</p> <code>None</code> <code>key_network</code> <code>PRNGKey</code> <p>PRNG Key that inits the network state and parameters.</p> <code>key_network</code> <code>key_generator</code> <code>PRNGKey</code> <p>PRNG Key that inits the data stream of the generator.</p> <code>key_generator</code> <p>bool</p> Type Description <code>bool</code> <p>Wether or not the training run was killed by a callback.</p> Source code in <code>x_xy/subpkgs/ml/train.py</code> <pre><code>def train(\n    generator: Callable,\n    n_episodes: int,\n    network: hk.TransformedWithState,\n    optimizer: Optional[optax.GradientTransformation] = None,\n    tbp: int = 1000,\n    tbp_skip: int = 0,\n    tbp_skip_keep_grads: bool = False,\n    loggers: list[Logger] = [],\n    callbacks: list[TrainingLoopCallback] = [],\n    initial_params: Optional[str] = None,\n    initial_params_pretrained: Optional[tuple[str, int]] = None,\n    key_network: jax.random.PRNGKey = key_network,\n    key_generator: jax.random.PRNGKey = key_generator,\n    callback_save_params: Optional[str] = None,\n    callback_save_params_track_metrices: Optional[list[list[str]]] = None,\n    callback_kill_if_grads_larger: Optional[float] = None,\n    callback_kill_if_nan: bool = False,\n    callback_kill_after_episode: Optional[int] = None,\n    callback_kill_after_seconds: Optional[float] = None,\n    callback_kill_tag: Optional[str] = None,\n    loss_fn: LOSS_FN = _default_loss_fn,\n    metrices: Optional[METRICES] = _default_metrices,\n) -&gt; bool:\n\"\"\"Trains RNNO\n\n    Args:\n        generator (Callable): output of the rcmg-module\n        n_episodes (int): number of episodes to train for\n        network (hk.TransformedWithState): RNNO network\n        optimizer (_type_, optional): optimizer, see optimizer.py module\n        tbp (int, optional): Truncated backpropagation through time step size\n        tbp_skip (int, optional): Skip `tbp_skip` number of first steps per epoch.\n        tbp_skip_keep_grads (bool, optional): Keeps grads between first `tbp_skip`\n            steps per epoch.\n        loggers: list of Loggers used to log the training progress.\n        callbacks: callbacks of the TrainingLoop.\n        initial_params: If given uses as initial parameters.\n        key_network: PRNG Key that inits the network state and parameters.\n        key_generator: PRNG Key that inits the data stream of the generator.\n\n    Returns: bool\n        Wether or not the training run was killed by a callback.\n    \"\"\"\n\n    # test if generator is batched..\n    key = jax.random.PRNGKey(0)\n    X, _ = generator(key)\n\n    if tree_utils.tree_ndim(X) == 2:\n        # .. if not then batch it\n        generator = x_xy.algorithms.batch_generators_lazy(generator, 1)\n\n    # .. now it most certainly is; Queue it for data\n    X, _ = generator(key)\n\n    batchsize = tree_utils.tree_shape(X)\n    pmap_size, vmap_size = distribute_batchsize(batchsize)\n\n    params, initial_state = network.init(\n        key_network,\n        X,\n    )\n    initial_state = _repeat_state(initial_state, batchsize)\n\n    assert not (\n        initial_params is not None and initial_params_pretrained is not None\n    ), \"Either or, not both\"\n    if initial_params is not None:\n        params = load(initial_params)\n    if initial_params_pretrained is not None:\n        pre_name, pre_version = initial_params_pretrained\n        params = load(pretrained=pre_name, pretrained_version=pre_version)\n    del initial_params\n\n    if optimizer is None:\n        # TODO; hardcoded `n_steps_per_episode`\n        optimizer = make_optimizer(\n            3e-3, n_episodes, n_steps_per_episode=6, skip_large_update_max_normsq=100.0\n        )\n\n    opt_state = optimizer.init(params)\n\n    step_fn = _build_step_fn(\n        loss_fn,\n        network.apply,\n        initial_state,\n        pmap_size,\n        vmap_size,\n        optimizer,\n        tbp=tbp,\n        tbp_skip=tbp_skip,\n        tbp_skip_keep_grads=tbp_skip_keep_grads,\n    )\n\n    default_callbacks = []\n    if metrices is not None:\n        eval_fn = _build_eval_fn(\n            metrices, network.apply, initial_state, pmap_size, vmap_size\n        )\n        default_callbacks.append(_DefaultEvalFnCallback(eval_fn))\n\n    if callback_kill_tag is not None:\n        default_callbacks.append(WandbKillRun(stop_tag=callback_kill_tag))\n\n    if callback_save_params is not None:\n        default_callbacks.append(SaveParamsTrainingLoopCallback(callback_save_params))\n\n    if callback_kill_if_grads_larger is not None:\n        default_callbacks.append(\n            LogGradsTrainingLoopCallBack(\n                callback_kill_if_grads_larger, consecutive_larger=18\n            )\n        )\n\n    if callback_kill_if_nan:\n        default_callbacks.append(NanKillRunCallback())\n\n    # always log, because we also want `i_epsiode` to be logged in wandb\n    default_callbacks.append(\n        LogEpisodeTrainingLoopCallback(callback_kill_after_episode)\n    )\n\n    if callback_kill_after_seconds is not None:\n        default_callbacks.append(TimingKillRunCallback(callback_kill_after_seconds))\n\n    callbacks_all = default_callbacks + callbacks\n\n    # we add this callback afterwards because it might require the metrices calculated\n    # from one of the user-provided callbacks\n    if callback_save_params_track_metrices is not None:\n        assert (\n            callback_save_params is not None\n        ), \"Required field if `callback_save_params_track_metrices` is set.\"\n\n        callbacks_all.append(\n            SaveParamsTrainingLoopCallback(\n                path_to_file=parse_path(callback_save_params, extension=\"\"),\n                last_n_params=3,\n                track_metrices=callback_save_params_track_metrices,\n                cleanup=True,\n            )\n        )\n\n    # if wandb is initialized, then add the appropriate logger\n    if wandb.run is not None:\n        wandb_logger_found = False\n        for logger in loggers:\n            if isinstance(logger, WandbLogger):\n                wandb_logger_found = True\n        if not wandb_logger_found:\n            loggers.append(WandbLogger())\n\n    loop = TrainingLoop(\n        key_generator,\n        generator,\n        params,\n        opt_state,\n        step_fn,\n        loggers=loggers,\n        callbacks=callbacks_all,\n    )\n\n    return loop.run(n_episodes)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.optimizer.make_optimizer","title":"<code>make_optimizer(lr, n_episodes, n_steps_per_episode, adap_clip=0.1, glob_clip=0.2, skip_large_update_max_normsq=5.0, skip_large_update_warmup=300, inner_opt=optax.lamb, **inner_opt_kwargs)</code>","text":"Source code in <code>x_xy/subpkgs/ml/optimizer.py</code> <pre><code>def make_optimizer(\n    lr: float,\n    n_episodes: int,\n    n_steps_per_episode: int,\n    adap_clip: Optional[float] = 0.1,\n    glob_clip: Optional[float] = 0.2,\n    skip_large_update_max_normsq: float = 5.0,\n    skip_large_update_warmup: int = 300,\n    inner_opt=optax.lamb,\n    **inner_opt_kwargs\n):\n    steps = n_steps_per_episode * n_episodes\n    schedule = optax.cosine_decay_schedule(lr, steps, 1e-7)\n    optimizer = optax.chain(\n        optax.adaptive_grad_clip(adap_clip)\n        if adap_clip is not None\n        else optax.identity(),\n        optax.clip_by_global_norm(0.2) if glob_clip is not None else optax.identity(),\n        inner_opt(schedule, **inner_opt_kwargs),\n    )\n    optimizer = skip_large_update(\n        optimizer,\n        skip_large_update_max_normsq,\n        max_consecutive_toolarge=6 * 25,\n        warmup=skip_large_update_warmup,\n    )\n    return optimizer\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.callbacks.EvalXyTrainingLoopCallback","title":"<code>EvalXyTrainingLoopCallback</code>","text":"Source code in <code>x_xy/subpkgs/ml/callbacks.py</code> <pre><code>class EvalXyTrainingLoopCallback(TrainingLoopCallback):\n    def __init__(\n        self,\n        init_apply,\n        eval_metrices: dict[str, Tuple[Callable, Callable, Callable]],\n        X: dict,\n        y: dict,\n        metric_identifier: str,\n        eval_every: int = 5,\n    ):\n        \"X, y can be batched or unbatched.\"\n        self.X, self.y = tree_utils.to_3d_if_2d((X, y))\n        del X, y\n        _, initial_state = init_apply.init(jax.random.PRNGKey(1), self.X)\n        batchsize = tree_utils.tree_shape(self.X)\n        self.eval_fn = _build_eval_fn2(\n            eval_metrices,\n            init_apply.apply,\n            _repeat_state(initial_state, batchsize),\n            *distribute_batchsize(batchsize),\n        )\n        self.eval_every = eval_every\n        self.metric_identifier = metric_identifier\n\n    def after_training_step(\n        self,\n        i_episode: int,\n        metrices: dict,\n        params: dict,\n        grads: list[dict],\n        sample_eval: dict,\n        loggers: list[Logger],\n    ):\n        if self.eval_every == -1:\n            return\n\n        if (i_episode % self.eval_every) == 0:\n            point_estimates, _ = self.eval_fn(params, self.X, self.y)\n            self.last_metrices = {self.metric_identifier: point_estimates}\n        metrices.update(self.last_metrices)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.callbacks.EvalXyTrainingLoopCallback.__init__","title":"<code>__init__(init_apply, eval_metrices, X, y, metric_identifier, eval_every=5)</code>","text":"<p>X, y can be batched or unbatched.</p> Source code in <code>x_xy/subpkgs/ml/callbacks.py</code> <pre><code>def __init__(\n    self,\n    init_apply,\n    eval_metrices: dict[str, Tuple[Callable, Callable, Callable]],\n    X: dict,\n    y: dict,\n    metric_identifier: str,\n    eval_every: int = 5,\n):\n    \"X, y can be batched or unbatched.\"\n    self.X, self.y = tree_utils.to_3d_if_2d((X, y))\n    del X, y\n    _, initial_state = init_apply.init(jax.random.PRNGKey(1), self.X)\n    batchsize = tree_utils.tree_shape(self.X)\n    self.eval_fn = _build_eval_fn2(\n        eval_metrices,\n        init_apply.apply,\n        _repeat_state(initial_state, batchsize),\n        *distribute_batchsize(batchsize),\n    )\n    self.eval_every = eval_every\n    self.metric_identifier = metric_identifier\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.ml_utils.load","title":"<code>load(path=None, pretrained=None, pretrained_version=None)</code>","text":"Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>def load(\n    path: Optional[Union[str, Path]] = None,\n    pretrained: Optional[str] = None,\n    pretrained_version: Optional[int] = None,\n) -&gt; PyTree:\n    assert not (\n        path is None and pretrained is None\n    ), \"Either `path` or `pretrained` must be given.\"\n    assert not (\n        path is not None and pretrained is not None\n    ), \"Both `path` and `pretrained` cannot both be given.\"\n\n    if pretrained_version is not None:\n        assert pretrained is not None\n\n    if path is not None:\n        path = Path(path).expanduser()\n        if not path.is_file():\n            raise ValueError(f\"Not a file: {path}\")\n        if path.suffix != suffix:\n            raise ValueError(f\"Not a {suffix} file: {path}\")\n        with open(path, \"rb\") as file:\n            data = pickle.load(file)\n        return data\n    else:\n        version = \"\"\n        if pretrained_version is not None:\n            # v0, v1, v2, ...\n            version = f\"_v{int(pretrained_version)}\"\n        path_in_repo = f\"params/{pretrained}/params_{pretrained}{version}{suffix}\"\n        path_on_disk = download_from_repo(path_in_repo)\n        return load(path_on_disk)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.ml_utils.save","title":"<code>save(data, path, overwrite=False)</code>","text":"Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>def save(data: PyTree, path: Union[str, Path], overwrite: bool = False):\n    path = Path(path).expanduser()\n    if path.suffix != suffix:\n        path = path.with_suffix(suffix)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if path.exists():\n        if overwrite:\n            path.unlink()\n        else:\n            raise RuntimeError(f\"File {path} already exists.\")\n    with open(path, \"wb\") as file:\n        pickle.dump(data, file, protocol=5)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.ml_utils.list_pretrained","title":"<code>list_pretrained()</code>","text":"<p>Open Github repo that hosts the pretrained parameters.</p> Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>def list_pretrained() -&gt; None:\n    \"Open Github repo that hosts the pretrained parameters.\"\n    url = \"https://github.com/SimiPixel/x_xy_v2_datahost/tree/main/params\"\n    webbrowser.open(url)\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.ml_utils.n_params","title":"<code>n_params(params)</code>","text":"<p>Number of parameters in Pytree <code>params</code>.</p> Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>def n_params(params) -&gt; int:\n    \"Number of parameters in Pytree `params`.\"\n    return sum([arr.flatten().size for arr in jax.tree_util.tree_leaves(params)])\n</code></pre>"},{"location":"api/subpkgs/ml/#x_xy.subpkgs.ml.ml_utils.WandbLogger","title":"<code>WandbLogger</code>","text":"Source code in <code>x_xy/subpkgs/ml/ml_utils.py</code> <pre><code>class WandbLogger(MultimediaLogger):\n    def __init__(self):\n        _log_environment(self)\n        wandb.run.define_metric(STEP_METRIC_NAME)\n\n    def log_key_value(self, key: str, value: str | float, step: Optional[int] = None):\n        data = {key: value}\n        if step is not None:\n            data.update({STEP_METRIC_NAME: step})\n        wandb.log(data)\n\n    def log_params(self, path: str):\n        self._print_upload_file(path)\n        wandb.save(path, policy=\"now\")\n\n    def log_video(\n        self,\n        path: str,\n        fps: int = 25,\n        caption: Optional[str] = None,\n        step: Optional[int] = None,\n    ):\n        # TODO &gt;&gt;&gt;\n        wandb.save(path, policy=\"now\")\n        return\n        # &lt;&lt;&lt;\n        data = {\"video\": wandb.Video(path, caption=caption, fps=fps)}\n        if step is not None:\n            data.update({STEP_METRIC_NAME: step})\n        wandb.log(data)\n\n    def log_image(self, path: str, caption: Optional[str] = None):\n        # wandb.log({\"image\": wandb.Image(path, caption=caption)})\n        wandb.save(path, policy=\"now\")\n\n    def log_txt(self, path: str, wait: bool = True):\n        wandb.save(path, policy=\"now\")\n        # TODO: `wandb` is not async at all?\n        if wait:\n            time.sleep(3)\n\n    @staticmethod\n    def disable():\n        os.environ[\"WANDB_MODE\"] = \"offline\"\n\n    def close(self):\n        wandb.run.finish()\n</code></pre>"},{"location":"api/subpkgs/omc/","title":"omc","text":""},{"location":"api/subpkgs/omc/#x_xy.subpkgs.omc.read_omc","title":"<code>read_omc(path_marker_imu_setup_file, path_optitrack_file, path_imu_folder, segment_names_setup_file=['seg1', 'seg2', 'seg3', 'seg4', 'seg5'], imu_names_setup_file=['imu_rigid', 'imu_flex'], imu_file_prefix=None, imu_file_delimiter=None, qEOpt2EImu_euler_deg=np.array([0.0, 0, 0]), qImu2Seg_euler_deg={}, imu_sync_offset=None, hz_opt=None, hz_imu=None, verbose=True)</code>","text":"Source code in <code>x_xy/subpkgs/omc/omc.py</code> <pre><code>def read_omc(\n    path_marker_imu_setup_file: str,\n    path_optitrack_file: str,\n    path_imu_folder: str,\n    segment_names_setup_file: list[str] = [\"seg1\", \"seg2\", \"seg3\", \"seg4\", \"seg5\"],\n    imu_names_setup_file: list[str] = [\"imu_rigid\", \"imu_flex\"],\n    imu_file_prefix: Optional[str] = None,\n    imu_file_delimiter: Optional[str] = None,\n    # zyx convention\n    qEOpt2EImu_euler_deg: np.ndarray = np.array([0.0, 0, 0]),\n    # if imu and seg not in `q_Imu2seg[seg][imu]`, then [0, 0, 0]\n    # also zyx convention\n    qImu2Seg_euler_deg: dict = {},\n    imu_sync_offset: Optional[dict] = None,\n    hz_opt: Optional[int] = None,\n    hz_imu: Optional[int] = None,\n    verbose: bool = True,\n) -&gt; dict:\n    p_setup_file = parse_path(path_marker_imu_setup_file, extension=\"json\")\n    path_optitrack = parse_path(path_optitrack_file, extension=\"csv\")\n    path_imu = parse_path(path_imu_folder)\n\n    with open(p_setup_file) as f:\n        marker_imu_setup = json.load(f)\n\n    if hz_opt is None:\n        hz_opt = autodetermine_optitrack_freq(path_optitrack)\n        if verbose:\n            print(f\"OMC Hz: {hz_opt}\")\n\n    if hz_imu is None:\n        hz_imu = autodetermine_imu_freq(path_imu)\n        if verbose:\n            print(f\"IMU Hz: {hz_imu}\")\n\n    if imu_file_prefix is None:\n        imu_file_prefix = autodetermine_imu_file_prefix(path_imu)\n        if verbose:\n            print(f\"IMU File Prefix: {imu_file_prefix}\")\n\n    if imu_file_delimiter is None:\n        imu_file_delimiter = autodetermine_imu_file_delimiter(path_imu)\n        if verbose:\n            print(f\"IMU File Delimiter: {imu_file_delimiter}\")\n\n    data = {}\n    if imu_sync_offset is None:\n        imu_sync_offset = {}\n\n    for seg in segment_names_setup_file:\n        data[seg] = {}\n        if seg not in imu_sync_offset:\n            imu_sync_offset[seg] = {}\n\n        seg_number = int(seg[3])\n        xaxis_markers = marker_imu_setup[seg][\"xaxis_markers\"][0]\n        yaxis_markers = marker_imu_setup[seg][\"yaxis_markers\"][0]\n\n        quat_opt_markers2EOpt = _construct_quat_from_three_markers(\n            path_optitrack, seg_number, xaxis_markers, yaxis_markers, marker_imu_setup\n        )\n\n        imus = {}\n        for imu in imu_names_setup_file:\n            imu_number = marker_imu_setup[seg][imu]\n            imu_unsynced = _imu_measurements_from_txt(\n                path_imu, imu_file_prefix, imu_number, imu_file_delimiter\n            )\n            if imu not in imu_sync_offset[seg]:\n                imu_sync_offset[seg][imu] = _sync_imu_offset_with_optical(\n                    imu_unsynced, quat_opt_markers2EOpt, hz_imu, hz_opt\n                )\n            if verbose:\n                print(\n                    f\"Segment: {seg_number}, IMU: {imu_number}, Offset: \"\n                    f\"{imu_sync_offset[seg][imu]}\"\n                )\n\n            assert (\n                imu_sync_offset[seg][imu] &gt;= 0\n            ), f\"IMU sync offset negative, {imu_sync_offset[seg][imu]}\"\n            imu_synced = jax.tree_map(\n                lambda arr: arr[imu_sync_offset[seg][imu] :], imu_unsynced\n            )\n            imus[imu] = imu_synced\n\n            # alignment: rigid-imu to markers\n            q_Imu2Seg_default = np.array([1.0, 0, 0, 0])\n            if seg in qImu2Seg_euler_deg:\n                if imu in qImu2Seg_euler_deg[seg]:\n                    q_Imu2Seg_default = _from_euler(qImu2Seg_euler_deg[seg][imu])\n\n            for signal in [\"acc\", \"mag\", \"gyr\"]:\n                imus[imu][signal] = qmt.rotate(q_Imu2Seg_default, imus[imu][signal])\n\n        data[seg].update(imus)\n\n        # alignment: earth_omc to earth_inertial\n        qEOpt2EImu = _from_euler(qEOpt2EImu_euler_deg)\n        data[seg][\"quat\"] = qmt.qmult(qEOpt2EImu, quat_opt_markers2EOpt)\n        for marker_number in range(1, 5):\n            data[seg][f\"marker{marker_number}\"] = qmt.rotate(\n                qEOpt2EImu,\n                _construct_pos_from_single_marker(\n                    path_optitrack, seg_number, marker_number\n                ),\n            )\n\n    return data, imu_sync_offset\n</code></pre>"},{"location":"api/subpkgs/omc/#x_xy.subpkgs.omc.utils.crop_tail","title":"<code>crop_tail(signal, hz=None, strict=True, verbose=True)</code>","text":"<p>Crop all signals to length of shortest signal.</p> Source code in <code>x_xy/subpkgs/omc/utils.py</code> <pre><code>def crop_tail(\n    signal: PyTree,\n    hz: Optional[int | float | PyTree] = None,\n    strict: bool = True,\n    verbose: bool = True,\n):\n    \"Crop all signals to length of shortest signal.\"\n    if hz is None:\n        hz = 1.0\n\n    if isinstance(hz, (int, float)):\n        hz = tree.map_structure(lambda _: hz, signal)\n\n    # int -&gt; float\n    hz = tree.map_structure(float, hz)\n\n    def length_in_seconds(arr, hz):\n        assert arr.ndim &lt; 3\n        return len(arr) / hz\n\n    signal_lengths = tree.map_structure(length_in_seconds, signal, hz)\n    shortest_length = min(tree.flatten(signal_lengths))\n    hz_of_shortest_length = tree.flatten(hz)[np.argmin(tree.flatten(signal_lengths))]\n\n    if strict:\n        # reduce shortest_length until it becomes a clearn crop for all other\n        # frequencies\n        i = -1\n        cleancrop = False\n        while not cleancrop:\n            i += 1\n            shortest_length -= i * (1 / hz_of_shortest_length)\n            cleancrop = True\n\n            for each_hz in tree.flatten(hz):\n                if (shortest_length * each_hz) % 1 != 0.0:\n                    cleancrop = False\n                    break\n\n            if i &gt; int(hz_of_shortest_length):\n                warnings.warn(\n                    f\"Must crop more than i={i} and still no clean crop possible.\"\n                )\n\n            if i &gt; 100:\n                break\n\n    if verbose:\n        print(f\"`crop_tail`: Crop off at t={shortest_length}.\")\n\n    def crop(arr, hz):\n        if strict:\n            crop_tail = np.round(shortest_length * hz, decimals=10)\n            err_msg = (\n                f\"No clean crop possible: shortest_length={shortest_length}; hz={hz}\"\n            )\n            assert (crop_tail % 1) == 0.0, err_msg\n            crop_tail = int(crop_tail)\n        else:\n            crop_tail = math.ceil(shortest_length * hz)\n        return arr[:crop_tail]\n\n    return tree.map_structure(crop, signal, hz)\n</code></pre>"},{"location":"api/subpkgs/omc/#x_xy.subpkgs.omc.utils.resample","title":"<code>resample(signal, hz_in, hz_out, quatdetect=True, vecinterp_method='linear')</code>","text":"Source code in <code>x_xy/subpkgs/omc/utils.py</code> <pre><code>def resample(\n    signal: PyTree,\n    hz_in: int | float | PyTree,\n    hz_out: int | float | PyTree,\n    quatdetect: bool = True,\n    vecinterp_method: str = \"linear\",\n) -&gt; PyTree:\n    # int -&gt; float\n    hz_in, hz_out = tree.map_structure(float, (hz_in, hz_out))\n\n    if isinstance(hz_in, float):\n        hz_in = tree.map_structure(lambda _: hz_in, signal)\n    if isinstance(hz_out, float):\n        hz_out = tree.map_structure(lambda _: hz_out, signal)\n\n    def resample_array(signal: np.ndarray, hz_in, hz_out):\n        is1D = False\n        if signal.ndim == 1:\n            is1D = True\n            signal = signal[:, None]\n        assert signal.ndim == 2\n\n        N = signal.shape[0]\n        ts_out = np.arange(N, step=hz_in / hz_out)\n        signal = nanInterp(signal)\n        if quatdetect and signal.shape[1] == 4:\n            signal = quatInterp(signal, ts_out)\n        else:\n            if vecinterp_method == \"linear\":\n                signal = vecInterp(signal, ts_out)\n            elif vecinterp_method == \"cubic\":\n                signal = _cubic_interpolation(signal, ts_out)\n            else:\n                raise NotImplementedError(\n                    \"`vecinterp_method` must be one of ['linear', 'cubic']\"\n                )\n        if is1D:\n            signal = signal[:, 0]\n        return signal\n\n    return tree.map_structure(resample_array, signal, hz_in, hz_out)\n</code></pre>"},{"location":"api/subpkgs/omc/#x_xy.subpkgs.omc.utils.hz_helper","title":"<code>hz_helper(segments, imus=['imu_rigid', 'imu_flex'], markers=[1, 2, 3, 4], hz_imu=40.0, hz_omc=120.0)</code>","text":"Source code in <code>x_xy/subpkgs/omc/utils.py</code> <pre><code>def hz_helper(\n    segments: list[str],\n    imus: list[str] = [\"imu_rigid\", \"imu_flex\"],\n    markers: list[int] = [1, 2, 3, 4],\n    hz_imu: float = 40.0,\n    hz_omc: float = 120.0,\n):\n    hz_in = {}\n    imu_dict = dict(acc=hz_imu, mag=hz_imu, gyr=hz_imu)\n    for seg in segments:\n        hz_in[seg] = {}\n        for imu in imus:\n            hz_in[seg][imu] = imu_dict\n        for marker in markers:\n            hz_in[seg][f\"marker{marker}\"] = hz_omc\n        hz_in[seg][\"quat\"] = hz_omc\n\n    return hz_in\n</code></pre>"},{"location":"api/subpkgs/sim2real/","title":"sim2real","text":""},{"location":"api/subpkgs/sim2real/#x_xy.subpkgs.sim2real.xs_from_raw","title":"<code>xs_from_raw(sys, link_name_pos_rot, eps_frame=None, qinv=False)</code>","text":"<p>Build time-series of maximal coordinates <code>xs</code> from raw position and quaternion trajectory data. This function scans through each link (as defined by <code>sys</code>), looks for the raw data in <code>link_name_pos_rot</code> using the <code>link_name</code> as identifier. It inverts the quaternion if <code>qinv</code>. Then, it creates a <code>Transform</code> that transforms from epsilon (as defined by <code>eps_frame</code>) to the link for each timestep. Finally, it stacks all transforms in order as defined by <code>sys</code> along the 1-th axis. The 0-th axis is time axis.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System which defines ordering of returned <code>xs</code></p> required <code>link_name_pos_rot</code> <code>dict</code> <p>Dictonary of <code>link_name</code> -&gt; {'pos': ..., 'quat': ...}. Obtained, e.g., using <code>process_omc</code>.</p> required <code>eps_frame</code> <code>str</code> <p>Move into this segment's frame at time zero as eps frame. Defaults to <code>None</code>. If <code>None</code>: Don't move into a specific eps-frame.</p> <code>None</code> <p>Returns:</p> Type Description <code>Transform</code> <p>x_xy.base.Transform: Time-series of eps-to-link transformations</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def xs_from_raw(\n    sys: x_xy.base.System,\n    link_name_pos_rot: dict,\n    eps_frame: Optional[str] = None,\n    qinv: bool = False,\n) -&gt; x_xy.base.Transform:\n\"\"\"Build time-series of maximal coordinates `xs` from raw position and\n    quaternion trajectory data. This function scans through each link (as\n    defined by `sys`), looks for the raw data in `link_name_pos_rot` using\n    the `link_name` as identifier. It inverts the quaternion if `qinv`.\n    Then, it creates a `Transform` that transforms from epsilon (as defined\n    by `eps_frame`) to the link for each timestep. Finally, it stacks all\n    transforms in order as defined by `sys` along the 1-th axis. The 0-th\n    axis is time axis.\n\n    Args:\n        sys (x_xy.base.System): System which defines ordering of returned `xs`\n        link_name_pos_rot (dict): Dictonary of `link_name` -&gt;\n            {'pos': ..., 'quat': ...}. Obtained, e.g., using `process_omc`.\n        eps_frame (str, optional): Move into this segment's frame at time zero as\n            eps frame. Defaults to `None`.\n            If `None`: Don't move into a specific eps-frame.\n\n    Returns:\n        x_xy.base.Transform: Time-series of eps-to-link transformations\n    \"\"\"\n    # determine `eps_frame` transform\n    if eps_frame is not None:\n        eps = link_name_pos_rot[eps_frame]\n        q_eps = eps[\"quat\"][0]\n        if qinv:\n            q_eps = x_xy.maths.quat_inv(q_eps)\n        t_eps = x_xy.base.Transform(eps[\"pos\"][0], q_eps)\n    else:\n        t_eps = x_xy.base.Transform.zero()\n\n    # build `xs` from optical motion capture data\n    xs = []\n\n    def f(_, __, link_name: str):\n        q, pos = (\n            link_name_pos_rot[link_name][\"quat\"],\n            link_name_pos_rot[link_name][\"pos\"],\n        )\n        if qinv:\n            q = x_xy.maths.quat_inv(q)\n        t = x_xy.base.Transform(pos, q)\n        t = x_xy.algebra.transform_mul(t, x_xy.algebra.transform_inv(t_eps))\n        xs.append(t)\n\n    scan_sys(sys, f, \"l\", sys.link_names)\n\n    # stack and permute such that time-axis is 0-th axis\n    xs = xs[0].batch(*xs[1:])\n    xs = xs.transpose((1, 0, 2))\n    return xs\n</code></pre>"},{"location":"api/subpkgs/sim2real/#x_xy.subpkgs.sim2real.match_xs","title":"<code>match_xs(sys, xs, sys_xs)</code>","text":"<p>Match tranforms <code>xs</code> to subsystem <code>sys</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Smaller system. Every link in <code>sys</code> must be in <code>sys_xs</code>.</p> required <code>xs</code> <code>Transform</code> <p>Transforms of larger system.</p> required <code>sys_xs</code> <code>Transform</code> <p>Larger system.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Transforms of smaller system.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def match_xs(sys: System, xs: Transform, sys_xs: System) -&gt; Transform:\n\"\"\"Match tranforms `xs` to subsystem `sys`.\n\n    Args:\n        sys (System): Smaller system. Every link in `sys` must be in `sys_xs`.\n        xs (Transform): Transforms of larger system.\n        sys_xs (Transform): Larger system.\n\n    Returns:\n        Transform: Transforms of smaller system.\n    \"\"\"\n    _checks_time_series_of_xs(sys_xs, xs)\n\n    xs_small = xs_from_raw(\n        sys,\n        {\n            name: {\n                \"pos\": xs.pos[:, sys_xs.name_to_idx(name)],\n                \"quat\": xs.rot[:, sys_xs.name_to_idx(name)],\n            }\n            for name in sys_xs.link_names\n        },\n        eps_frame=None,\n        qinv=False,\n    )\n    return xs_small\n</code></pre>"},{"location":"api/subpkgs/sim2real/#x_xy.subpkgs.sim2real.unzip_xs","title":"<code>unzip_xs(sys, xs)</code>","text":"<p>Split eps-to-link transforms into parent-to-child pure translational <code>transform1</code> and pure rotational <code>transform2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Defines scan.tree</p> required <code>xs</code> <code>Transform</code> <p>Eps-to-link transforms</p> required <p>Returns:</p> Type Description <code>Tuple[Transform, Transform]</code> <p>Tuple[Transform, Transform]: transform1, transform2</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def unzip_xs(sys: System, xs: Transform) -&gt; Tuple[Transform, Transform]:\n\"\"\"Split eps-to-link transforms into parent-to-child pure\n    translational `transform1` and pure rotational `transform2`.\n\n    Args:\n        sys (System): Defines scan.tree\n        xs (Transform): Eps-to-link transforms\n\n    Returns:\n        Tuple[Transform, Transform]: transform1, transform2\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    @jax.vmap\n    def _unzip_xs(xs):\n        def f(_, __, i: int, p: int):\n            if p == -1:\n                x_parent_to_link = xs[i]\n            else:\n                x_parent_to_link = algebra.transform_mul(\n                    xs[i], algebra.transform_inv(xs[p])\n                )\n\n            transform1_pos = Transform.create(pos=x_parent_to_link.pos)\n            transform2_rot = Transform.create(rot=x_parent_to_link.rot)\n            return (transform1_pos, transform2_rot)\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_parents)\n\n    return _unzip_xs(xs)\n</code></pre>"},{"location":"api/subpkgs/sim2real/#x_xy.subpkgs.sim2real.zip_xs","title":"<code>zip_xs(sys, xs_transform1, xs_transform2)</code>","text":"<p>Performs forward kinematics using <code>transform1</code> and <code>transform2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Defines scan_sys</p> required <code>xs_transform1</code> <code>Transform</code> <p>Applied before <code>transform1</code></p> required <code>xs_transform2</code> <code>Transform</code> <p>Applied after <code>transform2</code></p> required <p>Returns:</p> Type Description <code>Transform</code> <p>x_xy.base.Transform: Time-series of eps-to-link transformations</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def zip_xs(\n    sys: System,\n    xs_transform1: Transform,\n    xs_transform2: Transform,\n) -&gt; Transform:\n\"\"\"Performs forward kinematics using `transform1` and `transform2`.\n\n    Args:\n        sys (x_xy.base.System): Defines scan_sys\n        xs_transform1 (x_xy.base.Transform): Applied before `transform1`\n        xs_transform2 (x_xy.base.Transform): Applied after `transform2`\n\n    Returns:\n        x_xy.base.Transform: Time-series of eps-to-link transformations\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs_transform1)\n    _checks_time_series_of_xs(sys, xs_transform2)\n\n    @jax.vmap\n    def _zip_xs(xs_transform1, xs_transform2):\n        eps_to_l = {-1: x_xy.base.Transform.zero()}\n\n        def f(_, __, i: int, p: int):\n            transform = algebra.transform_mul(xs_transform2[i], xs_transform1[i])\n            eps_to_l[i] = algebra.transform_mul(transform, eps_to_l[p])\n            return eps_to_l[i]\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_parents)\n\n    return _zip_xs(xs_transform1, xs_transform2)\n</code></pre>"},{"location":"api/subpkgs/sim2real/#x_xy.subpkgs.sim2real.delete_to_world_pos_rot","title":"<code>delete_to_world_pos_rot(sys, xs)</code>","text":"<p>Replace the transforms of all links that connect to the worldbody by unity transforms.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System only used for structure (in scan_sys).</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of modified transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def delete_to_world_pos_rot(sys: System, xs: Transform) -&gt; Transform:\n\"\"\"Replace the transforms of all links that connect to the worldbody\n    by unity transforms.\n\n    Args:\n        sys (System): System only used for structure (in scan_sys).\n        xs (Transform): Time-series of transforms to be modified.\n\n    Returns:\n        Transform: Time-series of modified transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    zero_trafo = Transform.zero((xs.shape(),))\n    for i, p in enumerate(sys.link_parents):\n        if p == -1:\n            xs = _overwrite_transform_of_link_then_update(sys, xs, zero_trafo, i)\n    return xs\n</code></pre>"},{"location":"api/subpkgs/sim2real/#x_xy.subpkgs.sim2real.randomize_to_world_pos_rot","title":"<code>randomize_to_world_pos_rot(key, sys, xs, config)</code>","text":"<p>Replace the transforms of all links that connect to the worldbody by randomize transforms.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Array</code> <p>PRNG Key.</p> required <code>sys</code> <code>System</code> <p>System only used for structure (in scan_sys).</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <code>config</code> <code>RCMG_Config</code> <p>Defines the randomization.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of modified transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def randomize_to_world_pos_rot(\n    key: jax.Array, sys: System, xs: Transform, config: RCMG_Config\n) -&gt; Transform:\n\"\"\"Replace the transforms of all links that connect to the worldbody\n    by randomize transforms.\n\n    Args:\n        key (jax.Array): PRNG Key.\n        sys (System): System only used for structure (in scan_sys).\n        xs (Transform): Time-series of transforms to be modified.\n        config (RCMG_Config): Defines the randomization.\n\n    Returns:\n        Transform: Time-series of modified transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n    assert sys.link_parents.count(-1) == 1, \"Found multiple connections to world\"\n\n    free_sys_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"free\" joint=\"free\"/&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\n    free_sys = load_sys_from_str(free_sys_str)\n    _, xs_free = build_generator(free_sys, config)(key)\n    xs_free = xs_free.take(free_sys.name_to_idx(\"free\"), axis=1)\n    link_idx_to_world = sys.link_parents.index(-1)\n    return _overwrite_transform_of_link_then_update(sys, xs, xs_free, link_idx_to_world)\n</code></pre>"},{"location":"api/subpkgs/sim2real/#x_xy.subpkgs.sim2real.scale_xs","title":"<code>scale_xs(sys, xs, factor, exclude=['px', 'py', 'pz', 'free'])</code>","text":"<p>Increase / decrease transforms by scaling their positional / rotational components based on the systems link type, i.e. the <code>xs</code> should conceptionally be <code>transform2</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System defining structure (for scan_sys)</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <code>factor</code> <code>float</code> <p>Multiplicative factor.</p> required <code>exclude</code> <code>list[str]</code> <p>Skip scaling of transforms if their link_type is one of those. Defaults to [\"px\", \"py\", \"pz\", \"free\"].</p> <code>['px', 'py', 'pz', 'free']</code> <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of scaled transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def scale_xs(\n    sys: System,\n    xs: Transform,\n    factor: float,\n    exclude: list[str] = [\"px\", \"py\", \"pz\", \"free\"],\n) -&gt; Transform:\n\"\"\"Increase / decrease transforms by scaling their positional / rotational\n    components based on the systems link type, i.e. the `xs` should conceptionally\n    be `transform2` objects.\n\n    Args:\n        sys (System): System defining structure (for scan_sys)\n        xs (Transform): Time-series of transforms to be modified.\n        factor (float): Multiplicative factor.\n        exclude (list[str], optional): Skip scaling of transforms if their link_type\n            is one of those. Defaults to [\"px\", \"py\", \"pz\", \"free\"].\n\n    Returns:\n        Transform: Time-series of scaled transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    @jax.vmap\n    def _scale_xs(xs):\n        def f(_, __, i: int, type: str):\n            x_link = xs[i]\n            if type not in exclude:\n                x_link = _scale_transform_based_on_type(x_link, type, factor)\n            return x_link\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_types)\n\n    return _scale_xs(xs)\n</code></pre>"},{"location":"api/subpkgs/sim2real/#x_xy.subpkgs.sim2real.project_xs","title":"<code>project_xs(sys, transform2)</code>","text":"<p>Project transforms into the physically feasible subspace as defined by the joints in the system.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def project_xs(sys: System, transform2: Transform) -&gt; Transform:\n\"\"\"Project transforms into the physically feasible subspace as defined by the\n    joints in the system.\"\"\"\n    _checks_time_series_of_xs(sys, transform2)\n\n    _str2idx = {\"x\": 0, \"y\": 1, \"z\": 2}\n\n    @jax.vmap\n    def _project_xs(transform2):\n        def f(_, __, i: int, link_type: str, joint_params: jax.Array):\n            t = transform2[i]\n            rot, pos = jnp.array([1.0, 0, 0, 0]), jnp.zeros((3,))\n\n            if link_type in [\"rx\", \"ry\", \"rz\"]:\n                angles = maths.quat_to_euler(t.rot)\n                idx = _str2idx[link_type[1]]\n                proj_angles = jnp.zeros((3,)).at[idx].set(angles[idx])\n                rot = maths.euler_to_quat(proj_angles)\n            elif link_type in [\"px\", \"py\", \"pz\"]:\n                idx = _str2idx[link_type[1]]\n                pos = pos.at[idx].set(t.pos[idx])\n            elif link_type == \"spherical\":\n                rot = t.rot\n            elif link_type in [\"p3d\", \"cor\"]:\n                pos = t.pos\n            elif link_type == \"free\":\n                pos, rot = t.pos, t.rot\n            # TODO; Consider removing the case of `rr` and `rr_imp`\n            # after all these joints are not part of the standard library\n            elif link_type == \"rr\":\n                assert joint_params.shape == (3,)\n                rot = maths.quat_project(t.rot, joint_params)\n            elif link_type == \"rr_imp\":\n                assert joint_params.shape == (6,)\n                warnings.warn(\"`rr_imp` cannot be projected.\")\n                rot = t.rot\n            elif link_type == \"frozen\":\n                pass\n            else:\n                raise NotImplementedError\n            return Transform(pos=pos, rot=rot)\n\n        return scan_sys(\n            sys,\n            f,\n            \"lll\",\n            list(range(sys.num_links())),\n            sys.link_types,\n            sys.links.joint_params,\n        )\n\n    return _project_xs(transform2)\n</code></pre>"},{"location":"api/subpkgs/sys_composer/","title":"sys_composer","text":""},{"location":"api/subpkgs/sys_composer/#x_xy.subpkgs.sys_composer.delete_sys.delete_subsystem","title":"<code>delete_subsystem(sys, link_name)</code>","text":"<p>Cut subsystem starting at <code>link_name</code> (inclusive) from tree.</p> Source code in <code>x_xy/subpkgs/sys_composer/delete_sys.py</code> <pre><code>def delete_subsystem(sys: base.System, link_name: str | list[str]) -&gt; base.System:\n    \"Cut subsystem starting at `link_name` (inclusive) from tree.\"\n    if isinstance(link_name, list):\n        for ln in link_name:\n            sys = delete_subsystem(sys, ln)\n        return sys\n\n    assert (\n        link_name in sys.link_names\n    ), f\"link {link_name} not found in {sys.link_names}\"\n\n    subsys = _find_subsystem_indices(sys.link_parents, sys.name_to_idx(link_name))\n    idx_map, keep = _idx_map_and_keepers(sys.link_parents, subsys)\n\n    def take(list):\n        return [ele for i, ele in enumerate(list) if i in keep]\n\n    d, a, ss, sz = [], [], [], []\n\n    def filter_arrays(_, __, damp, arma, stiff, zero, i: int):\n        if i in keep:\n            d.append(damp)\n            a.append(arma)\n            ss.append(stiff)\n            sz.append(zero)\n\n    scan_sys(\n        sys,\n        filter_arrays,\n        \"dddql\",\n        sys.link_damping,\n        sys.link_armature,\n        sys.link_spring_stiffness,\n        sys.link_spring_zeropoint,\n        list(range(sys.num_links())),\n    )\n\n    d, a, ss, sz = map(jnp.concatenate, (d, a, ss, sz))\n\n    new_sys = base.System(\n        link_parents=_reindex_parent_array(sys.link_parents, subsys),\n        links=tree_utils.tree_indices(sys.links, jnp.array(keep, dtype=int)),\n        link_types=take(sys.link_types),\n        link_damping=d,\n        link_armature=a,\n        link_spring_stiffness=ss,\n        link_spring_zeropoint=sz,\n        dt=sys.dt,\n        geoms=[\n            geom.replace(link_idx=idx_map[geom.link_idx])\n            for geom in sys.geoms\n            if geom.link_idx in keep\n        ],\n        gravity=sys.gravity,\n        integration_method=sys.integration_method,\n        mass_mat_iters=sys.mass_mat_iters,\n        link_names=take(sys.link_names),\n        model_name=sys.model_name,\n    )\n\n    return parse_system(new_sys)\n</code></pre>"},{"location":"api/subpkgs/sys_composer/#x_xy.subpkgs.sys_composer.delete_sys.make_sys_noimu","title":"<code>make_sys_noimu(sys, imu_link_names=None)</code>","text":"<p>Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'}</p> Source code in <code>x_xy/subpkgs/sys_composer/delete_sys.py</code> <pre><code>def make_sys_noimu(sys: x_xy.System, imu_link_names: Optional[list[str]] = None):\n    \"Returns, e.g., imu_attachment = {'imu1': 'seg1', 'imu2': 'seg3'}\"\n    if imu_link_names is None:\n        imu_link_names = _autodetermine_imu_names(sys)\n    imu_attachment = {name: sys.parent_name(name) for name in imu_link_names}\n    sys_noimu = delete_subsystem(sys, imu_link_names)\n    return sys_noimu, imu_attachment\n</code></pre>"},{"location":"api/subpkgs/sys_composer/#x_xy.subpkgs.sys_composer.inject_sys.inject_system","title":"<code>inject_system(sys, sub_sys, at_body=None)</code>","text":"<p>Combine two systems into one.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Large system.</p> required <code>sub_sys</code> <code>System</code> <p>Small system that will be included into the large system <code>sys</code>.</p> required <code>at_body</code> <code>Optional[str]</code> <p>Into which body of the large system small system will be included. Defaults to <code>worldbody</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>System</code> <p>base.System: description</p> Source code in <code>x_xy/subpkgs/sys_composer/inject_sys.py</code> <pre><code>def inject_system(\n    sys: base.System,\n    sub_sys: base.System,\n    at_body: Optional[str] = None,\n) -&gt; base.System:\n\"\"\"Combine two systems into one.\n\n    Args:\n        sys (base.System): Large system.\n        sub_sys (base.System): Small system that will be included into the\n            large system `sys`.\n        at_body (Optional[str], optional): Into which body of the large system\n            small system will be included. Defaults to `worldbody`.\n\n    Returns:\n        base.System: _description_\n    \"\"\"\n\n    # replace parent array\n    if at_body is None:\n        new_world = -1\n    else:\n        new_world = sys.name_to_idx(at_body)\n\n    # append sub_sys at index end and replace sub_sys world with `at_body`\n    N = sys.num_links()\n\n    def new_parent(old_parent: int):\n        if old_parent != -1:\n            return old_parent + N\n        else:\n            return new_world\n\n    sub_sys = sub_sys.replace(\n        link_parents=[new_parent(p) for p in sub_sys.link_parents]\n    )\n\n    # replace link indices of geoms in sub_sys\n    sub_sys = sub_sys.replace(\n        geoms=[\n            geom.replace(link_idx=new_parent(geom.link_idx)) for geom in sub_sys.geoms\n        ]\n    )\n\n    # merge two systems\n    concat = lambda a1, a2: tree_batch([a1, a2], True, \"jax\")\n    combined_sys = base.System(\n        link_parents=sys.link_parents + sub_sys.link_parents,\n        links=concat(sys.links, sub_sys.links),\n        link_types=sys.link_types + sub_sys.link_types,\n        link_damping=concat(sys.link_damping, sub_sys.link_damping),\n        link_armature=concat(sys.link_armature, sub_sys.link_armature),\n        link_spring_stiffness=concat(\n            sys.link_spring_stiffness, sub_sys.link_spring_stiffness\n        ),\n        link_spring_zeropoint=concat(\n            sys.link_spring_zeropoint, sub_sys.link_spring_zeropoint\n        ),\n        dt=sys.dt,\n        geoms=sys.geoms + sub_sys.geoms,\n        gravity=sys.gravity,\n        integration_method=sys.integration_method,\n        mass_mat_iters=sys.mass_mat_iters,\n        link_names=sys.link_names + sub_sys.link_names,\n        model_name=sys.model_name,\n    )\n\n    return parse_system(combined_sys)\n</code></pre>"},{"location":"api/subpkgs/sys_composer/#x_xy.subpkgs.sys_composer.morph_sys.morph_system","title":"<code>morph_system(sys, new_parents)</code>","text":"<p>Re-orders the graph underlying the system. Returns a new system.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System to be modified.</p> required <code>new_parents</code> <code>list[int]</code> <p>Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system.</p> required <p>Returns:</p> Type Description <code>System</code> <p>base.System: Modified system.</p> Source code in <code>x_xy/subpkgs/sys_composer/morph_sys.py</code> <pre><code>def morph_system(sys: base.System, new_parents: list[int | str]) -&gt; base.System:\n\"\"\"Re-orders the graph underlying the system. Returns a new system.\n\n    Args:\n        sys (base.System): System to be modified.\n        new_parents (list[int]): Let the i-th entry have value j. Then, after morphing\n            the system the system will be such that the link corresponding to the i-th\n            link in the old system will have as parent the link corresponding to the\n            j-th link in the old system.\n\n    Returns:\n        base.System: Modified system.\n    \"\"\"\n    assert len(new_parents) == sys.num_links()\n\n    structure, permutation, new_parent_array = identify_system(sys, new_parents)\n\n    sys, new_transform1 = _new_transform1(sys, permutation, structure, True, True)\n\n    def _new_pos_min_max(old_pos_min_max):\n        new_pos_min_max = []\n        for link_idx_old_indices in range(sys.num_links()):\n            node = structure[link_idx_old_indices]\n            if node.parent_changed and node.new_parent_old_indices != -1:\n                grandparent = structure[\n                    node.new_parent_old_indices\n                ].new_parent_old_indices\n                if grandparent != -1:\n                    use = grandparent\n                else:\n                    # in this case we will always move the cs into the cs that connects\n                    # to -1; thus the `pos_mod` will always be zeros no matter what we\n                    # `use`\n                    use = None\n            else:\n                use = link_idx_old_indices\n\n            if use is not None:\n                pos_min_max_using_one = sys.links.transform1.pos.at[use].set(\n                    old_pos_min_max[use]\n                )\n            else:\n                pos_min_max_using_one = sys.links.transform1.pos\n\n            sys_mod = sys.replace(\n                links=sys.links.replace(\n                    transform1=sys.links.transform1.replace(pos=pos_min_max_using_one)\n                )\n            )\n\n            # break early because we only use the value of `link_idx_old_indices` anways\n            pos_mod = _new_transform1(\n                sys_mod, permutation, structure, breakearly=link_idx_old_indices\n            )[1][link_idx_old_indices].pos\n\n            new_pos_min_max.append(pos_mod)\n        return jnp.vstack(new_pos_min_max)\n\n    new_pos_min_unsorted = _new_pos_min_max(sys.links.pos_min)\n    new_pos_max_unsorted = _new_pos_min_max(sys.links.pos_max)\n    new_pos_min = jnp.where(\n        new_pos_min_unsorted &gt; new_pos_max_unsorted,\n        new_pos_max_unsorted,\n        new_pos_min_unsorted,\n    )\n    new_pos_max = jnp.where(\n        new_pos_max_unsorted &lt; new_pos_min_unsorted,\n        new_pos_min_unsorted,\n        new_pos_max_unsorted,\n    )\n    links = sys.links.replace(\n        transform1=new_transform1, pos_min=new_pos_min, pos_max=new_pos_max\n    )\n\n    def _permute(obj):\n        if isinstance(obj, (base._Base, jax.Array)):\n            return obj[jnp.array(permutation, dtype=jnp.int32)]\n        elif isinstance(obj, list):\n            return [obj[permutation[i]] for i in range(len(obj))]\n        assert False\n\n    _joint_properties = _permute(_swapped_joint_properties(sys, structure))\n    stack_joint_properties = lambda i: jnp.concatenate(\n        [link[i] for link in _joint_properties]\n    )\n\n    morphed_system = base.System(\n        link_parents=new_parent_array,\n        links=_permute(links).replace(\n            joint_params=jnp.vstack([link[5] for link in _joint_properties])\n        ),\n        link_types=[link[4] for link in _joint_properties],\n        link_damping=stack_joint_properties(0),\n        link_armature=stack_joint_properties(1),\n        link_spring_stiffness=stack_joint_properties(2),\n        link_spring_zeropoint=stack_joint_properties(3),\n        dt=sys.dt,\n        geoms=_permute_modify_geoms(sys.geoms, structure),\n        gravity=sys.gravity,\n        integration_method=sys.integration_method,\n        mass_mat_iters=sys.mass_mat_iters,\n        link_names=_permute(sys.link_names),\n        model_name=sys.model_name,\n    )\n\n    return parse_system(morphed_system)\n</code></pre>"},{"location":"notebooks/batched_simulation/","title":"Batched simulation","text":"<p>This example is available as a jupyter notebook here.</p> <p><code>System</code> object is a registered Jax-PyTree. This means it's a nested array.</p> <p>This enables us to stack multiple systems (or states) to enable vectorized operations.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\n\n\nxml_str = \"\"\"\n&lt;x_xy model=\"double_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"upper\" euler=\"0 90 0\" joint=\"ry\" damping=\"2\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"lower\" pos=\"1 0 0\" joint=\"ry\" damping=\"2\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nstate = x_xy.State.create(sys)\n</code></pre> <pre><code># second system with gravity disabled\nsys_nograv = sys.replace(gravity = sys.gravity * 0.0)\nsys_batched = sys.batch(sys_nograv)\n\nnext_state_batched = jax.vmap(x_xy.step, in_axes=(0, None))(sys_batched, state)\n</code></pre> <pre><code># note how the state of the system without gravity has not changed at all\nnext_state_batched.q\n</code></pre> <pre>\n<code>Array([[-1.7982468e-10,  2.3305433e-10],\n       [ 0.0000000e+00,  0.0000000e+00]], dtype=float32)</code>\n</pre> <pre><code>second_state = x_xy.State.create(sys, qd=jnp.ones((2,)))\nstate_batched = state.batch(second_state)\nnext_state_batched = jax.vmap(x_xy.step, in_axes=(None, 0))(sys, state_batched)\n</code></pre> <pre><code>next_state_batched.q\n</code></pre> <pre>\n<code>Array([[-1.7982468e-10,  2.3305433e-10],\n       [ 1.0048340e-02,  9.8215193e-03]], dtype=float32)</code>\n</pre> <p>Batched kinematic simulation is done using either <code>x_xy.batch_generators_eager</code> or <code>x_xy.batch_generators_lazy</code>.</p> <pre><code>gen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nbatchsize = 8\ngen_batched = x_xy.batch_generators_lazy(gen, batchsizes=batchsize)\nseed = 1\nqs, xs = gen_batched(jax.random.PRNGKey(seed))\n</code></pre> <pre><code>qs.shape\n</code></pre> <pre>\n<code>(8, 1000, 2)</code>\n</pre> <pre><code>\n</code></pre>"},{"location":"notebooks/batched_simulation/#batched-dynamical-simulation","title":"Batched Dynamical Simulation","text":""},{"location":"notebooks/batched_simulation/#batched-system","title":"Batched System","text":"<p>I.e. simulating two different system with the same initial state.</p>"},{"location":"notebooks/batched_simulation/#batched-state","title":"Batched State","text":""},{"location":"notebooks/batched_simulation/#batched-kinematic-simulation","title":"Batched Kinematic Simulation","text":""},{"location":"notebooks/control/","title":"Control","text":"<p>This example is available as a jupyter notebook here.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\n</code></pre> <p>The <code>step</code> function also takes generalized forces <code>tau</code> applied to the degrees of freedom its third input <code>step(sys, state, taus)</code>.</p> <p>Let's consider an inverted pendulum on a cart, and apply a left-right force onto the cart such that the pole stays in the upright position.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"inv_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;defaults&gt;\n        &lt;geom edge_color=\"black\" color=\"white\"/&gt;\n    &lt;/defaults&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"cart\" joint=\"px\" damping=\"0.01\"&gt;\n            &lt;geom type=\"box\" mass=\"1\" dim=\"0.4 0.1 0.1\"/&gt;\n            &lt;body name=\"pendulum\" joint=\"ry\" euler=\"0 -90 0\" damping=\"0.01\"&gt;\n                &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.5 0 0\" dim=\"1 0.1 0.1\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nstate = x_xy.State.create(sys, q=jnp.array([0.0, 0.2])) \n\nxs = []\nT = 10.0\nfor t in range(int(T / sys.dt)):\n    measurement_noise = np.random.normal() * 5\n    phi = jnp.rad2deg(state.q[1]) + measurement_noise\n    cart_motor_input = 0.1 * phi * abs(phi)\n    taus = jnp.clip(jnp.array([cart_motor_input, 0.0]), -10, 10) \n    state = jax.jit(x_xy.step)(sys, state, taus)\n    xs.append(state.x)\n</code></pre> <pre><code>def show_video(sys, xs: list[x_xy.Transform]):\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render(sys, [xs[i] for i in range(0, len(xs), 4)], camera=\"c\", add_cameras={-1: '&lt;camera name=\"c\" mode=\"targetbody\" target=\"0\" pos=\"0 -2 2\"/&gt;'})\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01&lt;00:00, 242.17it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>xml_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"pendulum\" joint=\"ry\" euler=\"0 90 0\" damping=\"0.01\" pos=\"0 0 1\"&gt;\n            &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.5 0 0\" dim=\"1 0.1 0.1\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nP, D = jnp.array([10.0]), jnp.array([1.0])\n\ndef simulate_pd_control(sys, P, D):\n    controller = x_xy.pd_control(P, D)\n    # reference signal\n    q_ref = jnp.ones((1000, 1)) * jnp.pi / 2\n    controller_state = controller.init(sys, q_ref)\n    state = x_xy.State.create(sys) \n\n    xs = []\n    T = 5.0\n    for t in range(int(T / sys.dt)):\n        controller_state, taus = jax.jit(controller.apply)(controller_state, sys, state)\n        state = jax.jit(x_xy.step)(sys, state, taus)\n        xs.append(state.x)\n    return xs\n</code></pre> <pre><code>xs = simulate_pd_control(sys, P, D)\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00&lt;00:00, 254.63it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Note the steady state error. This is because we have gravity and no Integral part (so no PID control).</p> <p>If we remove gravity the steady state error also vanishes (as is expected.)</p> <pre><code>sys_nograv = sys.replace(gravity = sys.gravity * 0.0)\nxs = simulate_pd_control(sys_nograv, P, D)\nshow_video(sys_nograv, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00&lt;00:00, 248.42it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/control/#balance-an-inverted-pendulum-on-a-cart","title":"Balance an inverted Pendulum on a cart","text":""},{"location":"notebooks/control/#pd-control","title":"PD Control","text":""},{"location":"notebooks/custom_joint_type/","title":"Custom joint type","text":"<p>This example is available as a jupyter notebook here.</p> <p>In this notebook we will define a new joint type that is a hinge joint with a random joint axes direction.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\n\nimport mediapy as media\n</code></pre> <p>We will give this new joint type the identifier <code>rr</code> (random revolute).</p> <pre><code>from x_xy.algorithms.jcalc import _draw_rxyz\n\n\n# we use this `params` input to specify the joint-axes, if we later then randomize the attribute of the system object\n# we will have the effect of a hinge joint with a randomized joint axes direction\n\n# set the dimensionality of the attribute to 3 for each joint / link in the system.\n# This is save because the library itself does not use this attribute at all\nx_xy.base.update_n_joint_params(3)\n\ndef _rr_transform(q, params):\n    axis = params\n    q = jnp.squeeze(q)\n    rot = x_xy.maths.quat_rot_axis(axis, q)\n    return x_xy.Transform.create(rot=rot)\n\n# we don't specify the motion vectors; They are required for dynamic simulation\nrr_joint = x_xy.JointModel(_rr_transform, rcmg_draw_fn=_draw_rxyz)\n\n# qd_width is zero because we have not specified the motion vectors\nx_xy.register_new_joint_type(\"rr\", rr_joint, q_width=1, qd_width=0)\n</code></pre> <pre><code>xml_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"pendulum\" joint=\"rr\"&gt;\n            &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.25 0 0\" dim=\"0.5 0.1 0.1\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n</code></pre> <pre><code>def setup_fn_randomize_joint_axes(key, sys: x_xy.System) -&gt; x_xy.System:\n    \"Randomizes the `sys.links.joint_params` attribute, which is used as joint-axis direction.\"\n    @jax.vmap\n    def _draw_random_joint_axis(key):\n        return x_xy.maths.rotate(jnp.array([1.0, 0, 0]), x_xy.maths.quat_random(key))\n\n    joint_axes = _draw_random_joint_axis(jax.random.split(key, sys.num_links()))\n    return sys.replace(links=sys.links.replace(joint_params=joint_axes))\n\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, ang0_min=0.0, ang0_max=0.0), \n                           setup_fn=setup_fn_randomize_joint_axes)\n_, xs = gen(jax.random.PRNGKey(1))\n</code></pre> <pre><code>def show_video(sys, xs: x_xy.Transform):\n    # right now `xs` is a batched `Transform` object\n    # so convert to a list of unbatched `Transform` object which is what `render_frames` expects.\n    xs = [xs[i] for i in range(xs.shape())]\n\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render(sys, [xs[i] for i in range(0, len(xs), 4)], camera=\"target\")\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:00&lt;00:00, 265.98it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>And now with a different seed, the joint axis (and motion) is different.</p> <pre><code>_, xs = gen(jax.random.PRNGKey(3))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:00&lt;00:00, 277.61it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/custom_joint_type/#defining-a-custom-joint-type","title":"Defining a custom Joint Type","text":""},{"location":"notebooks/custom_joint_type_dynamics/","title":"Custom joint type dynamics","text":"<p>This example is available as a jupyter notebook here.</p> <p>In this notebook we will define a new joint type that is a hinge joint with a random joint axes direction.</p> <p>It will also support dynamical simulation.</p> <pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\n\nimport mediapy as media\n</code></pre> <p>We will give this new joint type the identifier <code>rr</code> (random revolute).</p> <pre><code>from x_xy.algorithms.jcalc import _draw_rxyz\n\n# we use this `params` input to specify the joint-axes, if we later then randomize the attribute of the system object\n# we will have the effect of a hinge joint with a randomized joint axes direction\n\n# set the dimensionality of the attribute to 3 for each joint / link in the system.\n# This is save because the library itself does not use this attribute at all\nx_xy.base.update_n_joint_params(3)\n\ndef _rr_transform(q, params):\n    axis = params\n    q = jnp.squeeze(q)\n    rot = x_xy.maths.quat_rot_axis(axis, q)\n    return x_xy.Transform.create(rot=rot)\n\ndef _motion_fn(params):\n    return x_xy.base.Motion.create(ang=params)\n\n# here we do specify the motion vectors\nrr_joint = x_xy.JointModel(_rr_transform, motion=[_motion_fn], rcmg_draw_fn=_draw_rxyz)\n\n# we register the joint; Note that qd_width is not zero now, but rather one\nx_xy.register_new_joint_type(\"rr\", rr_joint, q_width=1, qd_width=1)\n</code></pre> <pre><code>xml_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;geom type=\"xyz\" dim=\"0.1\"/&gt;\n        &lt;body name=\"pendulum\" joint=\"rr\" pos=\"0 0 0.5\" damping=\".01\"&gt;\n            &lt;geom type=\"xyz\" dim=\"0.1\"/&gt;\n            &lt;geom type=\"box\" mass=\"0.5\" pos=\"0.25 0 0\" dim=\"0.5 0.1 0.1\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\nsys = sys.replace(links=sys.links.replace(joint_params = x_xy.maths.safe_normalize(jnp.array([[0, 1.0, -1.0]]))))\n</code></pre> <pre><code>state = x_xy.State.create(sys)\nxs = []\nfor t in range(500):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n</code></pre> <pre><code>def show_video(sys, xs: x_xy.Transform):\n    frames = x_xy.render(sys, [xs[i] for i in range(0, len(xs), 4)], camera=None)\n    media.show_video(frames, fps=25)\n\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 125/125 [00:00&lt;00:00, 130.50it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/custom_joint_type_dynamics/#defining-a-custom-joint-type-that-supports-dynamical-simulation","title":"Defining a custom Joint Type that supports dynamical simulation","text":""},{"location":"notebooks/error_quaternion/","title":"Error quaternion","text":"<p>In this notebook we will talk about what functions you need to do ML with quaternions. After all the purpose of this library is to create training data.</p> <p>Typically, this involves quaternions as target values (to be predicted), similar to an orientation estimation filter (like VQF).</p> <p>So, suppose you want to train some ML model that predicts a quaternion \\(\\hat{q} = f_\\theta(X)\\).</p> <pre><code>import x_xy\nimport jax \nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n</code></pre> <pre><code># suppose a 6D IMU input\nfeature_dim = 6\n\nparams = jax.random.normal(jax.random.PRNGKey(1), (4, feature_dim))\ndef neural_network(params, X):\n    q_unnormalized = params@X\n    norm = jnp.linalg.norm(q_unnormalized)\n    return q_unnormalized / norm\n\n\ndef loss_fn(params, X, y):\n    q, qhat = y, neural_network(params, X)\n    # squared angle error\n    return x_xy.maths.angle_error(q, qhat)**2\n</code></pre> <p>But this is dangerous as this might lead to NaNs.</p> <pre><code>X = jnp.zeros((6,))\ny = jnp.array([1.0, 0, 0, 0])\nloss_fn(params, X, y)\n</code></pre> <pre>\n<code>Array(nan, dtype=float32)</code>\n</pre> <p>We could try to fix is by adding a small number in the divison.</p> <pre><code># suppose a 6D IMU input\nfeature_dim = 6\n\nparams = jax.random.normal(jax.random.PRNGKey(1), (4, feature_dim))\ndef neural_network(params, X):\n    q_unnormalized = params@X\n    norm = jnp.linalg.norm(q_unnormalized)\n    eps = 1e-8\n    return q_unnormalized / (norm + eps)\n\n\ndef loss_fn(params, X, y):\n    q, qhat = y, neural_network(params, X)\n    # squared angle error\n    return x_xy.maths.angle_error(q, qhat)**2\n\nX = jnp.zeros((6,))\ny = jnp.array([1.0, 0, 0, 0])\nloss_fn(params, X, y)\n</code></pre> <pre>\n<code>Array(0., dtype=float32)</code>\n</pre> <p>But, still the gradient required for backpropagation gives NaNs.</p> <pre><code>jax.grad(loss_fn)(params, X, y)\n</code></pre> <pre>\n<code>Array([[nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan]], dtype=float32)</code>\n</pre> <p>The solution is a little involved. TLDR; Use <code>x_xy.maths.safe_normalize</code></p> <pre><code># suppose a 6D IMU input\nfeature_dim = 6\n\nparams = jax.random.normal(jax.random.PRNGKey(1), (4, feature_dim))\ndef neural_network(params, X):\n    q_unnormalized = params@X\n    return x_xy.maths.safe_normalize(q_unnormalized)\n\n\ndef loss_fn(params, X, y):\n    q, qhat = y, neural_network(params, X)\n    # squared angle error\n    return x_xy.maths.angle_error(q, qhat)**2\n\nX = jnp.zeros((6,))\ny = jnp.array([1.0, 0, 0, 0])\nloss_fn(params, X, y)\n</code></pre> <pre>\n<code>Array(0., dtype=float32)</code>\n</pre> <pre><code>jax.grad(loss_fn)(params, X, y)\n</code></pre> <pre>\n<code>Array([[0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.]], dtype=float32)</code>\n</pre> <p>Let's take a closer look at the function <code>x_xy.maths.angle_error</code> which was used in the <code>loss_fn</code> in the above.</p> <p>What is the behaviour of the error function (sort of the metric) between two quaternions as one approaches the other?</p> <p>A first implementation might look like this:</p> <pre><code>def quat_error(q, qhat):\n    q_error = x_xy.maths.quat_mul(x_xy.maths.quat_inv(q), qhat)\n    phi = 2 * jnp.arccos(q_error[0])\n    return jnp.abs(phi)\n</code></pre> <p>Let's reduce this function to the critical operation <code>phi = ...</code> and let's assume, without loss of generality, that the target quaternion is the identity quaternion.</p> <p>Then, this effectively becomes about extracting the angle from a quaternion safely.</p> <pre><code>def quat_angle(q):\n    return 2 * jnp.arccos(q[0])\n</code></pre> <pre><code>input_angles = jnp.linspace(-0.005, 0.005, num=1000)\n\ndef input_to_output_angles_incorrect(angle):\n    q = x_xy.maths.quat_rot_axis(jnp.array([1.0, 0, 0]), angle)\n    return quat_angle(q)\n\ndef input_to_output_angles_correct(angle):\n    q = x_xy.maths.quat_rot_axis(jnp.array([1.0, 0, 0]), angle)\n    return x_xy.maths.quat_angle(q)\n</code></pre> <pre><code>plt.plot(input_angles, jax.vmap(input_to_output_angles_incorrect)(input_angles), label=\"incorrect\")\nplt.plot(input_angles, jax.vmap(input_to_output_angles_correct)(input_angles), label=\"correct\")\nplt.legend()\nplt.show()\n</code></pre> <p>As one might expect, the gradients are also much more stable.</p> <pre><code>plt.plot(input_angles, jax.vmap(jax.grad(input_to_output_angles_incorrect))(input_angles), label=\"incorrect\")\nplt.plot(input_angles, jax.vmap(jax.grad(input_to_output_angles_correct))(input_angles), label=\"correct\")\nplt.legend()\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"notebooks/error_quaternion/#the-error-quaternion-required-for-ml-purposes","title":"The error quaternion (required for ML purposes)","text":""},{"location":"notebooks/error_quaternion/#how-to-get-a-quaternion-as-network-output","title":"How to get a quaternion as network output?","text":"<p>That's easy enough. You normalize a four dimensional vector.</p>"},{"location":"notebooks/error_quaternion/#a-closer-look-at-the-function-x_xymathsangle_error","title":"A closer look at the function <code>x_xy.maths.angle_error</code>","text":""},{"location":"notebooks/error_quaternion/#pytorch-library-for-quaternion-operations","title":"Pytorch library for quaternion operations","text":"<p>These functions are for JAX, but the following should work for PyTorch -&gt; https://naver.github.io/roma/</p>"},{"location":"notebooks/experimental_data/","title":"Experimental data","text":"<pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\n\ndef show_video(sys, xs: x_xy.Transform) -&gt; None:\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render(sys, [xs[i] for i in range(0, xs.shape(), 4)], camera=\"c\",\n                         height=480, width=640, add_cameras={-1: '&lt;camera name=\"c\" mode=\"targetbody\" target=\"3\" pos=\".5 -.5 1.25\"/&gt;'})\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n</code></pre> <p>Experimental data and system definitions of the experimental setup are located in the sub-package <code>exp_data</code></p> <pre><code>from x_xy.subpkgs import exp\n</code></pre> <p>Multiple experimental trials will be made available. Right now only the trial with identifiers <code>S_04/6</code> is available.</p> <pre><code>exp_id = \"S_06\"\nsys = exp.load_sys(exp_id)\n</code></pre> <p>Let's first take a look at the system that was used in the experiments.</p> <pre><code>state = x_xy.State.create(sys)\n# update the maximal coordinates\nxs = x_xy.forward_kinematics(sys, state)[1].x.batch()\n</code></pre> <pre><code>show_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 48.62it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>As you can see a five segment kinematic chain was moved, and for each segment IMU measurements and OMC ground truth is available.</p> <p>Let's load this (no simulated) IMU and OMC data.</p> <pre><code># `canonical` is the identifier of the first motion pattern performed in this trial\n# `shaking` is the identifier of the last motion pattern performed in this trial\ndata = exp.load_data(exp_id, motion_start=\"canonical\", motion_stop=\"shaking\")\n</code></pre> <pre><code>data.keys()\n</code></pre> <pre>\n<code>dict_keys(['seg1', 'seg2', 'seg3', 'seg4', 'seg5'])</code>\n</pre> <pre><code>data[\"seg1\"].keys()\n</code></pre> <pre>\n<code>dict_keys(['imu_flex', 'imu_rigid', 'marker1', 'marker2', 'marker3', 'marker4', 'quat'])</code>\n</pre> <pre><code>data[\"seg1\"][\"imu_rigid\"].keys()\n</code></pre> <pre>\n<code>dict_keys(['acc', 'gyr', 'mag'])</code>\n</pre> <p>The quaternion <code>quat</code> is to be interpreted as the rotation from segment to an arbitrary OMC inertial frame.</p> <p>The position <code>marker1</code> is to be interpreted as the position vector from arbitrary OMC inertial frame to a specific marker (marker 1) on the respective segment (vector given in the OMC inertial frame).</p> <p>Then, for each segment actually two IMUs are attached to it. One is rigidly attached, one is non-rigidly attached (via foam).</p> <p>Also, how long is the trial?</p> <pre><code>data[\"seg1\"][\"marker1\"].shape\n</code></pre> <pre>\n<code>(32500, 3)</code>\n</pre> <p>It's 325 seconds of data.</p> <p>Let's take a look at the motion of the whole trial.</p> <p>To render it, we need maximal coordinates <code>xs</code> of all links in the system. Luckily, there exists a function inside sub-package <code>sim2real</code> that does this already (but please check out the source).</p> <pre><code>from x_xy.subpkgs import sim2real\n\n# this function is required because we have four markers per segment, so four positions\n# that we could use as the position of the frame for that segment. Inside the xml string\n# there is at the bottom comments that define which marker should be used for which segment\n# because they are close\nlink_name_pos_rot = exp.link_name_pos_rot_data(data, exp.load_xml_str(\"S_06\"))\n\nxs = sim2real.xs_from_raw(sys, link_name_pos_rot, qinv=True)\n</code></pre> <pre><code>show_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 8125/8125 [00:57&lt;00:00, 142.21it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Perfect. This is a rendered animation of the real experimental motion that was performed. You can see that the spacing between segments is not perfect.</p> <p>This is because in our idealistic system model joints have no spatial dimension but in reality they have. The entire setup is 3D printed, and the joints are also several centimeters long.</p> <p>The segments are 20cm long.</p> <p>We can use this experimental data to validate our simulated approaches or validate ML models that are learned on simulated training data.</p> <pre><code>\n</code></pre>"},{"location":"notebooks/experimental_data/#loading-and-working-with-experimental-data","title":"Loading and working with experimental data","text":""},{"location":"notebooks/getting_started/","title":"Getting started","text":"<p>This example is available as a jupyter notebook here.</p> <p>And on Google Colab here</p> <p>Setup the environment if this is executed on Google Colab.</p> <p>Make sure to change the runtime type to <code>GPU</code>. To do this go to <code>Runtime</code> -&gt; <code>Change runtime type</code> -&gt; <code>GPU</code></p> <p>Otherwise, rendering won't work in Google Colab.</p> <pre><code>import os\n\ntry:\n    import google.colab\n    IN_COLAB = True\nexcept:\n    IN_COLAB = False\n\nif IN_COLAB:\n    os.system(\"pip install --quiet 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'\")\n    os.system(\"pip install --quiet mediapy\")\n    os.system(\"pip install --quiet matplotlib\")\n</code></pre> <pre><code>import x_xy\n# automatically detects colab or not\nx_xy.utils.setup_colab_env()\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\n</code></pre> <p>Systems are defined with the following xml syntax.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"double_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"upper\" euler=\"0 90 0\" joint=\"ry\" damping=\"2\" pos=\"0 0 2\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"lower\" pos=\"1 0 0\" joint=\"ry\" damping=\"2\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n</code></pre> <p>With this xml description of the system, we are ready to load the system using <code>load_sys_from_str</code>. We can also save this to a text-file <code>double_pendulum.xml</code> and load with <code>load_sys_from_xml</code>.</p> <pre><code>sys = x_xy.load_sys_from_str(xml_str)\n</code></pre> <pre><code>sys.model_name\n</code></pre> <pre>\n<code>'double_pendulum'</code>\n</pre> <p>System objects have many attributes. You may refer to the API documentation for more details.</p> <pre><code>sys.link_names\n</code></pre> <pre>\n<code>['upper', 'lower']</code>\n</pre> <p>Let's start with the most obvious. A physical simulation. We refer to it as \"dynamical simulation\", in contrast to what we do a little later which is a purely kinematic simulation.</p> <p>First, we have to create the dynamical state of the system. It is defined by the all degrees of freedom in the system and their velocities. Here, we have two revolute joints (one degree of freedom). Thus, the minimal coordinates vector \\(q\\) and minimal velocity vector \\(q'\\) has two dimensions.</p> <pre><code>state = x_xy.State.create(sys)\n</code></pre> <pre><code>state.q\n</code></pre> <pre>\n<code>Array([0., 0.], dtype=float32)</code>\n</pre> <pre><code>state.qd\n</code></pre> <pre>\n<code>Array([0., 0.], dtype=float32)</code>\n</pre> <pre><code>next_state = x_xy.step(sys, state)\n</code></pre> <p>Massive speedups if we use <code>jax.jit</code> to jit-compile the function.</p> <pre><code>%timeit x_xy.step(sys, state)\n</code></pre> <pre>\n<code>339 ms \u00b1 15 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code>\n</pre> <pre><code>%timeit jax.jit(x_xy.step)(sys, state)\n</code></pre> <pre>\n<code>94.6 \u00b5s \u00b1 42.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code>\n</pre> <p>Let's unroll the dynamics for multiple timesteps.</p> <pre><code>T = 10.0\nxs = []\nfor _ in range(int(T / sys.dt)):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n</code></pre> <p>Next, let's render the frames and create an animation.</p> <pre><code>frames = x_xy.render(sys, xs, camera=\"targetfar\")\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03&lt;00:00, 250.57it/s]\n</code>\n</pre> <pre><code>def show_video(frames: list[np.ndarray], dt: float):\n    assert dt == 0.01\n    # frames are at 100 Hz, but let's create an animation at 25Hz\n    media.show_video([frames[i][..., :3] for i in range(0, len(frames), 4)], fps=25)\n\nshow_video(frames, sys.dt)\n</code></pre>        This browser does not support the video tag.        <p>Hmm, pretty boring. Let's get the pendulum into an configuration with some potential energy.</p> <p>All we have to change is the initial state <code>state.q</code>.</p> <pre><code>state = x_xy.State.create(sys, q=jnp.array([jnp.pi / 2, 0]))\n</code></pre> <pre><code>T = 10.0\nxs = []\nfor _ in range(int(T / sys.dt)):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n\nframes = x_xy.render(sys, xs, camera=\"targetfar\")\nshow_video(frames, sys.dt)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:04&lt;00:00, 249.70it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>That's more like it!</p> <p>Next, we will take a look at \"kinematic simulation\".</p> <p>Let's start with why you would want this. </p> <p>Imagine we want to learn a filter that estimates some quantity of interest from some sensor input. </p> <p>Then, we could try to create many random motions, record the measured sensor input, and the ground truth quantity of interest target values. </p> <p>This is then used as training data for a Machine Learning model.</p> <p>The general interface to kinematic simulation is via <code>x_xy.build_generator</code>.</p> <p>This function creates a function (of type <code>Generator</code>) that maps a PRNG seed to, e.g., <code>X, y</code> data.</p> <pre><code>gen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nseed = 1\n_, xs = gen(jax.random.PRNGKey(seed))\n</code></pre> <pre><code># right now `xs` is a batched `Transform` object\n# so convert to a list of unbatched `Transform` object which is what `render_frames` expects.\nxs_list = [xs[i] for i in range(xs.shape())]\n</code></pre> <pre><code>frames = x_xy.render(sys, xs_list, camera=\"targetfar\")\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:04&lt;00:00, 246.81it/s]\n</code>\n</pre> <p>This is now completely random, but unphysical motion. It's only kinematics, but that is okay for creating training data.</p> <pre><code>show_video(frames, sys.dt)\n</code></pre>        This browser does not support the video tag.        <p>We are interested in simulating IMU data as input <code>X</code>, and estimating quaternions as target <code>y</code>.</p> <p>We can easily simulate an IMU with only the trajectory of maximal coordinates <code>xs</code>.</p> <p>Suppose, we want to simulate an IMU right that is placed on the <code>lower</code> segment and right at the revolute joint.</p> <p>This is exactly where the coordinate system of the <code>lower</code> segment is placed.</p> <p>Right now the <code>xs</code> trajectory contains both coordinate sytems of <code>upper</code> and <code>lower</code>.</p> <pre><code># (n_timesteps, n_links, 3)\nxs.pos.shape\n</code></pre> <pre>\n<code>(1000, 2, 3)</code>\n</pre> <pre><code># (n_timesteps, n_links, 4)\nxs.rot.shape\n</code></pre> <pre>\n<code>(1000, 2, 4)</code>\n</pre> <p>From the axis with length two, the 0th entry is for <code>upper</code> and the 1st entry is for <code>lower</code>.</p> <pre><code>sys.name_to_idx(\"upper\")\n</code></pre> <pre>\n<code>0</code>\n</pre> <pre><code>sys.name_to_idx(\"lower\")\n</code></pre> <pre>\n<code>1</code>\n</pre> <pre><code>xs_lower = xs.take(1, axis=1)\n</code></pre> <pre><code>imu_lower = x_xy.imu(xs_lower, sys.gravity, sys.dt)\n</code></pre> <pre><code>imu_lower.keys()\n</code></pre> <pre>\n<code>dict_keys(['acc', 'gyr'])</code>\n</pre> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), imu_lower[\"gyr\"], label=[\"x\", \"y\", \"z\"])\nplt.ylabel(\"gyro [rad / s]\")\nplt.xlabel(\"time [s]\")\nplt.legend()\nplt.show()\n</code></pre> <p>As you can see it's a two-dimensional problem, which is why only one (<code>y</code>) is non-zero.</p> <p>Let's consider a larger kinematic chain in free 3D space.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"three_segment_kinematic_chain\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\" pos=\"0 0 2\"&gt;\n            &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"seg1\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"-0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"-0.5 0 0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rz\" pos=\"1 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.5 0 -0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nseed = 1\n_, xs = gen(jax.random.PRNGKey(seed))\nxs_list = [xs[i] for i in range(xs.shape())]\nframes = x_xy.render(sys, xs_list, camera=\"targetfar\")\nshow_video(frames, sys.dt)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:04&lt;00:00, 203.91it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>We can modify the <code>build_generator</code> with a custom <code>finalize_fn</code> which determines what output the generator generates.</p> <p>The two orange boxes on segment 1 and segment 3 are modelling our two IMUs. This will be the network's input <code>X</code> data.</p> <p>As target we will try to estimate both relative orientations as <code>y</code> data.</p> <pre><code>def finalize_fn(key: jax.Array, q: jax.Array, xs: x_xy.Transform, sys: x_xy.System):\n    xs_by_name = lambda name: xs.take(sys.name_to_idx(name), axis=1)\n    X = {\n        \"seg1\": x_xy.imu(xs_by_name(\"imu1\"), sys.gravity, sys.dt),\n        \"seg3\": x_xy.imu(xs_by_name(\"imu2\"), sys.gravity, sys.dt),\n    }\n\n    xs_seg1 = xs_by_name(\"seg1\")\n    xs_seg2 = xs_by_name(\"seg2\")\n    xs_seg3 = xs_by_name(\"seg3\")\n\n    # all `xs` transforms are to be interpreted as \"from epsilon to segment\"\n    xs_from_seg2_to_seg1 = x_xy.transform_mul(xs_seg1, x_xy.transform_inv(xs_seg2))\n    xs_from_seg3_to_seg2 = x_xy.transform_mul(xs_seg2, x_xy.transform_inv(xs_seg3))\n\n    y = {\n        # we only estimate the orientation, so extract the quaternion from the transform (transform.rot)\n        \"seg2\": xs_from_seg2_to_seg1.rot,\n        \"seg3\": xs_from_seg3_to_seg2.rot\n    }\n    return X, y\n\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5), finalize_fn=finalize_fn)\nseed = 1\nX, y = gen(jax.random.PRNGKey(seed))\n</code></pre> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), X[\"seg1\"][\"gyr\"], label=[\"x\", \"y\", \"z\"])\nplt.ylabel(\"gyro [rad / s]\")\nplt.xlabel(\"time [s]\")\nplt.title(\"IMU 1 Gyroscope\")\nplt.legend()\nplt.show()\n</code></pre> <p>Now, the IMU is non-zero in all three <code>x/y/z</code> components.</p> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), y[\"seg2\"], label=[\"w\", \"x\", \"y\", \"z\"])\nplt.xlabel(\"time [s]\")\nplt.title(\"Relative quaternion from seg2 to seg1\")\nplt.legend()\nplt.show()\n</code></pre> <p>Note how the relative quaternion is only around the y-axis. Can you see why? (Hint: Check the defining <code>xml_str</code>.)</p> <pre><code>\n</code></pre>"},{"location":"notebooks/getting_started/#dynamical-simulation","title":"Dynamical Simulation","text":""},{"location":"notebooks/getting_started/#kinematic-simulation","title":"Kinematic Simulation","text":""},{"location":"notebooks/getting_started/#x-y-training-data-attaching-sensors","title":"<code>X, y</code> Training data / Attaching sensors","text":""},{"location":"notebooks/imu_modeling/","title":"Imu modeling","text":"<pre><code>from x_xy.subpkgs import exp\nimport matplotlib.pyplot as plt\nimport jax\nimport x_xy\nimport jax.numpy as jnp\n\nhz = 100\nmarkerMap = {\n    \"seg1\": 2,\n    \"seg5\": 2,\n    \"seg2\": 1,\n    \"seg3\": 2,\n    \"seg4\": 4\n}\n\ndef load_data(seg: str, t1: float, t2: float, motion: str = \"fast\"):\n\n    data = exp.load_data(\"S_06\", motion)[seg]\n\n    # extract a small window from long time series for plotting\n    pos, rot, imu_data = jax.tree_map(lambda arr: arr[int(t1 * hz): int(t2 * hz)], \n                                      (data[f\"marker{markerMap[seg]}\"], data[\"quat\"], data[\"imu_rigid\"]))\n    rot = x_xy.maths.quat_inv(rot)\n\n    # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation\n    xs = x_xy.Transform.create(pos, rot)\n    return pos, rot, xs, imu_data\n\n\nt1, t2 = 3.0, 9.0\npos, rot, xs, imu_data = load_data(\"seg1\", t1, t2)\n</code></pre> <p>Remove gravity from accelerometer to better compare.</p> <pre><code>def linear_acceleration(xs: x_xy.Transform, acc: jax.Array) -&gt; jax.Array:\n    q_E2Imu = xs.rot\n    q_Imu2E = x_xy.maths.quat_inv(q_E2Imu)\n    gravity = jnp.array([0, 0, 9.81])\n    acc_E_nograv = x_xy.maths.rotate(acc, q_Imu2E) - gravity\n    return x_xy.maths.rotate(acc_E_nograv, q_E2Imu)\n\nimu_data[\"acc\"] = linear_acceleration(xs, imu_data[\"acc\"])\n</code></pre> <pre><code>def plot_imu(imu_data: dict):\n    imu_data = jax.tree_map(lambda arr: arr[:-100], imu_data.copy())\n    fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n    ts = jnp.arange(t1, t2 - 1.0, step=1 / hz)\n    axes[0].plot(ts, imu_data[\"acc\"], label=[\"x\", \"y\", \"z\"])\n    axes[1].plot(ts, imu_data[\"gyr\"], label=[\"x\", \"y\", \"z\"])\n    for ax in axes:\n        ax.grid()\n        ax.set_xlabel(\"time [s]\")\n        ax.legend()\n    axes[0].set_title(\"Acc\")\n    axes[1].set_title(\"Gyr\")\n\nplot_imu(imu_data)\n</code></pre> <pre><code>imu_data = x_xy.imu(xs, gravity=jnp.zeros((3,)), dt=1 / hz)\nplot_imu(imu_data)\n</code></pre> <p>Accelerometer doesn't look too great! We need low-pass filtering. Two options:</p> <pre><code>imu_data = x_xy.imu(xs, gravity=jnp.zeros((3,)), dt=1 / hz, quasi_physical=True)\nplot_imu(imu_data)\n</code></pre> <pre><code>imu_data = x_xy.imu(xs, gravity=jnp.zeros((3,)), dt=1 / hz, low_pass_filter_pos_f_cutoff=15.0, low_pass_filter_rot_alpha=0.55)\nplot_imu(imu_data)\n</code></pre> <pre><code>from scipy.optimize import minimize\n\ndef optimize_parameters(seg: str, motion: str):\n\n    # include all `fast` data in the optimization\n    t1, t2 = 0.0, 500.0\n    pos, rot, xs, imu_data = load_data(seg, t1, t2, motion)\n    imu_data[\"acc\"] = linear_acceleration(xs, imu_data[\"acc\"])\n\n    @jax.jit\n    def objective(params):\n        f_cutoff, alpha, offset = params\n\n        # probably move about 5cm negative x-axis in local CS for e.g. segment 1\n        pos_offset = x_xy.maths.rotate(x_xy.maths.rotate(pos, rot) + jnp.array([offset, 0, 0]), x_xy.maths.quat_inv(rot))\n        xs_offset = xs.replace(pos=pos_offset)\n        imu = x_xy.imu(xs_offset, jnp.zeros((3,)), 1 / hz, low_pass_filter_pos_f_cutoff=f_cutoff, low_pass_filter_rot_alpha=alpha)\n\n        return jnp.mean((imu_data[\"acc\"] - imu[\"acc\"])**2) + jnp.mean((imu_data[\"gyr\"] - imu[\"gyr\"])**2)\n\n    return minimize(objective, jnp.array([5.0, 1.0, 0.0]), method=\"Nelder-Mead\")\n</code></pre> <pre><code>for seg in [\"seg1\", \"seg2\", \"seg3\", \"seg4\", \"seg5\"]:\n    print(optimize_parameters(seg, \"fast\"))\n</code></pre> <pre>\n<code>       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.7932277321815491\n             x: [ 1.135e+01  3.934e-01  1.147e-01]\n           nit: 105\n          nfev: 206\n final_simplex: (array([[ 1.135e+01,  3.934e-01,  1.147e-01],\n                       [ 1.135e+01,  3.934e-01,  1.147e-01],\n                       [ 1.135e+01,  3.933e-01,  1.147e-01],\n                       [ 1.135e+01,  3.933e-01,  1.147e-01]]), array([ 7.932e-01,  7.932e-01,  7.933e-01,  7.933e-01]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.4039503335952759\n             x: [ 1.129e+01  4.117e-01  1.165e-01]\n           nit: 94\n          nfev: 184\n final_simplex: (array([[ 1.129e+01,  4.117e-01,  1.165e-01],\n                       [ 1.129e+01,  4.117e-01,  1.165e-01],\n                       [ 1.129e+01,  4.117e-01,  1.165e-01],\n                       [ 1.129e+01,  4.117e-01,  1.165e-01]]), array([ 4.040e-01,  4.040e-01,  4.040e-01,  4.040e-01]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.3781769871711731\n             x: [ 1.193e+01  4.375e-01  1.198e-01]\n           nit: 130\n          nfev: 246\n final_simplex: (array([[ 1.193e+01,  4.375e-01,  1.198e-01],\n                       [ 1.193e+01,  4.374e-01,  1.198e-01],\n                       [ 1.193e+01,  4.374e-01,  1.198e-01],\n                       [ 1.193e+01,  4.374e-01,  1.198e-01]]), array([ 3.782e-01,  3.782e-01,  3.782e-01,  3.782e-01]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.5418692231178284\n             x: [ 1.133e+01  4.609e-01  1.157e-01]\n           nit: 120\n          nfev: 233\n final_simplex: (array([[ 1.133e+01,  4.609e-01,  1.157e-01],\n                       [ 1.133e+01,  4.609e-01,  1.157e-01],\n                       [ 1.133e+01,  4.609e-01,  1.157e-01],\n                       [ 1.133e+01,  4.609e-01,  1.157e-01]]), array([ 5.419e-01,  5.419e-01,  5.419e-01,  5.419e-01]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.6123257279396057\n             x: [ 1.106e+01  3.812e-01  1.210e-01]\n           nit: 107\n          nfev: 201\n final_simplex: (array([[ 1.106e+01,  3.812e-01,  1.210e-01],\n                       [ 1.106e+01,  3.812e-01,  1.210e-01],\n                       [ 1.106e+01,  3.812e-01,  1.210e-01],\n                       [ 1.106e+01,  3.813e-01,  1.210e-01]]), array([ 6.123e-01,  6.123e-01,  6.123e-01,  6.123e-01]))\n</code>\n</pre> <pre><code>for seg in [\"seg1\", \"seg2\", \"seg3\", \"seg4\", \"seg5\"]:\n    print(optimize_parameters(seg, \"slow1\"))\n</code></pre> <pre>\n<code>       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.09304095804691315\n             x: [ 9.910e+00  3.885e-01  1.136e-01]\n           nit: 111\n          nfev: 211\n final_simplex: (array([[ 9.910e+00,  3.885e-01,  1.136e-01],\n                       [ 9.910e+00,  3.885e-01,  1.136e-01],\n                       [ 9.910e+00,  3.885e-01,  1.136e-01],\n                       [ 9.910e+00,  3.885e-01,  1.136e-01]]), array([ 9.304e-02,  9.305e-02,  9.305e-02,  9.305e-02]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.02368384227156639\n             x: [ 1.008e+01  3.732e-01  1.332e-01]\n           nit: 97\n          nfev: 190\n final_simplex: (array([[ 1.008e+01,  3.732e-01,  1.332e-01],\n                       [ 1.008e+01,  3.732e-01,  1.332e-01],\n                       [ 1.008e+01,  3.732e-01,  1.332e-01],\n                       [ 1.008e+01,  3.732e-01,  1.332e-01]]), array([ 2.368e-02,  2.369e-02,  2.369e-02,  2.369e-02]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.01580578088760376\n             x: [ 8.666e+00  3.510e-01  1.343e-01]\n           nit: 111\n          nfev: 219\n final_simplex: (array([[ 8.666e+00,  3.510e-01,  1.343e-01],\n                       [ 8.666e+00,  3.510e-01,  1.343e-01],\n                       [ 8.666e+00,  3.510e-01,  1.343e-01],\n                       [ 8.667e+00,  3.510e-01,  1.343e-01]]), array([ 1.581e-02,  1.581e-02,  1.581e-02,  1.581e-02]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.01700039766728878\n             x: [ 8.336e+00  3.602e-01  1.210e-01]\n           nit: 108\n          nfev: 208\n final_simplex: (array([[ 8.336e+00,  3.602e-01,  1.210e-01],\n                       [ 8.336e+00,  3.601e-01,  1.210e-01],\n                       [ 8.335e+00,  3.601e-01,  1.210e-01],\n                       [ 8.335e+00,  3.602e-01,  1.210e-01]]), array([ 1.700e-02,  1.700e-02,  1.700e-02,  1.700e-02]))\n       message: Optimization terminated successfully.\n       success: True\n        status: 0\n           fun: 0.10861615836620331\n             x: [ 6.784e+00  3.782e-01  5.929e-04]\n           nit: 50\n          nfev: 107\n final_simplex: (array([[ 6.784e+00,  3.782e-01,  5.929e-04],\n                       [ 6.784e+00,  3.782e-01,  5.930e-04],\n                       [ 6.784e+00,  3.782e-01,  5.930e-04],\n                       [ 6.784e+00,  3.782e-01,  5.930e-04]]), array([ 1.086e-01,  1.086e-01,  1.086e-01,  1.086e-01]))\n</code>\n</pre> <pre><code>\n</code></pre>"},{"location":"notebooks/imu_modeling/#on-what-imus-measure","title":"On \"what IMUs measure\"","text":""},{"location":"notebooks/imu_modeling/#real-world-imu","title":"Real-world IMU","text":""},{"location":"notebooks/imu_modeling/#vanilla-simulated-imu","title":"Vanilla simulated IMU","text":""},{"location":"notebooks/imu_modeling/#quasi-physical-simulation-strategy","title":"Quasi-physical simulation strategy","text":""},{"location":"notebooks/imu_modeling/#butterworth-filtering","title":"Butterworth filtering","text":""},{"location":"notebooks/imu_modeling/#optimize-low-pass-filter-parameters","title":"Optimize low-pass-filter parameters","text":""},{"location":"notebooks/knee_joint_translational_dof/","title":"Knee joint translational dof","text":"<p>This example is available as a jupyter notebook here.</p> <p>And on Google Colab here</p> <p>Setup the environment if this is executed on Google Colab.</p> <p>Make sure to change the runtime type to <code>GPU</code>. To do this go to <code>Runtime</code> -&gt; <code>Change runtime type</code> -&gt; <code>GPU</code></p> <p>Otherwise, rendering won't work in Google Colab.</p> <pre><code>import os\n\ntry:\n    import google.colab\n    IN_COLAB = True\nexcept:\n    IN_COLAB = False\n\nif IN_COLAB:\n    os.system(\"pip install --quiet 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'\")\n    os.system(\"pip install --quiet mediapy\")\n    os.system(\"pip install --quiet matplotlib\")\n    os.system(\"pip install --quiet dm-haiku\")\n</code></pre> <pre><code>import x_xy\n# automatically detects colab or not\nx_xy.utils.setup_colab_env()\n\nimport jax\nimport jax.numpy as jnp\nimport haiku as hk\nimport mediapy as media\n</code></pre> <pre><code>MAX_TRANSLATION = 0.1\nROM_MIN_RAD = 0.0\nROM_MAX_RAD = jnp.pi\n\ndef build_mlp_knee(key: jax.random.PRNGKey = jax.random.PRNGKey(1)):\n\n    @hk.without_apply_rng\n    @hk.transform\n    def mlp(x):\n        net = hk.nets.MLP([10, 10, 2], activation=jnp.tanh, w_init=hk.initializers.RandomNormal())\n        # normalize the x input; [0, 1]\n        x = (x + ROM_MIN_RAD) / (ROM_MAX_RAD - ROM_MIN_RAD)\n        # center the x input; [-0.5, 0.5]\n        x = (x - 0.5)\n        return net(x)\n\n    example_q = jnp.zeros((1,))\n    params = mlp.init(key, example_q)\n    params_flat, unflatten = jax.flatten_util.ravel_pytree(params)\n\n    def forward(params_flat: jax.Array, q: jax.Array):\n        params = unflatten(params_flat)\n        return jax.nn.sigmoid(mlp.apply(params, q)) * MAX_TRANSLATION\n\n    return params_flat, forward \n\ndef register_knee_joint():\n    params_flat, forward = build_mlp_knee(jax.random.PRNGKey(0))\n    x_xy.update_n_joint_params(params_flat.size)\n\n\n    def transform_fn_knee(q: jax.Array, params: jax.Array) -&gt; x_xy.Transform:\n        pos = jnp.concatenate((forward(params, q), jnp.array([0.0])))\n        axis = jnp.array([0, 0, 1.0])\n        rot = x_xy.maths.quat_rot_axis(axis, jnp.squeeze(q))\n        return x_xy.Transform(pos, rot)\n\n\n    def draw_fn_knee(config: x_xy.RCMG_Config, key_t, key_value, dt, params):\n        qs = x_xy.algorithms.jcalc._draw_rxyz(config, key_t, key_value, dt, params)\n        # rom constraints\n        return (qs / (2 * jnp.pi) + 0.5) * (ROM_MAX_RAD - ROM_MIN_RAD) + ROM_MIN_RAD\n\n    x_xy.register_new_joint_type(\"knee\", x_xy.JointModel(transform_fn_knee, rcmg_draw_fn=draw_fn_knee), 1, 0)\n</code></pre> <pre><code>register_knee_joint()\n</code></pre> <pre><code>HIP_REVOLUTE_JOINT = True\n\nxml_str = f\"\"\"\n&lt;x_xy&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;geom type=\"xyz\" dim=\"0.15\"/&gt;\n        &lt;body name=\"_femur\" joint=\"py\" euler=\"90 90 0\" pos=\"0.5 0.5 0.8\"&gt;\n            &lt;geom type=\"xyz\" dim=\"0.1\"/&gt;\n            &lt;body name=\"femur\" joint=\"{\"rz\" if HIP_REVOLUTE_JOINT else \"frozen\"}\"&gt;\n                &lt;geom type=\"xyz\" dim=\"0.1\"/&gt;\n                &lt;geom type=\"capsule\" mass=\"10\" euler=\"0 90 0\" pos=\"0.2 0 0\" dim=\"0.05 0.4\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"0.2 0 0.06\"&gt;\n                    &lt;geom type=\"xyz\" dim=\"0.05\"/&gt;\n                    &lt;geom type=\"box\" mass=\"0\" dim=\"0.05 0.05 0.02\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n                &lt;body name=\"tibia\" joint=\"knee\" pos=\"0.4 0 0\"&gt;\n                    &lt;geom type=\"xyz\" dim=\"0.1\"/&gt;\n                    &lt;geom type=\"capsule\" mass=\"10\" euler=\"0 90 0\" pos=\"0.2 0 0\" dim=\"0.04 0.4\"/&gt;\n                    &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.2 0 0.06\"&gt;\n                        &lt;geom type=\"xyz\" dim=\"0.05\"/&gt;\n                        &lt;geom type=\"box\" mass=\"0\" dim=\"0.05 0.05 0.02\" color=\"orange\"/&gt;\n                    &lt;/body&gt;\n                    &lt;geom type=\"box\" mass=\"5.0\" pos=\"0.45 -.1 0\" dim=\"0.025 0.2 0.05\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n</code></pre> <pre><code>def setup_fn(key, sys: x_xy.System) -&gt; x_xy.System:\n    params_flat, _ = build_mlp_knee(key)\n    return sys.replace(links=sys.links.replace(joint_params=sys.links.joint_params.at[sys.name_to_idx(\"tibia\")].set(params_flat)))\n\n\ndef finalize_fn(key, qs, xs: x_xy.Transform, sys: x_xy.System):\n    X = {}\n    for imu in [\"imu1\", \"imu2\"]:\n        xs_imu = xs.take(sys.name_to_idx(imu), axis=1)\n        X[imu] = {}\n        X[imu][\"pos\"] = xs_imu.pos\n        X[imu][\"quat\"] = xs_imu.rot\n        X[imu][\"imu\"] = x_xy.imu(xs_imu, sys.gravity, sys.dt)\n\n    params = sys.links.joint_params[sys.name_to_idx(\"tibia\")]\n    return qs, xs, X, params\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(t_min=0.1, t_max=0.75, T=30, ), setup_fn, finalize_fn)\nbatchsize = 32\ngen = x_xy.batch_generators_lazy(gen, batchsize)\n</code></pre> <pre><code>qs, xs, X, params = gen(jax.random.PRNGKey(14))\n</code></pre> <pre><code>import matplotlib.pyplot as plt\n\n\nidx = 5\nphi = jnp.linspace(0.0, jnp.pi)[:, None]\n# meter -&gt; centimeter\ntrans_x, trans_y = jax.vmap(lambda arr: build_mlp_knee()[1](params[idx], arr))(phi).T * 100\nplt.scatter(trans_x, trans_y, c=phi, cmap=\"coolwarm\")\nplt.colorbar()\nplt.grid()\nplt.xlabel(\"x translation [cm]\")\nplt.ylabel(\"y translation [cm]\")\n</code></pre> <pre>\n<code>Text(0, 0.5, 'y translation [cm]')</code>\n</pre> <pre><code>idx = 5\nxs_render = xs[idx]\nmedia.show_video(x_xy.render(sys, [xs_render[i] for i in range(0, xs_render.shape(), 4)], camera=\"target\", width=1280, height=720), fps=25)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [00:06&lt;00:00, 120.44it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/knee_joint_translational_dof/#registering-a-knee-joint-type","title":"Registering a Knee Joint Type","text":""},{"location":"notebooks/machine_learning/","title":"Machine learning","text":"<p>This example is available as a jupyter notebook here.</p> <p>And on Google Colab here</p> <p>Setup the environment if this is executed on Google Colab.</p> <p>Make sure to change the runtime type to <code>GPU</code>. To do this go to <code>Runtime</code> -&gt; <code>Change runtime type</code> -&gt; <code>GPU</code></p> <p>Otherwise, rendering won't work in Google Colab.</p> <pre><code>import os\n\ntry:\n    import google.colab\n    IN_COLAB = True\nexcept:\n    IN_COLAB = False\n\nif IN_COLAB:\n    os.system(\"pip install --quiet 'x_xy[all_muj] @ git+https://github.com/SimiPixel/x_xy_v2'\")\n    os.system(\"pip install --quiet mediapy\")\n\nimport x_xy\n# automatically detects colab or not\nx_xy.utils.setup_colab_env()\n</code></pre> <pre><code>from x_xy.subpkgs import ml, exp, sys_composer, sim2real\nimport mediapy\nimport jax.numpy as jnp\nimport tree_utils\n</code></pre> <pre><code>def load_data_and_prediction(motion, sys, params):\n    exp_data = exp.load_data(\"S_04\", motion)\n    xml_str = exp.load_xml_str(\"S_04\")\n    xs = sim2real.xs_from_raw(sys, exp.link_name_pos_rot_data(exp_data, xml_str), qinv=True)\n\n    # slightly decrease `transform1.pos.x` by a little; purely for better optics\n    translations, rotations = sim2real.unzip_xs(sys, xs)\n    seg_mask = jnp.array([sys.name_to_idx(name) for name in sys.link_names[1:] if name[:3] != \"imu\"])\n    imu_mask = jnp.array([sys.name_to_idx(name) for name in sys.link_names[1:] if name[:3] == \"imu\"])\n    translations = translations.replace(pos=translations.pos.at[:, seg_mask, 0].set(translations.pos[:, seg_mask, 0] - 0.03))\n    translations = translations.replace(pos=translations.pos.at[:, imu_mask, 0].set(translations.pos[:, imu_mask, 0] + 0.03))\n    xs_translated = sim2real.zip_xs(sys, translations, rotations)\n\n    X = {seg: {} for seg in [\"seg2\", \"seg3\", \"seg4\"]}\n    for seg in X:\n        imu_data = exp_data[seg][\"imu_rigid\"]\n        imu_data.pop(\"mag\")\n        if seg == \"seg3\":\n            imu_data = tree_utils.tree_zeros_like(imu_data)\n        X[seg].update(imu_data)\n\n    sys_noimu, _ = sys_composer.make_sys_noimu(sys)\n    filter = ml.RNNOFilter(params=params)\n    filter.init(sys_noimu, tree_utils.tree_slice(X, 0))\n    yhat = tree_utils.tree_slice(filter.predict(tree_utils.add_batch_dim(X)), 0)\n    return xs_translated, yhat\n</code></pre> <pre><code>params = ml.load(pretrained=\"rr_rr_unknown\")\nmotion = \"thomas_fast\"\nsys = exp.load_sys(\"S_04\", morph_yaml_key=\"seg2\", delete_after_morph=[\"seg5\", \"imu3\"])\n\nxs, yhat = load_data_and_prediction(motion, sys, params)\nframes = x_xy.render_prediction(sys, xs, yhat, stepframe=4, width=640, height=480, camera=\"c\", \n                         add_cameras={-1: '&lt;camera name=\"c\" mode=\"targetbody\" target=\"3\" pos=\".5 -.5 1.25\"/&gt;',})\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1150/1150 [00:07&lt;00:00, 160.92it/s]\n</code>\n</pre> <pre><code>mediapy.show_video(frames, fps=25.0)\n</code></pre>        This browser does not support the video tag.        <pre><code>\n</code></pre>"},{"location":"notebooks/magnetometer_modeling/","title":"Magnetometer modeling","text":"<pre><code>from x_xy.subpkgs import exp\nimport matplotlib.pyplot as plt\nimport jax\nimport x_xy\nimport jax.numpy as jnp\nimport numpy as np\n\nhz = 100\nmarkerMap = {\n    \"seg1\": 2,\n    \"seg5\": 2,\n    \"seg2\": 1,\n    \"seg3\": 2,\n    \"seg4\": 4\n}\n\ndef load_data(seg: str, t1: float, t2: float, motion: str = \"fast\"):\n\n    data = exp.load_data(\"S_06\", motion, resample_to_hz=hz)[seg]\n\n    # extract a small window from long time series for plotting\n    pos, rot, imu_data = jax.tree_map(lambda arr: arr[int(t1 * hz): int(t2 * hz)], \n                                      (data[f\"marker{markerMap[seg]}\"], data[\"quat\"], data[\"imu_rigid\"]))\n    rot = x_xy.maths.quat_inv(rot)\n\n    # maximal coordinates of segment, there is (almost) no sensor-to-segment orientation\n    xs = x_xy.Transform.create(pos, rot)\n    return pos, rot, xs, imu_data\n\n\nt1, t2 = 3.0, 9.0\npos, rot, xs, imu_data = load_data(\"seg1\", t1, t2)\n</code></pre> <pre><code>def plot(*mag_data):\n    mag_data = jax.tree_map(lambda arr: arr[:-100], mag_data)\n    _, axes = plt.subplots(1, len(mag_data), figsize=(len(mag_data)*6, 4))\n    axes = [axes] if not isinstance(axes, np.ndarray) else axes\n    ts = jnp.arange(t1, t2 - 1.0, step=1 / hz)\n\n    for i, mag in enumerate(mag_data):\n        axes[i].plot(ts, mag, label=[\"x\", \"y\", \"z\"])\n        axes[i].grid()\n        axes[i].set_xlabel(\"time [s]\")\n\n    axes[0].legend()\n\nplot(imu_data[\"mag\"])\n</code></pre> <pre><code>imu_data_sim = x_xy.imu(xs, jnp.array([0, 0, 9.81]), 1/hz, jax.random.PRNGKey(1), has_magnetometer=True, low_pass_filter_rot_alpha=0.5)\nplot(imu_data[\"mag\"], imu_data_sim[\"mag\"])\n</code></pre> <pre><code>from scipy.optimize import minimize\n\ndef optimize_parameters(seg: str, motion: str):\n    t1, t2 = 0.0, 500.0\n    pos, rot, xs, imu_data = load_data(seg, t1, t2, motion)\n\n    @jax.jit\n    def objective(params):\n        magvec= params\n        #alpha = np.clip(alpha, 0.0, 1.0)\n\n        imu_sim = x_xy.imu(xs, jnp.zeros((3,)), 1 / hz, \n                       low_pass_filter_rot_alpha=0.5, magvec=magvec, has_magnetometer=True)\n\n        return jnp.mean((imu_data[\"mag\"] - imu_sim[\"mag\"])**2)\n\n    res = minimize(objective, jnp.array([0.0, .7, -.7]), method=\"Nelder-Mead\")\n\n    perfect = np.array([0, res.x[1], res.x[2]])\n    perfect /= np.linalg.norm(perfect)\n    dip_angle = np.arctan2(perfect[1], perfect[2])\n    return res.x, np.linalg.norm(res.x), np.rad2deg(dip_angle) - 90\n</code></pre> <pre><code>for seg in [\"seg1\", \"seg2\", \"seg3\", \"seg4\", \"seg5\"]:\n    print(optimize_parameters(seg, \"slow1\"))\n</code></pre> <pre>\n<code>(array([-0.05896413,  0.14859727, -0.6037423 ]), 0.6245499859475367, 76.1728005538744)\n(array([ 0.02533224,  0.14627165, -0.55623915]), 0.5757074853210327, 75.26675216029446)\n(array([ 0.07460717,  0.27922318, -0.61151762]), 0.6763768248352189, 65.45823250226809)\n(array([ 0.0733927 ,  0.11376623, -0.67427571]), 0.6877332170462306, 80.42304783544904)\n(array([-0.02853771,  0.25007162, -0.56940705]), 0.6225548991139125, 66.28992758667985)\n</code>\n</pre> <pre><code>for seg in [\"seg1\", \"seg2\", \"seg3\", \"seg4\", \"seg5\"]:\n    print(optimize_parameters(seg, \"fast\"))\n</code></pre> <pre>\n<code>(array([-0.08957149,  0.17059967, -0.59387128]), 0.6243479736511597, 73.97238366561834)\n(array([ 0.0625981 ,  0.13683037, -0.30304913]), 0.33834871253087784, 65.70024471726742)\n(array([ 0.13724254,  0.17922383, -0.56517563]), 0.6085886891267375, 72.40556712429398)\n(array([ 0.06167598,  0.0691196 , -0.62971958]), 0.6364968119293144, 83.73614668184419)\n(array([-0.13426178,  0.31914448, -0.47368419]), 0.5867334490474401, 56.02990061087547)\n</code>\n</pre> <p>Test optimized magnetic field vector</p> <pre><code>pos, rot, xs, imu_data = load_data(\"seg1\", t1, t2, \"fast\")\nimu_data_sim = x_xy.imu(xs, jnp.array([0, 0, 9.81]), 1/hz, has_magnetometer=True, low_pass_filter_rot_alpha=0.56,\n                        magvec=jnp.array([-0.08957149,  0.17059967, -0.59387128]))\nplot(imu_data[\"mag\"], imu_data_sim[\"mag\"])\n</code></pre> <pre><code>pos, rot, xs, imu_data = load_data(\"seg1\", t1, t2, \"slow1\")\nimu_data_sim = x_xy.imu(xs, jnp.array([0, 0, 9.81]), 1/hz, has_magnetometer=True, low_pass_filter_rot_alpha=0.5,\n                        magvec=jnp.array([-0.05896413,  0.14859727, -0.6037423 ]), noisy=True, key=jax.random.PRNGKey(7))\nplot(imu_data[\"mag\"], imu_data_sim[\"mag\"])\n</code></pre> <pre><code>\n</code></pre>"},{"location":"notebooks/magnetometer_modeling/#magnetometer-modeling","title":"Magnetometer modeling","text":""},{"location":"notebooks/magnetometer_modeling/#real-world-magnetic-field","title":"Real-world Magnetic-field","text":""},{"location":"notebooks/magnetometer_modeling/#optimize-magnetic-field-vector","title":"Optimize Magnetic Field Vector","text":""},{"location":"notebooks/morph_system/","title":"Morph system","text":"<pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\n\ndef show_video(sys, xs: x_xy.Transform) -&gt; None:\n    assert sys.dt == 0.01\n    # only render every fourth to get a framerate of 25 fps\n    frames = x_xy.render(sys, [xs[i] for i in range(0, xs.shape(), 4)], camera=\"targetfar\", height=480, width=640)\n    # convert rgba to rgb\n    frames = [frame[..., :3] for frame in frames]\n    media.show_video(frames, fps=25)\n</code></pre> <p>In this system the middle segment <code>seg2</code> acts as \"anchor\".</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"three_segment_kinematic_chain\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\" pos=\"0 0 1\"&gt;\n            &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\" color=\"self\"/&gt;\n            &lt;body name=\"seg1\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"-0.5 0 0\" dim=\"1 0.25 0.2\" color=\"self\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"-0.5 0 0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rz\" pos=\"1 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\" color=\"self\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.5 0 -0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, dang_max_free_spherical=0.1, dpos_max=0.1))\n_, xs = gen(jax.random.PRNGKey(1))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01&lt;00:00, 180.20it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Can you see what i mean? The middle segment has all the \"global rotation and translation\".</p> <p>Let's move the anchor to <code>seg1</code> but without changing the xml syntax. This can be done with the subpackage <code>sys_composer</code>.</p> <pre><code>from x_xy.subpkgs import sys_composer\n</code></pre> <pre><code># the new parents of seg2, seg1, imu1, seg3, imu2 are ...\nnew_parents = [\"seg1\", -1, \"seg1\", \"seg2\", \"seg3\"]\nsys = sys_composer.morph_system(sys, new_parents=new_parents)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5, dang_max_free_spherical=0.1, dpos_max=0.1))\n_, xs = gen(jax.random.PRNGKey(1))\nshow_video(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:01&lt;00:00, 184.32it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>Pretty cool, ha? :)</p> <pre><code>\n</code></pre>"},{"location":"notebooks/morph_system/#different-anchors-explains-sys_composermorph_system","title":"Different Anchors (explains sys_composer.morph_system)","text":""},{"location":"notebooks/motion_artifact_rejection/","title":"Motion artifact rejection","text":"<p>This example is available as a jupyter notebook here.</p> <p>And on Google Colab here</p> <p>Setup the environment if this is executed on Google Colab.</p> <p>Make sure to change the runtime type to <code>GPU</code>. To do this go to <code>Runtime</code> -&gt; <code>Change runtime type</code> -&gt; <code>GPU</code></p> <p>Otherwise, rendering won't work in Google Colab.</p> <pre><code>import os\n\ntry:\n    import google.colab\n    IN_COLAB = True\nexcept:\n    IN_COLAB = False\n\nif IN_COLAB:\n    os.system(\"pip install --quiet 'x_xy[muj] @ git+https://github.com/SimiPixel/x_xy_v2'\")\n    os.system(\"pip install --quiet mediapy\")\n</code></pre> <pre><code>import x_xy\n# automatically detects colab or not\nx_xy.utils.setup_colab_env()\n\nimport jax\nimport jax.numpy as jnp\n\nimport mediapy as media\n\nfrom x_xy.algorithms.generator import transforms\n\ndef show_video(sys, xs, **kwargs):\n    media.show_video(x_xy.render(sys, [xs[i] for i in range(0, xs.shape(), 4)], camera=\"target\", width=640, height=480, **kwargs), fps=25)\n</code></pre> <pre><code>sys = x_xy.load_example(\"knee_flexible_imus\")\n</code></pre> <pre><code>media.show_image(x_xy.render(sys, camera=\"target\", height=480, width=640)[0])\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 32.06it/s]\n</code>\n</pre> <pre><code>T = 20.0\nT_crop = 4.0\nT_initial_nomotion = 2.0\n\nconfig = x_xy.RCMG_Config(t_min=0.1, t_max=0.75, T=T+T_crop, ang0_min=0.0, ang0_max=0.0, pos_min=-1.0, pos_max=1.0, dpos_max=0.5)\nconfig = x_xy.concat_configs([config.to_nomotion_config(), config], [T_initial_nomotion])\n\nP_gains = {\n    \"free\": jnp.array(3 * [50.0] + 3*[200.0]),\n    \"ry\": jnp.array([50.0])\n}\n\ndef setup_fn(key, sys: x_xy.System):\n    link_damping = sys.link_damping\n    link_spring_stiffness = sys.link_spring_stiffness\n\n    idx_map = sys.idx_map(\"d\")\n    # randomize damping and stiffness of IMU attachment\n    for link_name in [\"imu1\", \"imu2\", \"_imu1\", \"_imu2\"]:\n        # spherical joints\n        if link_name[0] == \"_\":\n            stiff_min, stiff_max = .2, .4\n        else: # p3d joints\n            stiff_min, stiff_max = 25.0, 75.0\n        key, c1, c2 = jax.random.split(key, 3)\n\n        slice = idx_map[link_name]\n        link_spring_stiffness = link_spring_stiffness.at[slice].set(jax.random.uniform(c1, (3,), minval=stiff_min, maxval=stiff_max))\n        link_damping = link_damping.at[slice].set(link_spring_stiffness[slice] * jax.random.uniform(c2, (3,), minval=0.05, maxval=0.2))\n\n    return sys.replace(link_damping=link_damping, link_spring_stiffness=link_spring_stiffness)\n\n\ndef finalize_fn(key, q, xs, sys):\n    X = dict()\n    for imu in [\"imu1\", \"imu2\"]:\n        key, consume = jax.random.split(key)\n        X[imu] = x_xy.imu(\n            xs.take(sys.name_to_idx(imu), 1),\n            sys.gravity,\n            sys.dt,\n            consume,\n            noisy=True\n        )\n    y = dict()\n    # tibia to femur; child to parent\n    y[\"tibia\"] = x_xy.transform_mul(xs.take(sys.name_to_idx(\"femur\"), 1), x_xy.transform_inv(xs.take(sys.name_to_idx(\"tibia\"), 1))).rot\n\n    # truncate from T + T_crop seconds to T\n    crop = int(T_crop / sys.dt)\n    X, y, q, xs = jax.tree_map(lambda arr: arr[crop:], (X, y, q, xs))\n    return (X, y), (q, xs, sys)\n\n\ngen = x_xy.GeneratorPipe(\n    x_xy.GeneratorTrafoRandomizePositions(),\n    transforms.GeneratorTrafoSetupFn(setup_fn),\n    transforms.GeneratorTrafoDynamicalSimulation(P_gains, [\"_imu1\", \"_imu2\"]),\n    transforms.GeneratorTrafoFinalizeFn(finalize_fn),\n    x_xy.GeneratorTrafoRemoveInputExtras(sys),\n    x_xy.GeneratorTrafoRemoveOutputExtras()\n)(config)\n</code></pre> <pre><code>(X, y), (q_obs, xs_obs, sys_obs) = jax.jit(gen)(jax.random.PRNGKey(2))\n</code></pre> <pre><code>show_video(sys_obs, xs_obs, show_floor=False)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:01&lt;00:00, 290.52it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>sys_frozen = sys_obs.replace(link_types=[\"frozen\", \"spherical\", \"p3d\", \"frozen\", \"spherical\", \"p3d\"])\n\ndef freeze_x(q_obs):\n    q_frozen = jnp.concatenate(tuple(q_obs[:, sys_obs.idx_map(\"q\")[name]] for name in [\"_imu1\", \"imu1\", \"_imu2\", \"imu2\"]), axis=-1)\n    return jax.vmap(lambda q: x_xy.algorithms.forward_kinematics_transforms(sys_frozen, q)[0])(q_frozen)\n</code></pre> <pre><code>show_video(sys_frozen, freeze_x(q_obs))\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:03&lt;00:00, 162.16it/s]\n</code>\n</pre>        This browser does not support the video tag.        <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"prism/ss_23_marcel_thomas/notebook/","title":"Notebook","text":"<pre><code>import x_xy\nimport jax\nimport jax.numpy as jnp\nimport jax.random as random\nfrom x_xy.subpkgs.ml import rnno, callbacks, train, load\nfrom x_xy.subpkgs import sim2real, sys_composer\nimport tree_utils\nimport matplotlib.pyplot as plt\nimport mediapy as media\n</code></pre> <pre><code>three_seg_rigid = r\"\"\"\n&lt;x_xy model=\"three_seg_rigid\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"0.1 0 0\" dim=\"0.2 0.05 0.05\" color=\"red\"/&gt;\n            &lt;body name=\"seg1\" joint=\"rsry\" pos=\"0 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"-0.1 0 0\" dim=\"0.2 0.05 0.05\" color=\"yellow\"/&gt;\n                &lt;body name=\"imu1\" pos=\"-0.1 0.0 0.03\" joint=\"frozen\"&gt;\n                    &lt;geom type=\"box\" mass=\"2\" pos=\"0 0 0\" dim=\"0.05 0.01 0.01\" color=\"green\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rsrz\" pos=\"0.2 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.1 0 0\" dim=\"0.2 0.05 0.05\" color=\"blue\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.1 0.0 0.03\"&gt;\n                    &lt;geom type=\"box\" mass=\"2\" pos=\"0 0 0\" dim=\"0.05 0.01 0.01\" color=\"green\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n    &lt;defaults&gt;\n        &lt;geom edge_color=\"black\" color=\"1 0.8 0.7 1\"/&gt;\n    &lt;/defaults&gt;\n&lt;/x_xy&gt;\n\"\"\"\n</code></pre> <pre><code>dustin_exp_xml_seg1 = r\"\"\"\n&lt;x_xy model=\"dustin_exp\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg1\" joint=\"free\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"-0.1 0 0\" dim=\"0.2 0.05 0.05\"/&gt;\n            &lt;body name=\"seg2\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.1 0 0\" dim=\"0.2 0.05 0.05\"/&gt;\n                    &lt;body name=\"seg3\" joint=\"rz\" pos=\"0.2 0 0\" &gt;\n                        &lt;geom type=\"box\" mass=\"10\" pos=\"0.1 0 0\" dim=\"0.2 0.05 0.05\"/&gt;\n                    &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n</code></pre> <pre><code># Helper function - Creates an array of values x &lt;- [0, 1] which may be multiplied to another sequence.\ndef motion_amplifier(\n        time : float,\n        sampling_rate : float,\n        key_rigid_phases : jax.Array,\n        n_rigid_phases=3,\n        rigid_duration_cov=jnp.array([0.02] * 3),\n        transition_cov=jnp.array([0.1] * 3)\n) -&gt; jax.Array:\n    error_msg = \"motion_amplifier: There must be a variance for each rigid phase!\"\n    assert rigid_duration_cov.shape == (n_rigid_phases,) == transition_cov.shape, error_msg\n    n_frames = int(time / sampling_rate)\n    key_rigid_means, key_rigid_variances, key_slope_down_variances, key_slope_up_variances = random.split(key_rigid_phases, 4)\n\n    # Calculate center points of rigid phases\n    means = jnp.sort(random.uniform(key_rigid_means, shape=(n_rigid_phases, 1), minval=0, maxval=n_frames).T)\n\n    # Calculate durations, which is twice the rigid distance from the center points for each rigid phase.\n    rigid_distances = jnp.abs(random.multivariate_normal(\n        key_rigid_variances, mean=jnp.zeros_like(means), cov=jnp.diag((rigid_duration_cov * n_frames)**2)))\n\n    # Calculate transition durations\n    transition_slowdown_durations = jnp.abs(random.multivariate_normal(\n        key_slope_down_variances, mean=jnp.zeros_like(means), cov=jnp.diag((transition_cov * n_frames)**2)\n        ))\n    transition_speedup_durations = jnp.abs(random.multivariate_normal(\n        key_slope_up_variances, mean=jnp.zeros_like(means), cov=jnp.diag((transition_cov * n_frames)**2)\n        ))\n\n    # Phase start and end points\n    rigid_starts = (means - rigid_distances).astype(int).flatten()\n    rigid_ends = (means + rigid_distances).astype(int).flatten()\n    starts_slowing = (means - rigid_distances - transition_slowdown_durations).astype(int).flatten()\n    ends_moving = (means + rigid_distances + transition_speedup_durations).astype(int).flatten()\n\n    # Create masks\n    def create_mask(start, end):\n        nonlocal n_frames\n        return jnp.where(jnp.arange(n_frames) &lt; start, 1, 0) + jnp.where(jnp.arange(n_frames) &gt;= end, 1, 0)\n\n    mask = jax.vmap(create_mask)\n    rigid_mask = jnp.prod(mask(rigid_starts, rigid_ends), axis=0)\n    slowdown_masks = mask(starts_slowing, rigid_starts).astype(float)\n    speedup_masks = mask(rigid_ends, ends_moving).astype(float)\n\n    # We have to define an inline function in order to make this code JIT-able\n    def linsp(mask, start, end, begin_val, carry_fun):\n        range = end - start\n        def true_fun(carry, x): return (carry_fun(carry, range), 1 - carry)\n        def false_fun(carry, x): return (carry, x)\n        def f(carry, x): return jax.lax.cond(\n            x == 0, true_fun, false_fun, *(carry, x))\n        return jax.lax.scan(f, begin_val, mask)[1]\n\n    linsp_desc = jax.vmap(lambda m, s1, s2: linsp( m, s1, s2, 0.0, lambda carry, range: carry + 1/range))\n    slowdown_mask = jnp.prod(linsp_desc(slowdown_masks, starts_slowing, rigid_starts), axis=0)\n\n    linsp_asc = jax.vmap(lambda m, s1, s2: linsp(m, s1, s2, 1.0, lambda carry, range: carry - 1/range))\n    speedup_mask = jnp.prod(linsp_asc(speedup_masks, rigid_ends, ends_moving), axis=0)\n\n    return jnp.min(jnp.stack([rigid_mask, slowdown_mask, speedup_mask]), axis=0)\n</code></pre> <pre><code># Random generator: Uses the motion_amplifier to dampen/null the randomly generated angles.\ndef random_angles_with_rigid_phases_over_time(\n    key_t,\n    key_ang,\n    dt,\n    key_rigid_phases,\n    n_rigid_phases=3,\n    rigid_duration_cov=jnp.array([0.02] * 3),\n    transition_cov=jnp.array([0.1] * 3),\n    config: x_xy.algorithms.RCMG_Config=x_xy.algorithms.RCMG_Config()\n) -&gt; jax.Array:\n\n    mask = motion_amplifier(\n        config.T,\n        dt,\n        key_rigid_phases,\n        n_rigid_phases,\n        rigid_duration_cov,\n        transition_cov)\n\n    qs = x_xy.algorithms.random_angle_over_time(\n        key_t=key_t,\n        key_ang=key_ang,\n        ANG_0=config.ang0_max,\n        dang_min=config.dang_min,\n        dang_max=config.dang_max,\n        delta_ang_min=config.delta_ang_min,\n        delta_ang_max=config.delta_ang_max,\n        t_min=config.t_min,\n        t_max=config.t_max,\n        T=config.T,\n        Ts=dt,\n        randomized_interpolation=config.randomized_interpolation_angle,\n        range_of_motion=config.range_of_motion_hinge,\n        range_of_motion_method=config.range_of_motion_hinge_method\n    )\n\n    # derivate qs\n    qs_diff = jnp.diff(qs, axis=0)\n\n    # mulitply with motion amplifier\n    qs_diff = qs_diff * mask[:-1]\n\n    # integrate qs_diff\n    qs_rigid_phases = jnp.concatenate((qs[0:1], jnp.cumsum(qs_diff, axis=0)))\n    return qs_rigid_phases\n</code></pre> <pre><code>BEST_RUN = (1, jnp.array([0.02]), jnp.array([0.1]))\nMANY_TINY_STOPS = (30, jnp.array([0.001] * 30), jnp.array([0.0001] * 30))\n##################################################################################\n# Define your own problem configuration here :)                                  #\n\nPROBLEM = BEST_RUN # &lt;- Change this assignment to use it.\n##################################################################################\n\ndef define_joints():\n    def _draw_sometimes_rigid(\n            config: x_xy.algorithms.RCMG_Config, key_t: jax.Array, key_value: jax.Array, dt : float, joint_params : jax.Array\n    ) -&gt; jax.Array:\n        key_t, key_rigid_phases = jax.random.split(key_t)\n        return random_angles_with_rigid_phases_over_time(\n            key_t=key_t,\n            key_ang=key_value,\n            dt=dt,\n            key_rigid_phases=key_rigid_phases,\n            n_rigid_phases=PROBLEM[0],\n            rigid_duration_cov=PROBLEM[1],\n            transition_cov=PROBLEM[2],\n            config=config\n        )\n\n    def _rxyz_transform(q, _, axis):\n        q = jnp.squeeze(q)\n        rot = x_xy.maths.quat_rot_axis(axis, q)\n        return x_xy.base.Transform.create(rot=rot)\n\n    rsrx_joint = x_xy.algorithms.JointModel(\n        lambda q, _: _rxyz_transform(q, _, jnp.array([1.0, 0, 0])), [None], rcmg_draw_fn=_draw_sometimes_rigid\n    )\n    rsry_joint = x_xy.algorithms.JointModel(\n        lambda q, _: _rxyz_transform(q, _, jnp.array([0, 1.0, 0])), [None], rcmg_draw_fn=_draw_sometimes_rigid\n    )\n    rsrz_joint = x_xy.algorithms.JointModel(\n        lambda q, _: _rxyz_transform(q, _, jnp.array([0, 0, 1.0])), [None], rcmg_draw_fn=_draw_sometimes_rigid\n    )\n    try:\n        x_xy.algorithms.register_new_joint_type(\"rsrx\", rsrx_joint, 1)\n        x_xy.algorithms.register_new_joint_type(\"rsry\", rsry_joint, 1)\n        x_xy.algorithms.register_new_joint_type(\"rsrz\", rsrz_joint, 1)\n    except AssertionError:\n        print(\"Warning: Joints have already been registered!\")\n\ndefine_joints()\n</code></pre> <p>Note: it is also possible to support multiple problems at the same time, by implementing them as seperate joint types, or by injecting the <code>x_xy.algorithms.RCMG_Config</code> class e.g. by inheritance.</p> <p>After we defined the joint type, we can load the system:</p> <pre><code>sys_rigid = x_xy.io.load_sys_from_str(three_seg_rigid)\nsys_inference = x_xy.io.load_sys_from_str(dustin_exp_xml_seg1)\n</code></pre> <pre><code>def finalize_fn_imu_data(key, q, x, sys):\n    imu_seg_attachment = {\"imu1\": \"seg1\", \"imu2\": \"seg3\"}\n\n    X = {}\n    for imu, seg in imu_seg_attachment.items():\n        key, consume = jax.random.split(key)\n        X[seg] = x_xy.algorithms.imu(\n            x.take(sys.name_to_idx(imu), 1), sys.gravity, sys.dt, consume, True\n        )\n    return X\n\n\ndef finalize_fn_rel_pose_data(key, _, x, sys):\n    y = x_xy.algorithms.rel_pose(sys_scan=sys_inference, xs=x, sys_xs=sys)\n    return y\n\ndef finalize_fn(key, q, x, sys):\n    X = finalize_fn_imu_data(key, q, x, sys)\n    # Since no IMU is attached to seg2, we need to provide dummy data.\n    X[\"seg2\"] = tree_utils.tree_zeros_like(X[\"seg1\"])\n    y = finalize_fn_rel_pose_data(key, q, x, sys)\n    return X, y\n</code></pre> <p>The generated data comes is returned in the tuple \\((\\mathbf{X}, \\mathbf{y})\\), with \\(\\mathbf{X}\\) being the generated IMU accelorometer and gyroscope data and \\(\\mathbf{y}\\) the orientation of each segment, in form of a unit quaternion.</p> <pre><code>def setup_fn_seg2(key, sys: x_xy.base.System) -&gt; x_xy.base.System:\n    def replace_pos(transforms, new_pos, name: str):\n        i = sys.name_to_idx(name)\n        return transforms.index_set(i, transforms[i].replace(pos=new_pos))\n\n    def draw_pos_uniform(key, pos_min, pos_max):\n        key, c1, c2, c3 = jax.random.split(key, num=4)\n        pos = jnp.array(\n            [\n                jax.random.uniform(c1, minval=pos_min[0], maxval=pos_max[0]),\n                jax.random.uniform(c2, minval=pos_min[1], maxval=pos_max[1]),\n                jax.random.uniform(c3, minval=pos_min[2], maxval=pos_max[2]),\n            ]\n        )\n        return key, pos\n\n    ts = sys.links.transform1\n\n    # seg1 relative to seg2\n    key, pos = draw_pos_uniform(key, [-0.3, -0.02, -0.02], [-0.05, 0.02, 0.02])\n    ts = replace_pos(ts, pos, \"seg1\")\n\n    # imu1 relative to seg1\n    key, pos = draw_pos_uniform(\n        key, [-0.25, -0.05, -0.05], [-0.05, 0.05, 0.05])\n    ts = replace_pos(ts, pos, \"imu1\")\n\n    # seg3 relative to seg2\n    key, pos = draw_pos_uniform(key, [0.05, -0.02, -0.02], [0.3, 0.02, 0.02])\n    ts = replace_pos(ts, pos, \"seg3\")\n\n    # imu2 relative to seg2\n    key, pos = draw_pos_uniform(key, [0.05, -0.05, -0.05], [0.25, 0.05, 0.05])\n    ts = replace_pos(ts, pos, \"imu2\")\n\n    return sys.replace(links=sys.links.replace(transform1=ts))\n</code></pre> <p>With this, we can now train the model: We first define the batch size and number of epochs. For good results, a relatively large number of epochs is required, as the mean average angle error in training converges relatively late in training. Then we plug together the setup- and finalize functions in a generator function, which will provide the batched training data. A logger might also be added, such as a neptune logger. When using neptune, the environment-variables <code>NEPTUNE_TOKEN</code> and <code>NEPTUNE_PROJECT</code> must be set accordingly. </p> <pre><code>TRAINING_BATCH_SIZE = 80\nEPOCHS = 1500\nparams_path = \"parameters.pickle\"\nKEY_GEN = random.PRNGKey(1)\nKEY_NETWORK = random.PRNGKey(1)\n\ngen = x_xy.algorithms.build_generator(sys_rigid, x_xy.algorithms.RCMG_Config(), setup_fn_seg2, finalize_fn)\ngen = x_xy.algorithms.batch_generators_lazy(gen, TRAINING_BATCH_SIZE)\n\n# Set 'upload' to True if a logger is attached.\nsave_params = callbacks.SaveParamsTrainingLoopCallback(params_path, upload=False) \n\nloggers = []\n# loggers.append(NeptuneLogger()) # You may add loggers here, e.g. a Neptune Logger\n\nnetwork = rnno.make_rnno(sys_inference)\n</code></pre> <p>WARNING! Executing this code can take a long time (due to the very high number of epochs) and will probably take up a huge portion of your memory. If you run this code on a GPU, a batch size of 80 takes more than 50 GB of VRAM, so if the execution fails, it might be because of missing GPU memory. To circumvent this, the batch size can be decreased, however, the results will suffer from that.</p> <pre><code>train(gen, EPOCHS, network, loggers=loggers, callbacks=[save_params], key_generator=KEY_GEN, key_network=KEY_NETWORK)\n</code></pre> <pre><code>def finalize_fn_inference(key, q, x, sys):\n    X = finalize_fn_imu_data(key, q, x, sys)\n    y = finalize_fn_rel_pose_data(key, q, x, sys)\n    return X, y, x\n\n\ndef generate_inference_data(sys, config: x_xy.algorithms.RCMG_Config, seed=random.PRNGKey(1,)):\n    generator = x_xy.algorithms.build_generator(sys, config, finalize_fn=finalize_fn_inference)\n    X, y, xs = generator(seed)\n    return X, y, xs\n</code></pre> <p>To control the data generated, the RCMG_Config data is used. It contains all necessary information about the to-be-generated data series, e.g. time (<code>config.T</code>), except for the sampling rate, which is stored in the system object (<code>&lt;sys&gt;.dt</code>) and set in the XML-definition. The finalize function and its return values are similiar to the training finilaize function, however, an addtitional \\(\\mathbf{xs}\\) is returned, containing the actual position and rotation. This can be used for rendering purposes later. Also, the data is not batched, as we currently are only interested in one time series.</p> <pre><code>config = x_xy.algorithms.RCMG_Config()\nprint(f\"Generating data for a time series of {config.T} seconds, with a sampling rate of {1/sys_inference.dt} Hz.\")\n\n# If you are unhappy with your data series, you can alter this seed:\nseed = random.PRNGKey(1337,)\n\nX, y, xs = generate_inference_data(sys_rigid, config, seed)\n\n# Add dummy IMU data for segment 2 (which has no IMU attached)\nX[\"seg2\"] = tree_utils.tree_zeros_like(X[\"seg1\"])\n</code></pre> <pre>\n<code>Generating data for a time series of 60.0 seconds, with a sampling rate of 100.0 Hz.\n</code>\n</pre> <pre><code>params = load(\"parameters.pickle\")\n</code></pre> <p>Finally, we have everything we need to do inference! Let's see how our network performs...</p> <pre><code># Run prediction:\nX_3d = tree_utils.to_3d_if_2d(X, strict=True)\ninitial_params, state = network.init(random.PRNGKey(1,), X_3d)\nyhat, _ = network.apply(params, tree_utils.add_batch_dim(state), X_3d)\nyhat = tree_utils.to_2d_if_3d(yhat, strict=True)\n\n# Plot prediction:\ndef plot_segment(segment : str, axis : str, ax):\n    axis_idx = \"xyz\".index(axis)\n    euler_angles_hat_seg2 = jnp.rad2deg(x_xy.maths.quat_to_euler(yhat[segment])[:,axis_idx])\n    euler_angles_seg2 = jnp.rad2deg(x_xy.maths.quat_to_euler(y[segment])[:,axis_idx])\n    ax.plot(euler_angles_hat_seg2, label=\"prediction\")\n    ax.set_ylim((-180, 180))\n    ax.set_title(f\"{segment} ({axis}-axis)\")\n    ax.plot(euler_angles_seg2, label=\"truth\")\n    ax.set_xlabel(\"time [s]\")\n    ax.set_ylabel(\"euler angles [deg]\")\n    ax.legend()\n    print(f\"{segment}: medium absolute error {jnp.average(jnp.abs(euler_angles_hat_seg2 - euler_angles_seg2))} deg\")\n\nfig, axs = plt.subplots(ncols=2, figsize=(10, 4))\nplot_segment(\"seg2\", 'y', axs[0])\nplot_segment(\"seg3\", 'z', axs[1])\nplt.show()\n</code></pre> <pre>\n<code>seg2: medium absolute error 0.524849534034729 deg\nseg3: medium absolute error 0.5137953162193298 deg\n</code>\n</pre> <p>Let's also render a video of the prediction and the truth:</p> <pre><code># Extract translations from data-generating system...\ntranslations, rotations = sim2real.unzip_xs(sys_inference, sim2real.match_xs(sys_inference, xs, sys_rigid))\nyhat_inv = jax.tree_map(lambda quat: x_xy.maths.quat_inv(quat), yhat) \n\n# ... swap rotations with predicted ones...\nrotations_hat = [] \nfor i, name in enumerate(sys_inference.link_names):\n    if name in yhat_inv:\n        rotations_name = x_xy.Transform.create(rot=yhat_inv[name])\n    else:\n        rotations_name = rotations.take(i, axis=1)\n    rotations_hat.append(rotations_name)\n\n# ... and plug the positions and rotations back together.\nrotations_hat = rotations_hat[0].batch(*rotations_hat[1:]).transpose((1, 0, 2))\nxs_hat = sim2real.zip_xs(sys_inference, translations, rotations_hat)\n\n# Create combined system that shall be rendered and its transforms\nsys_render = sys_composer.inject_system(sys_rigid, sys_inference.add_prefix_suffix(suffix=\"_hat\"))\nxs_render = x_xy.Transform.concatenate(xs, xs_hat, axis=1)\n\n#  Render prediction and truth:\nframes = x_xy.render(sys_render, [xs_render[i] for i in range(xs_render.shape(axis=0))], camera='target')\nmedia.show_video([frame[..., :3] for frame in frames], fps=25)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000/6000 [00:16&lt;00:00, 374.76it/s]\n</code>\n</pre>        This browser does not support the video tag."},{"location":"prism/ss_23_marcel_thomas/notebook/#training-the-rnno-with-rigid-phases-prism-ss2023","title":"Training the RNNO with rigid phases (PRISM SS2023)","text":"<p>In this notebook, we define a custom hinge joint, which is configured to generate pauses (no movement) inside the generated data series. We use this joint to train the RNNO and perfrom inference with the generated parameters.</p>"},{"location":"prism/ss_23_marcel_thomas/notebook/#defining-the-system","title":"Defining the System","text":"<p>A system is defined in an XML structure. To read a system, an XML file may be used. It is also possible to define the system inline by using a string in XML-syntax.In the following, we define two three-segment chains:</p>"},{"location":"prism/ss_23_marcel_thomas/notebook/#registering-the-joint-axis","title":"Registering the joint axis","text":"<p>For this scenario, we define two systems: One for generating data with rigid phases and one for inference. To generate the random data with rigid phases, we first have to register a joint type, that allows for the creation of such data. We call this joint 'rsr\\&lt;x|y|z&gt;', a hinge joint that produces random sometimes rigid data, and turns around the respective axis \\(x\\), \\(y\\) or \\(z\\) in its frame.</p>"},{"location":"prism/ss_23_marcel_thomas/notebook/#generating-random-data","title":"Generating random data","text":"<p>The random data is generated by the following functions:</p>"},{"location":"prism/ss_23_marcel_thomas/notebook/#defining-the-random-joint-function","title":"Defining the random joint function","text":"<p>First of all, we have to define our problem. This means, parameterzing the random function. Two possible scenarios are implemented below: \"BEST_RUN\" and \"MANY_TINY_STOPS\", both of which achieved adequate results. The problems are defined as \\(P=(N, \\mathbf{\\sigma}_{r}, \\mathbf{\\sigma}_{tr})\\), with \\(N\\) being the number of rigid phases, \\(\\mathbf{\\sigma}_r\\) the covariance used for calculating the length of each rigid phase and \\(\\mathbf{\\sigma}_{tr}\\) for the length of each transition phase respectively. It also holds that \\(\\mathbf{\\sigma}_r, \\mathbf{\\sigma}_{tr} \\in \\mathbb{R}^N\\), with each entry being the variance for exactly one rigid phase.</p>"},{"location":"prism/ss_23_marcel_thomas/notebook/#generating-raw-data","title":"Generating raw data","text":"<p>For both training and inference, we first need a set of raw data. In our example, <code>sys_rigid</code> is used to generate the problem-specific data for each IMU. This data will be used for training and later by <code>sys_inference</code> to estimate the position and orientation of <code>seg2</code>, which has no IMU attached.</p>"},{"location":"prism/ss_23_marcel_thomas/notebook/#train-the-model","title":"Train the model","text":"<p>Before we begin with the actual training, we first define a setup function. This is called before training on each time series. The function below alters the length of segments and the position of the IMUs of the system, to simulate inaccuracies, e.g. when dealing  with experimental data.</p>"},{"location":"prism/ss_23_marcel_thomas/notebook/#infering-data","title":"Infering data","text":""},{"location":"prism/ss_23_marcel_thomas/notebook/#inference","title":"Inference","text":"<p>To do inference, we first need to load the parameters (weights) of our model.</p>"},{"location":"prism/ss_23_moritz/notebook/","title":"Notebook","text":"<pre><code>import jax\nimport jax.numpy as jnp\nimport tree_utils\nfrom jax.nn import softmax\nimport matplotlib.pyplot as plt\nimport mediapy\n\nimport x_xy\nfrom x_xy.subpkgs import ml, sim2real, sys_composer\n</code></pre> <p>Set the batch size and number of training episodes according to the available hardware.</p> <pre><code>BATCHSIZE = 32\nNUM_TRAINING_EPISODES = 1500\n</code></pre> <pre><code>sys_str = r\"\"\"\n&lt;x_xy model=\"three_segment_kinematic_chain\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;defaults&gt;\n        &lt;geom color=\"orange\"/&gt;\n    &lt;/defaults&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\" pos=\"0 0 2\"&gt;\n            &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"seg1\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"-0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"-0.5 0 0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"red\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rz\" pos=\"1 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.5 0 -0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"red\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\nsys = x_xy.io.load_sys_from_str(sys_str)\n</code></pre> <pre><code>dustin_exp_xml_seg1 = r\"\"\"\n&lt;x_xy model=\"dustin_exp\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;defaults&gt;\n        &lt;geom color=\"white\"/&gt;\n    &lt;/defaults&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg1\" joint=\"free\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"-0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"seg2\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"seg3\" joint=\"rz\" pos=\"0.2 0 0\" &gt;\n                    &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\nsys_inference = x_xy.io.load_sys_from_str(dustin_exp_xml_seg1)\n</code></pre> <pre><code>def finalise_fn(key: jax.Array, q: jax.Array, xs: x_xy.Transform, sys: x_xy.System):\n    def xs_by_name(name: str):\n        return xs.take(sys.name_to_idx(name), axis=1)\n\n    key, *consume = jax.random.split(key, 3)\n\n    # the input X to our RNNo is the IMU data of segments 1 and 3\n    X = {\n        \"seg1\": x_xy.imu(xs_by_name(\"imu1\"), sys.gravity, sys.dt, consume[0], True),\n        \"seg3\": x_xy.imu(xs_by_name(\"imu2\"), sys.gravity, sys.dt, consume[1], True),\n    }\n\n    # seg2 has no IMU, but we still need to make an entry in our X\n    X[\"seg2\"] = tree_utils.tree_zeros_like(X[\"seg1\"])\n\n    # the output of the RNNo is the estimated relative poses of our segments\n    y = x_xy.algorithms.rel_pose(sys_scan=sys_inference, xs=xs, sys_xs=sys)\n\n    return X, y\n\nconfig = x_xy.algorithms.RCMG_Config(dpos_max=0.3, ang0_min=0.0, ang0_max=0.0)\n\ngen = x_xy.build_generator(sys, config, finalize_fn=finalise_fn)\ngen = x_xy.batch_generator(gen, BATCHSIZE)\n</code></pre> <pre><code>def make_loss_fn(beta):\n    def metric_fn(q, q_hat):\n        return x_xy.maths.angle_error(q, q_hat) ** 2\n\n    if beta is not None:\n\n        def loss_fn(q, q_hat):\n            # q.shape == q_hat.shape == (1000, 4)\n            angles = metric_fn(q, q_hat)\n\n            factors = angles.shape[-1] * softmax(\n                beta * jax.lax.stop_gradient(angles), axis=-1\n            )\n\n            errors = factors * angles\n\n            return errors\n\n    else:\n        loss_fn = metric_fn\n\n    return loss_fn\n</code></pre> <p><code>beta</code> determines the strength of our weighting: the larger beta, the more relative weight we put on the larger errors, while <code>beta = 0.0</code> makes the scaling factors uniform one and gives us back our unweighted errors. Alternatively <code>beta = None</code> bypasses the scaling altogether. </p> <pre><code>beta = 1.0\n</code></pre> <pre><code>rnno = ml.make_rnno(sys_inference)\n\nloss_fn = make_loss_fn(beta)\n\nsave_params = ml.callbacks.SaveParamsTrainingLoopCallback(\n    \"parameters.pickle\", upload=False\n)\n\nml.train(gen, NUM_TRAINING_EPISODES, rnno, callbacks=[save_params], loss_fn=loss_fn)\n</code></pre> <p>To visualise our network, we can render it using mediapy. First we generate some motion data.</p> <pre><code>gen = x_xy.build_generator(sys, config)\n\nkey = jax.random.PRNGKey(1)\n\nq, xs = gen(key)\n</code></pre> <p>We need to again bring the motion data in the correct form for our RNNo and can then run inference of the generated data.</p> <pre><code>params = ml.load(\"parameters.pickle\")\n\nX, y = finalise_fn(key, q, xs, sys)\n\nX = tree_utils.add_batch_dim(X)\n\n_, state = rnno.init(key, X)\n\nstate = tree_utils.add_batch_dim(state)\n\ny_hat, _ = rnno.apply(params, state, X)\ny_hat = tree_utils.to_2d_if_3d(y_hat, strict=True)\n</code></pre> <p>First we want to plot the angle error for both segment 2 and segment 3 over time.</p> <pre><code>y[\"seg2\"][:10]\n</code></pre> <pre><code>y_hat[\"seg2\"]\n</code></pre> <pre><code>fig, ax = plt.subplots()\n\nangle_error2 = jnp.rad2deg(x_xy.maths.angle_error(y[\"seg2\"], y_hat[\"seg2\"]))\nangle_error3 = jnp.rad2deg(x_xy.maths.angle_error(y[\"seg3\"], y_hat[\"seg3\"]))\n\nT = jnp.arange(angle_error2.size) * sys_inference.dt\n\nax.plot(T, angle_error2, label=\"seg2\")\nax.plot(T, angle_error3, label=\"seg3\")\n\nax.set_xlabel(\"time [s]\")\nax.set_ylabel(\"abs. angle error [deg]\")\n\nax.legend()\n\nplt.show()\n</code></pre> <p>Next we have to create an <code>xs_hat</code> of the estimated orientations, so that we can render them.</p> <pre><code># Extract translations from data-generating system...\ntranslations, rotations = sim2real.unzip_xs(\n    sys_inference, sim2real.match_xs(sys_inference, xs, sys)\n)\n\ny_hat_inv = jax.tree_map(lambda quat: x_xy.maths.quat_inv(quat), y_hat) \n\n# ... swap rotations with predicted ones...\nrotations_hat = [] \nfor i, name in enumerate(sys_inference.link_names):\n    if name in y_hat_inv:\n        rotations_name = x_xy.Transform.create(rot=y_hat_inv[name])\n    else:\n        rotations_name = rotations.take(i, axis=1)\n    rotations_hat.append(rotations_name)\n\n# ... and plug the positions and rotations back together.\nrotations_hat = rotations_hat[0].batch(*rotations_hat[1:]).transpose((1, 0, 2))\nxs_hat = sim2real.zip_xs(sys_inference, translations, rotations_hat)\n\n# Create combined system that shall be rendered and its transforms\nsys_render = sys_composer.inject_system(sys, sys_inference.add_prefix_suffix(suffix=\"_hat\"))\nxs_render = x_xy.Transform.concatenate(xs, xs_hat, axis=1)\n</code></pre> <p>Now we can render both the predicted system (in white) as well as the real system (in orange).</p> <pre><code>xs_list = [xs_render[i] for i in range(xs_render.shape())]\n\nframes = x_xy.render(sys_render, xs_list, camera=\"targetfar\")\nmediapy.show_video([frame[..., :3] for frame in frames], fps=int(1 / sys.dt))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"prism/ss_23_moritz/notebook/#training-the-rnno-with-a-custom-loss-function","title":"Training the RNNo with a custom loss function","text":"<p>This notebook showcases how train an RNNo network with a custom loss function rather than the default mean-reduces angle error. This is showcased by scaling the error by a softmax over the time axis, which puts more weight on the time intervals with a higher deviation compared to ones with lower deviation.</p>"},{"location":"prism/ss_23_moritz/notebook/#defining-the-systems","title":"Defining the systems","text":"<p>We use two separate systems, both parsed from XML strings: one for training (<code>sys</code>) and one for inference (<code>dustin_sys</code>).</p>"},{"location":"prism/ss_23_moritz/notebook/#generating-the-motion-data","title":"Generating the motion data","text":"<p>Our motion data will be automatically generated using a <code>Generator</code>, which can be customised using an <code>RCMG_Config</code>. The <code>Generator</code> will generate data for both <code>q</code>, that is the state of all the joint angles in the system, as well as <code>xs</code>, which describes the orientations of all the links in the system. To use this data for training our RNNo, we first have to bring it into the correct form using a <code>finalise_fn</code>.</p>"},{"location":"prism/ss_23_moritz/notebook/#custom-loss-function","title":"Custom loss function","text":"<p>To customise the loss function of the RNNo, we transform the error values before they are averaged. The input to our loss function will be both \\(q\\), the real joint state, as well as \\(\\hat{q}\\), the joint space estimated by our RNNo. <code>q</code> and <code>q_hat</code> will both be <code>jax.Array</code>s of shape <code>(T_tbp, 4)</code>, where the first axis is slice over time (of our TBPTT length) and the second axis are the 4 components of a quaternion.</p> <p>In this notebook we want to change the relative weightings of the errors at different times using a softmax function in order to put more weight on larger errors. First we convert the errors from quaterions to angles. Then we scale each error angle by a factor, calculated from a softmax over the angles. The calculation of the factors includes a call to <code>jax.lax.stop_gradient</code> to make it so our gradients are only from the errors themselves, not the factors as well.</p>"}]}