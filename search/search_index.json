{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This is the documentation for the <code>x_xy</code> software library.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"api/exp_data/","title":"subpkgs.exp_data","text":""},{"location":"api/exp_data/#x_xy.subpkgs.exp_data.exp_data.load_data","title":"<code>load_data(exp_id, motion_start, motion_stop=None, left_padd=0.0, right_padd=0.0, start_for_start=True, stop_for_stop=True)</code>","text":"Source code in <code>x_xy/subpkgs/exp_data/exp_data.py</code> <pre><code>def load_data(\n    exp_id: str,\n    motion_start: str,\n    motion_stop: Optional[str] = None,\n    left_padd: float = 0.0,\n    right_padd: float = 0.0,\n    start_for_start: bool = True,\n    stop_for_stop: bool = True,\n) -&gt; dict:\n    trial_data = joblib.load(_load_file_path(exp_id, \"joblib\"))\n\n    timings = _read_yaml(exp_id)[\"timings\"]\n\n    if motion_stop is None:\n        motion_stop = motion_start\n\n    motions = list(timings.keys())\n    assert motions.index(motion_start) &lt;= motions.index(\n        motion_stop\n    ), f\"starting point motion {motion_start} is after the stopping \"\n    \"point motion {motion_stop}\"\n\n    if motion_start == motion_stop:\n        assert start_for_start and stop_for_stop, \"Empty sequence, stop &lt;= start\"\n\n    t1 = timings[motion_start][\"start\" if start_for_start else \"stop\"] - left_padd\n    # ensure that t1 &gt;= 0\n    t1 = max(t1, 0.0)\n    t2 = timings[motion_stop][\"stop\" if stop_for_stop else \"start\"] + right_padd\n\n    return _crop_sequence(trial_data, 1 / HZ, t1=t1, t2=t2)\n</code></pre>"},{"location":"api/exp_data/#x_xy.subpkgs.exp_data.exp_data.load_sys","title":"<code>load_sys(exp_id, preprocess_sys=None, morph_yaml_key=None, delete_after_morph=None, replace_rxyz_with_rr=False)</code>","text":"Source code in <code>x_xy/subpkgs/exp_data/exp_data.py</code> <pre><code>def load_sys(\n    exp_id: str,\n    preprocess_sys: Optional[Callable] = None,\n    morph_yaml_key: Optional[str] = None,\n    delete_after_morph: Optional[list[str]] = None,\n    replace_rxyz_with_rr: bool = False,\n) -&gt; x_xy.base.System:\n    xml_path = _load_file_path(exp_id, \"xml\")\n    sys = x_xy.io.load_sys_from_xml(xml_path)\n\n    if preprocess_sys is not None:\n        sys = preprocess_sys(sys)\n\n    if replace_rxyz_with_rr:\n        sys = _replace_rxyz_with_rr(sys)\n\n    if morph_yaml_key is not None:\n        new_parents = _read_yaml(exp_id)[\"morph\"][morph_yaml_key]\n        sys = sys_composer.morph_system(sys, new_parents)\n\n    if delete_after_morph is not None:\n        sys = sys_composer.delete_subsystem(sys, delete_after_morph)\n\n    return sys\n</code></pre>"},{"location":"api/register_joint_types/","title":"Register New Joint Types","text":""},{"location":"api/register_joint_types/#x_xy.algorithms.jcalc.register_new_joint_type","title":"<code>register_new_joint_type(joint_type, joint_model, q_width, qd_width=None)</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>def register_new_joint_type(\n    joint_type: str,\n    joint_model: JointModel,\n    q_width: int,\n    qd_width: Optional[int] = None,\n):\n    if qd_width is None:\n        qd_width = q_width\n\n    assert len(joint_model.motion) == qd_width\n    assert joint_type not in _joint_types, \"already exists\"\n    _joint_types.update({joint_type: joint_model})\n    base.Q_WIDTHS.update({joint_type: q_width})\n    base.QD_WIDTHS.update({joint_type: qd_width})\n</code></pre>"},{"location":"api/register_joint_types/#x_xy.algorithms.jcalc.JointModel","title":"<code>JointModel</code>  <code>dataclass</code>","text":"Source code in <code>x_xy/algorithms/jcalc.py</code> <pre><code>@dataclass\nclass JointModel:\n    # (q, params) -&gt; Transform\n    transform: Callable[[jax.Array, jax.Array], base.Transform]\n    # len(motion) == len(qd)\n    motion: list[base.Motion] = field(default_factory=lambda: [])\n    # (config, key_t, key_value, params) -&gt; jax.Array\n    rcmg_draw_fn: Optional[DRAW_FN] = None\n</code></pre>"},{"location":"api/sim2real/","title":"subpkgs.sim2real","text":""},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.xs_from_raw","title":"<code>xs_from_raw(sys, link_name_pos_rot, t1=0.0, t2=None, eps_frame=None, qinv=True)</code>","text":"<p>Build time-series of maximal coordinates <code>xs</code> from raw position and quaternion trajectory data. This function scans through each link (as defined by <code>sys</code>), looks for the raw data in <code>link_name_pos_rot</code> using the <code>link_name</code> as identifier. It inverts the quaternion if <code>qinv</code>. Then, it creates a <code>Transform</code> that transforms from epsilon (as defined by <code>eps_frame</code>) to the link for each timestep. Finally, it stacks all transforms in order as defined by <code>sys</code> along the 1-th axis. The 0-th axis is time axis.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System which defines ordering of returned <code>xs</code></p> required <code>link_name_pos_rot</code> <code>dict</code> <p>Dictonary of <code>link_name</code> -&gt; {'pos': ..., 'quat': ...}. Obtained, e.g., using <code>process_omc</code>.</p> required <code>t1</code> <code>float</code> <p>Crop time left. Defaults to 0.0.</p> <code>0.0</code> <code>t2</code> <code>Optional[float]</code> <p>Crop time right. Defaults to None.</p> <code>None</code> <code>eps_frame</code> <code>str</code> <p>Move into this segment's frame at time zero as eps frame. Defaults to <code>None</code>. If <code>None</code>: Use root-frame as eps-frame. If 'none': Don't move into a specific eps-frame.</p> <code>None</code> <p>Returns:</p> Type Description <code>Transform</code> <p>x_xy.base.Transform: Time-series of eps-to-link transformations</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def xs_from_raw(\n    sys: x_xy.base.System,\n    link_name_pos_rot: dict,\n    t1: float = 0.0,\n    t2: Optional[float] = None,\n    eps_frame: Optional[str] = None,\n    qinv: bool = True,\n) -&gt; x_xy.base.Transform:\n\"\"\"Build time-series of maximal coordinates `xs` from raw position and\n    quaternion trajectory data. This function scans through each link (as\n    defined by `sys`), looks for the raw data in `link_name_pos_rot` using\n    the `link_name` as identifier. It inverts the quaternion if `qinv`.\n    Then, it creates a `Transform` that transforms from epsilon (as defined\n    by `eps_frame`) to the link for each timestep. Finally, it stacks all\n    transforms in order as defined by `sys` along the 1-th axis. The 0-th\n    axis is time axis.\n\n    Args:\n        sys (x_xy.base.System): System which defines ordering of returned `xs`\n        link_name_pos_rot (dict): Dictonary of `link_name` -&gt;\n            {'pos': ..., 'quat': ...}. Obtained, e.g., using `process_omc`.\n        t1 (float, optional): Crop time left. Defaults to 0.0.\n        t2 (Optional[float], optional): Crop time right. Defaults to None.\n        eps_frame (str, optional): Move into this segment's frame at time zero as\n            eps frame. Defaults to `None`.\n            If `None`: Use root-frame as eps-frame.\n            If 'none': Don't move into a specific eps-frame.\n\n    Returns:\n        x_xy.base.Transform: Time-series of eps-to-link transformations\n    \"\"\"\n\n    if eps_frame == \"none\":\n        warnings.warn(\n            \"`eps_frame` set to `none` might lead to problems with artificial IMUs,\"\n            \" since the gravity vector is assumed to be in positive z-axis in eps-frame\"\n        )\n\n    link_name_pos_rot = _crop_sequence(link_name_pos_rot, sys.dt, t1, t2)\n\n    # determine `eps_frame` transform\n    if eps_frame != \"none\":\n        if eps_frame is None:\n            connect_to_base = []\n            # find link and link name that connects to world\n            for link_name, link_parent in zip(sys.link_names, sys.link_parents):\n                if link_parent == -1:\n                    connect_to_base.append(link_name)\n            assert len(connect_to_base) == 1, (\n                f\"Ambiguous `eps-frame` since multiple links ({connect_to_base})\"\n                \" connect to base.\"\n            )\n            eps_frame = connect_to_base[0]\n        eps = link_name_pos_rot[eps_frame]\n        q_eps = eps[\"quat\"][0]\n        if qinv:\n            q_eps = x_xy.maths.quat_inv(q_eps)\n        t_eps = x_xy.base.Transform(eps[\"pos\"][0], q_eps)\n    else:\n        t_eps = x_xy.base.Transform.zero()\n\n    # build `xs` from optical motion capture data\n    xs = []\n\n    def f(_, __, link_name: str):\n        q, pos = (\n            link_name_pos_rot[link_name][\"quat\"],\n            link_name_pos_rot[link_name][\"pos\"],\n        )\n        if qinv:\n            q = x_xy.maths.quat_inv(q)\n        t = x_xy.base.Transform(pos, q)\n        t = x_xy.algebra.transform_mul(t, x_xy.algebra.transform_inv(t_eps))\n        xs.append(t)\n\n    scan_sys(sys, f, \"l\", sys.link_names)\n\n    # stack and permute such that time-axis is 0-th axis\n    xs = xs[0].batch(*xs[1:])\n    xs = xs.transpose((1, 0, 2))\n    return xs\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.match_xs","title":"<code>match_xs(sys, xs, sys_xs)</code>","text":"<p>Match tranforms <code>xs</code> to subsystem <code>sys</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Smaller system. Every link in <code>sys</code> must be in <code>sys_xs</code>.</p> required <code>xs</code> <code>Transform</code> <p>Transforms of larger system.</p> required <code>sys_xs</code> <code>Transform</code> <p>Larger system.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Transforms of smaller system.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def match_xs(sys: System, xs: Transform, sys_xs: System) -&gt; Transform:\n\"\"\"Match tranforms `xs` to subsystem `sys`.\n\n    Args:\n        sys (System): Smaller system. Every link in `sys` must be in `sys_xs`.\n        xs (Transform): Transforms of larger system.\n        sys_xs (Transform): Larger system.\n\n    Returns:\n        Transform: Transforms of smaller system.\n    \"\"\"\n    _checks_time_series_of_xs(sys_xs, xs)\n\n    # disable warnings temporarily because otherwise it will warn because of the usage\n    # of `eps_frame` = 'none'\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        xs_small = xs_from_raw(\n            sys,\n            {\n                name: {\n                    \"pos\": xs.pos[:, sys_xs.name_to_idx(name)],\n                    \"quat\": xs.rot[:, sys_xs.name_to_idx(name)],\n                }\n                for name in sys_xs.link_names\n            },\n            eps_frame=\"none\",\n            qinv=False,\n        )\n    return xs_small\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.unzip_xs","title":"<code>unzip_xs(sys, xs)</code>","text":"<p>Split eps-to-link transforms into parent-to-child pure translational <code>transform1</code> and pure rotational <code>transform2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Defines scan.tree</p> required <code>xs</code> <code>Transform</code> <p>Eps-to-link transforms</p> required <p>Returns:</p> Type Description <code>Tuple[Transform, Transform]</code> <p>Tuple[Transform, Transform]: transform1, transform2</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def unzip_xs(sys: System, xs: Transform) -&gt; Tuple[Transform, Transform]:\n\"\"\"Split eps-to-link transforms into parent-to-child pure\n    translational `transform1` and pure rotational `transform2`.\n\n    Args:\n        sys (System): Defines scan.tree\n        xs (Transform): Eps-to-link transforms\n\n    Returns:\n        Tuple[Transform, Transform]: transform1, transform2\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    @jax.vmap\n    def _unzip_xs(xs):\n        def f(_, __, i: int, p: int):\n            if p == -1:\n                x_parent_to_link = xs[i]\n            else:\n                x_parent_to_link = algebra.transform_mul(\n                    xs[i], algebra.transform_inv(xs[p])\n                )\n\n            transform1_pos = Transform.create(pos=x_parent_to_link.pos)\n            transform2_rot = Transform.create(rot=x_parent_to_link.rot)\n            return (transform1_pos, transform2_rot)\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_parents)\n\n    return _unzip_xs(xs)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.zip_xs","title":"<code>zip_xs(sys, xs_transform1, xs_transform2)</code>","text":"<p>Performs forward kinematics using <code>transform1</code> and <code>transform2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Defines scan_sys</p> required <code>xs_transform1</code> <code>Transform</code> <p>Applied before <code>transform1</code></p> required <code>xs_transform2</code> <code>Transform</code> <p>Applied after <code>transform2</code></p> required <p>Returns:</p> Type Description <code>Transform</code> <p>x_xy.base.Transform: Time-series of eps-to-link transformations</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def zip_xs(\n    sys: System,\n    xs_transform1: Transform,\n    xs_transform2: Transform,\n) -&gt; Transform:\n\"\"\"Performs forward kinematics using `transform1` and `transform2`.\n\n    Args:\n        sys (x_xy.base.System): Defines scan_sys\n        xs_transform1 (x_xy.base.Transform): Applied before `transform1`\n        xs_transform2 (x_xy.base.Transform): Applied after `transform2`\n\n    Returns:\n        x_xy.base.Transform: Time-series of eps-to-link transformations\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs_transform1)\n    _checks_time_series_of_xs(sys, xs_transform2)\n\n    @jax.vmap\n    def _zip_xs(xs_transform1, xs_transform2):\n        eps_to_l = {-1: x_xy.base.Transform.zero()}\n\n        def f(_, __, i: int, p: int):\n            transform = algebra.transform_mul(xs_transform2[i], xs_transform1[i])\n            eps_to_l[i] = algebra.transform_mul(transform, eps_to_l[p])\n            return eps_to_l[i]\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_parents)\n\n    return _zip_xs(xs_transform1, xs_transform2)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.delete_to_world_pos_rot","title":"<code>delete_to_world_pos_rot(sys, xs)</code>","text":"<p>Replace the transforms of all links that connect to the worldbody by unity transforms.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System only used for structure (in scan_sys).</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of modified transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def delete_to_world_pos_rot(sys: System, xs: Transform) -&gt; Transform:\n\"\"\"Replace the transforms of all links that connect to the worldbody\n    by unity transforms.\n\n    Args:\n        sys (System): System only used for structure (in scan_sys).\n        xs (Transform): Time-series of transforms to be modified.\n\n    Returns:\n        Transform: Time-series of modified transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    zero_trafo = Transform.zero((xs.shape(),))\n    for i, p in enumerate(sys.link_parents):\n        if p == -1:\n            xs = _overwrite_transform_of_link_then_update(sys, xs, zero_trafo, i)\n    return xs\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.randomize_to_world_pos_rot","title":"<code>randomize_to_world_pos_rot(key, sys, xs, config)</code>","text":"<p>Replace the transforms of all links that connect to the worldbody by randomize transforms.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Array</code> <p>PRNG Key.</p> required <code>sys</code> <code>System</code> <p>System only used for structure (in scan_sys).</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <code>config</code> <code>RCMG_Config</code> <p>Defines the randomization.</p> required <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of modified transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def randomize_to_world_pos_rot(\n    key: jax.Array, sys: System, xs: Transform, config: RCMG_Config\n) -&gt; Transform:\n\"\"\"Replace the transforms of all links that connect to the worldbody\n    by randomize transforms.\n\n    Args:\n        key (jax.Array): PRNG Key.\n        sys (System): System only used for structure (in scan_sys).\n        xs (Transform): Time-series of transforms to be modified.\n        config (RCMG_Config): Defines the randomization.\n\n    Returns:\n        Transform: Time-series of modified transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n    assert sys.link_parents.count(-1) == 1, \"Found multiple connections to world\"\n\n    free_sys_str = \"\"\"\n&lt;x_xy&gt;\n    &lt;options dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"free\" joint=\"free\"/&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\n    free_sys = load_sys_from_str(free_sys_str)\n    _, xs_free = build_generator(free_sys, config)(key)\n    xs_free = xs_free.take(free_sys.name_to_idx(\"free\"), axis=1)\n    link_idx_to_world = sys.link_parents.index(-1)\n    return _overwrite_transform_of_link_then_update(sys, xs, xs_free, link_idx_to_world)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.scale_xs","title":"<code>scale_xs(sys, xs, factor, exclude=['px', 'py', 'pz', 'free'])</code>","text":"<p>Increase / decrease transforms by scaling their positional / rotational components based on the systems link type, i.e. the <code>xs</code> should conceptionally be <code>transform2</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System defining structure (for scan_sys)</p> required <code>xs</code> <code>Transform</code> <p>Time-series of transforms to be modified.</p> required <code>factor</code> <code>float</code> <p>Multiplicative factor.</p> required <code>exclude</code> <code>list[str]</code> <p>Skip scaling of transforms if their link_type is one of those. Defaults to [\"px\", \"py\", \"pz\", \"free\"].</p> <code>['px', 'py', 'pz', 'free']</code> <p>Returns:</p> Name Type Description <code>Transform</code> <code>Transform</code> <p>Time-series of scaled transforms.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def scale_xs(\n    sys: System,\n    xs: Transform,\n    factor: float,\n    exclude: list[str] = [\"px\", \"py\", \"pz\", \"free\"],\n) -&gt; Transform:\n\"\"\"Increase / decrease transforms by scaling their positional / rotational\n    components based on the systems link type, i.e. the `xs` should conceptionally\n    be `transform2` objects.\n\n    Args:\n        sys (System): System defining structure (for scan_sys)\n        xs (Transform): Time-series of transforms to be modified.\n        factor (float): Multiplicative factor.\n        exclude (list[str], optional): Skip scaling of transforms if their link_type\n            is one of those. Defaults to [\"px\", \"py\", \"pz\", \"free\"].\n\n    Returns:\n        Transform: Time-series of scaled transforms.\n    \"\"\"\n    _checks_time_series_of_xs(sys, xs)\n\n    @jax.vmap\n    def _scale_xs(xs):\n        def f(_, __, i: int, type: str):\n            x_link = xs[i]\n            if type not in exclude:\n                x_link = _scale_transform_based_on_type(x_link, type, factor)\n            return x_link\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_types)\n\n    return _scale_xs(xs)\n</code></pre>"},{"location":"api/sim2real/#x_xy.subpkgs.sim2real.project_xs","title":"<code>project_xs(sys, transform2)</code>","text":"<p>Project transforms into the physically feasible subspace as defined by the joints in the system.</p> Source code in <code>x_xy/subpkgs/sim2real/sim2real.py</code> <pre><code>def project_xs(sys: System, transform2: Transform) -&gt; Transform:\n\"\"\"Project transforms into the physically feasible subspace as defined by the\n    joints in the system.\"\"\"\n    _checks_time_series_of_xs(sys, transform2)\n\n    _str2idx = {\"x\": 0, \"y\": 1, \"z\": 2}\n\n    @jax.vmap\n    def _project_xs(transform2):\n        def f(_, __, i: int, link_type: str):\n            t = transform2[i]\n            rot, pos = jnp.array([1.0, 0, 0, 0]), jnp.zeros((3,))\n\n            if link_type in [\"rx\", \"ry\", \"rz\"]:\n                angles = maths.quat_to_euler(t.rot)\n                idx = _str2idx[link_type[1]]\n                proj_angles = jnp.zeros((3,)).at[idx].set(angles[idx])\n                rot = maths.euler_to_quat(proj_angles)\n            elif link_type in [\"px\", \"py\", \"pz\"]:\n                idx = _str2idx[link_type[1]]\n                pos = pos.at[idx].set(t.pos[idx])\n            elif link_type == \"spherical\":\n                rot = t.rot\n            elif link_type in [\"p3d\", \"cor\"]:\n                pos = t.pos\n            elif link_type == \"free\":\n                pos, rot = t.pos, t.rot\n            elif link_type in [\"rr\", \"frozen\"]:\n                warnings.warn(\n                    f\"`{link_type}`-joint-types can currently not be projected.\"\n                )\n            else:\n                raise NotImplementedError\n            return Transform(pos=pos, rot=rot)\n\n        return scan_sys(sys, f, \"ll\", list(range(sys.num_links())), sys.link_types)\n\n    return _project_xs(transform2)\n</code></pre>"},{"location":"api/state/","title":"State","text":""},{"location":"api/state/#x_xy.base.State","title":"<code>State</code>","text":"<p>The static and dynamic state of a system in minimal and maximal coordinates. Use <code>.create()</code> to create this object.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Array</code> <p>System state in minimal coordinates (equals <code>sys.q_size()</code>)</p> required <code>qd</code> <code>Array</code> <p>System velocity in minimal coordinates (equals <code>sys.qd_size()</code>)</p> required <code>x</code> <p>(Transform): Maximal coordinates of all links. From epsilon-to-link.</p> required <code>mass_mat_inv</code> <code>Array</code> <p>Inverse of the mass matrix. Internal usage.</p> required Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass State(_Base):\n\"\"\"The static and dynamic state of a system in minimal and maximal coordinates.\n    Use `.create()` to create this object.\n\n    Args:\n        q (jax.Array): System state in minimal coordinates (equals `sys.q_size()`)\n        qd (jax.Array): System velocity in minimal coordinates (equals `sys.qd_size()`)\n        x: (Transform): Maximal coordinates of all links. From epsilon-to-link.\n        mass_mat_inv (jax.Array): Inverse of the mass matrix. Internal usage.\n    \"\"\"\n\n    q: jax.Array\n    qd: jax.Array\n    x: Transform\n    mass_mat_inv: jax.Array\n\n    @classmethod\n    def create(\n        cls, sys: System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None\n    ):\n\"\"\"Create state of system.\n\n        Args:\n            sys (System): The system for which to create a state.\n            q (jax.Array, optional): The joint values of the system. Defaults to None.\n            Which then defaults to zeros.\n            qd (jax.Array, optional): The joint velocities of the system.\n            Defaults to None. Which then defaults to zeros.\n\n        Returns:\n            (State): Create State object.\n        \"\"\"\n        # to avoid circular imports\n        from x_xy import scan_sys\n\n        if q is None:\n            q = jnp.zeros((sys.q_size(),))\n\n            # free and spherical joints are not zeros but unit quaternions\n            def replace_by_unit_quat(carry, idx_map, link_typ, link_idx):\n                nonlocal q\n\n                if link_typ == \"spherical\" or link_typ == \"free\":\n                    q_idxs_link = idx_map[\"q\"](link_idx)\n                    q = q.at[q_idxs_link.start].set(1.0)\n\n            scan_sys(\n                sys,\n                replace_by_unit_quat,\n                \"ll\",\n                sys.link_types,\n                list(range(sys.num_links())),\n            )\n\n        if qd is None:\n            qd = jnp.zeros((sys.qd_size(),))\n        x = Transform.zero((sys.num_links(),))\n        return cls(q, qd, x, jnp.diag(jnp.ones((sys.qd_size(),))))\n</code></pre>"},{"location":"api/state/#x_xy.base.State.create","title":"<code>create(sys, q=None, qd=None)</code>  <code>classmethod</code>","text":"<p>Create state of system.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>The system for which to create a state.</p> required <code>q</code> <code>Array</code> <p>The joint values of the system. Defaults to None.</p> <code>None</code> <code>qd</code> <code>Array</code> <p>The joint velocities of the system.</p> <code>None</code> <p>Returns:</p> Type Description <code>State</code> <p>Create State object.</p> Source code in <code>x_xy/base.py</code> <pre><code>@classmethod\ndef create(\n    cls, sys: System, q: Optional[jax.Array] = None, qd: Optional[jax.Array] = None\n):\n\"\"\"Create state of system.\n\n    Args:\n        sys (System): The system for which to create a state.\n        q (jax.Array, optional): The joint values of the system. Defaults to None.\n        Which then defaults to zeros.\n        qd (jax.Array, optional): The joint velocities of the system.\n        Defaults to None. Which then defaults to zeros.\n\n    Returns:\n        (State): Create State object.\n    \"\"\"\n    # to avoid circular imports\n    from x_xy import scan_sys\n\n    if q is None:\n        q = jnp.zeros((sys.q_size(),))\n\n        # free and spherical joints are not zeros but unit quaternions\n        def replace_by_unit_quat(carry, idx_map, link_typ, link_idx):\n            nonlocal q\n\n            if link_typ == \"spherical\" or link_typ == \"free\":\n                q_idxs_link = idx_map[\"q\"](link_idx)\n                q = q.at[q_idxs_link.start].set(1.0)\n\n        scan_sys(\n            sys,\n            replace_by_unit_quat,\n            \"ll\",\n            sys.link_types,\n            list(range(sys.num_links())),\n        )\n\n    if qd is None:\n        qd = jnp.zeros((sys.qd_size(),))\n    x = Transform.zero((sys.num_links(),))\n    return cls(q, qd, x, jnp.diag(jnp.ones((sys.qd_size(),))))\n</code></pre>"},{"location":"api/sys_composer/","title":"subpkgs.sys_composer","text":""},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.delete_sys.delete_subsystem","title":"<code>delete_subsystem(sys, link_name)</code>","text":"<p>Cut subsystem starting at <code>link_name</code> (inclusive) from tree.</p> Source code in <code>x_xy/subpkgs/sys_composer/delete_sys.py</code> <pre><code>def delete_subsystem(sys: base.System, link_name: str | list[str]) -&gt; base.System:\n    \"Cut subsystem starting at `link_name` (inclusive) from tree.\"\n    if isinstance(link_name, list):\n        for ln in link_name:\n            sys = delete_subsystem(sys, ln)\n        return sys\n\n    assert (\n        link_name in sys.link_names\n    ), f\"link {link_name} not found in {sys.link_names}\"\n\n    subsys = _find_subsystem_indices(sys.link_parents, sys.name_to_idx(link_name))\n    idx_map, keep = _idx_map_and_keepers(sys.link_parents, subsys)\n\n    def take(list):\n        return [ele for i, ele in enumerate(list) if i in keep]\n\n    d, a, ss, sz = [], [], [], []\n\n    def filter_arrays(_, __, damp, arma, stiff, zero, i: int):\n        if i in keep:\n            d.append(damp)\n            a.append(arma)\n            ss.append(stiff)\n            sz.append(zero)\n\n    scan_sys(\n        sys,\n        filter_arrays,\n        \"dddql\",\n        sys.link_damping,\n        sys.link_armature,\n        sys.link_spring_stiffness,\n        sys.link_spring_zeropoint,\n        list(range(sys.num_links())),\n    )\n\n    d, a, ss, sz = map(jnp.concatenate, (d, a, ss, sz))\n\n    new_sys = base.System(\n        _reindex_parent_array(sys.link_parents, subsys),\n        tree_utils.tree_indices(sys.links, jnp.array(keep, dtype=int)),\n        take(sys.link_types),\n        d,\n        a,\n        ss,\n        sz,\n        sys.dt,\n        sys.dynamic_geometries,\n        [\n            geom.replace(link_idx=idx_map[geom.link_idx])\n            for geom in sys.geoms\n            if geom.link_idx in keep\n        ],\n        sys.gravity,\n        sys.integration_method,\n        sys.mass_mat_iters,\n        take(sys.link_names),\n        sys.model_name,\n    )\n\n    return parse_system(new_sys)\n</code></pre>"},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.inject_sys.inject_system","title":"<code>inject_system(sys, sub_sys, at_body=None, prefix='')</code>","text":"<p>Combine two systems into one.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>Large system.</p> required <code>sub_sys</code> <code>System</code> <p>Small system that will be included into the large system <code>sys</code>.</p> required <code>at_body</code> <code>Optional[str]</code> <p>Into which body of the large system small system will be included. Defaults to <code>worldbody</code>.</p> <code>None</code> <code>prefix</code> <code>Optional[str]</code> <p>Prefix that is added to body identifiers of small system. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>System</code> <p>base.System: description</p> Source code in <code>x_xy/subpkgs/sys_composer/inject_sys.py</code> <pre><code>def inject_system(\n    sys: base.System,\n    sub_sys: base.System,\n    at_body: Optional[str] = None,\n    prefix: str = \"\",\n) -&gt; base.System:\n\"\"\"Combine two systems into one.\n\n    Args:\n        sys (base.System): Large system.\n        sub_sys (base.System): Small system that will be included into the\n            large system `sys`.\n        at_body (Optional[str], optional): Into which body of the large system\n            small system will be included. Defaults to `worldbody`.\n        prefix (Optional[str], optional): Prefix that is added to body identifiers\n            of small system. Defaults to ''.\n\n    Returns:\n        base.System: _description_\n    \"\"\"\n\n    # give bodies new names if required\n    sub_sys = sub_sys.replace(link_names=[prefix + name for name in sub_sys.link_names])\n\n    # replace parent array\n    if at_body is None:\n        new_world = -1\n    else:\n        new_world = sys.name_to_idx(at_body)\n\n    # append sub_sys at index end and replace sub_sys world with `at_body`\n    N = sys.num_links()\n\n    def new_parent(old_parent: int):\n        if old_parent != -1:\n            return old_parent + N\n        else:\n            return new_world\n\n    sub_sys = sub_sys.replace(\n        link_parents=[new_parent(p) for p in sub_sys.link_parents]\n    )\n\n    # replace link indices of geoms in sub_sys\n    sub_sys = sub_sys.replace(\n        geoms=[\n            geom.replace(link_idx=new_parent(geom.link_idx)) for geom in sub_sys.geoms\n        ]\n    )\n\n    # merge two systems\n    concat = lambda a1, a2: tree_batch([a1, a2], True, \"jax\")\n    combined_sys = base.System(\n        link_parents=sys.link_parents + sub_sys.link_parents,\n        links=concat(sys.links, sub_sys.links),\n        link_types=sys.link_types + sub_sys.link_types,\n        link_damping=concat(sys.link_damping, sub_sys.link_damping),\n        link_armature=concat(sys.link_armature, sub_sys.link_armature),\n        link_spring_stiffness=concat(\n            sys.link_spring_stiffness, sub_sys.link_spring_stiffness\n        ),\n        link_spring_zeropoint=concat(\n            sys.link_spring_zeropoint, sub_sys.link_spring_zeropoint\n        ),\n        dt=sys.dt,\n        dynamic_geometries=sys.dynamic_geometries,\n        geoms=sys.geoms + sub_sys.geoms,\n        gravity=sys.gravity,\n        integration_method=sys.integration_method,\n        mass_mat_iters=sys.mass_mat_iters,\n        link_names=sys.link_names + sub_sys.link_names,\n        model_name=sys.model_name,\n    )\n\n    return parse_system(combined_sys)\n</code></pre>"},{"location":"api/sys_composer/#x_xy.subpkgs.sys_composer.morph_sys.morph_system","title":"<code>morph_system(sys, new_parents, prefix='')</code>","text":"<p>Re-orders the graph underlying the system. Returns a new system.</p> <p>Parameters:</p> Name Type Description Default <code>sys</code> <code>System</code> <p>System to be modified.</p> required <code>new_parents</code> <code>list[int]</code> <p>Let the i-th entry have value j. Then, after morphing the system the system will be such that the link corresponding to the i-th link in the old system will have as parent the link corresponding to the j-th link in the old system.</p> required <code>prefix</code> <code>str</code> <p>Prefix to prepend to all link names.</p> <code>''</code> <p>Returns:</p> Type Description <code>System</code> <p>base.System: Modified system.</p> Source code in <code>x_xy/subpkgs/sys_composer/morph_sys.py</code> <pre><code>def morph_system(\n    sys: base.System, new_parents: list[int | str], prefix: str = \"\"\n) -&gt; base.System:\n\"\"\"Re-orders the graph underlying the system. Returns a new system.\n\n    Args:\n        sys (base.System): System to be modified.\n        new_parents (list[int]): Let the i-th entry have value j. Then, after morphing\n            the system the system will be such that the link corresponding to the i-th\n            link in the old system will have as parent the link corresponding to the\n            j-th link in the old system.\n        prefix (str): Prefix to prepend to all link names.\n\n    Returns:\n        base.System: Modified system.\n    \"\"\"\n\n    structure, permutation, new_parent_array = identify_system(sys, new_parents)\n\n    link_idx_old_world_old_indices = sys.link_parents.index(-1)\n    d, a, ss, sz = _per_link_arrays(sys)\n\n    def _get_joint_properties_of(i1: int, i2: int):\n        return JointProperties(\n            sys.links.transform1[i1],\n            sys.links.pos_min[i1],\n            sys.links.pos_max[i1],\n            sys.link_types[i2],\n            d[i2],\n            a[i2],\n            ss[i2],\n            sz[i2],\n        )\n\n    joint_properties = []\n    for neighbours in structure:\n        if neighbours.new_parent_old_indices == -1:\n            i1 = i2 = link_idx_old_world_old_indices\n        elif neighbours.parent_changed:\n            i1 = neighbours.new_parent_old_indices\n        else:\n            i1 = neighbours.link_idx_old_indices\n        i2 = i1\n        properties_link = _get_joint_properties_of(i1, i2)\n        if neighbours.parent_changed:\n            properties_link = properties_link.inv()\n        joint_properties.append(properties_link)\n\n    unpack = lambda attr: ([getattr(jp, attr) for jp in joint_properties])\n    new_transform1 = unpack(\"transform1\")\n    new_transform1 = new_transform1[0].batch(*new_transform1[1:])\n    new_pos_min = jnp.stack(unpack(\"pos_min\"))\n    new_pos_max = jnp.stack(unpack(\"pos_max\"))\n\n    new_links = sys.links.replace(\n        transform1=new_transform1, pos_min=new_pos_min, pos_max=new_pos_max\n    )\n\n    new_links = _update_links_new_root_to_leaves(structure, permutation, new_links)\n\n    new_link_types = unpack(\"link_type\")\n    d, a, ss, sz = map(\n        unpack,\n        (\n            \"link_damping\",\n            \"link_armature\",\n            \"link_spring_stiffness\",\n            \"link_spring_zeropoint\",\n        ),\n    )\n\n    def _permute(obj):\n        if isinstance(obj, (base._Base, jax.Array)):\n            return obj[jnp.array(permutation, dtype=jnp.int32)]\n        elif isinstance(obj, list):\n            return [obj[permutation[i]] for i in range(len(obj))]\n        assert False\n\n    # permute those that have an indexing range not directly linked to 'l'\n    d, a, ss, sz = map(lambda list: jnp.concatenate(_permute(list)), (d, a, ss, sz))\n\n    morphed_system = base.System(\n        new_parent_array,\n        _permute(new_links),\n        _permute(new_link_types),\n        d,\n        a,\n        ss,\n        sz,\n        sys.dt,\n        sys.dynamic_geometries,\n        _permute_modify_geoms(sys.geoms, structure, new_transform1),\n        sys.gravity,\n        sys.integration_method,\n        sys.mass_mat_iters,\n        [prefix + name for name in _permute(sys.link_names)],\n        sys.model_name,\n    )\n\n    return parse_system(morphed_system)\n</code></pre>"},{"location":"api/system/","title":"The System object","text":"<p>The system object (in source code shortened to <code>sys</code>) captures all relevant physical information about the system. </p> <p>This includes (not exhaustively):</p> <ul> <li>All defined coordinate systems in the system (also called links), and their associated names (<code>sys.link_names</code>)</li> <li>All fixed translation and rotation between links (<code>sys.links.transform1</code>)</li> <li>All degrees of freedom between links (<code>sys.link_types</code>)</li> <li>All massive objects (<code>sys.links.inertia</code>) and their spatial volume (<code>sys.geoms</code>)</li> <li>The timestep size (default: 0.01s or 100Hz)</li> </ul> \\[\\frac{\\mathrm{d}y}{\\mathrm{d}t} = f(t, y(t))\\] <p>Info</p> <p>Something awesome!</p>"},{"location":"api/system/#x_xy.base.System","title":"<code>System</code>","text":"Source code in <code>x_xy/base.py</code> <pre><code>@struct.dataclass\nclass System(_Base):\n    link_parents: list[int] = struct.field(False)\n    links: Link\n    link_types: list[str] = struct.field(False)\n    link_damping: jax.Array\n    link_armature: jax.Array\n    link_spring_stiffness: jax.Array\n    link_spring_zeropoint: jax.Array\n    # simulation timestep size\n    dt: float = struct.field(False)\n    # whether or not to re-calculate the inertia\n    # matrix at every simulation timestep because\n    # the geometries may have changed\n    dynamic_geometries: bool = struct.field(False)\n    # geometries in the system\n    geoms: list[Geometry]\n    # root / base acceleration offset\n    gravity: jax.Array = struct.field(default_factory=lambda: jnp.array([0, 0, -9.81]))\n\n    integration_method: str = struct.field(\n        False, default_factory=lambda: \"semi_implicit_euler\"\n    )\n    mass_mat_iters: int = struct.field(False, default_factory=lambda: 0)\n\n    link_names: list[str] = struct.field(False, default_factory=lambda: [])\n\n    model_name: Optional[str] = struct.field(False, default_factory=lambda: None)\n\n    def num_links(self) -&gt; int:\n        return len(self.link_parents)\n\n    def q_size(self) -&gt; int:\n        return sum([Q_WIDTHS[typ] for typ in self.link_types])\n\n    def qd_size(self) -&gt; int:\n        return sum([QD_WIDTHS[typ] for typ in self.link_types])\n\n    def name_to_idx(self, name: str) -&gt; int:\n        return self.link_names.index(name)\n\n    def idx_to_name(self, idx: int) -&gt; str:\n        assert idx &gt;= 0, \"Worldbody index has no name.\"\n        return self.link_names[idx]\n\n    def idx_map(self, type: str) -&gt; dict:\n        \"type: is either `l` or `q` or `d`\"\n        from x_xy import scan_sys\n\n        dict_int_slices = {}\n\n        def f(_, idx_map, name: str, link_idx: int):\n            dict_int_slices[name] = idx_map[type](link_idx)\n\n        scan_sys(self, f, \"ll\", self.link_names, list(range(self.num_links())))\n\n        return dict_int_slices\n\n    def parent_name(self, name: str) -&gt; str:\n        return self.idx_to_name(self.link_parents[self.name_to_idx(name)])\n\n    def add_prefix(self, prefix: str = \"\") -&gt; \"System\":\n        return self.replace(link_names=[prefix + name for name in self.link_names])\n\n    def change_model_name(self, name: str) -&gt; \"System\":\n        return self.replace(model_name=name)\n\n    @staticmethod\n    def deep_equal(a, b):\n        if type(a) is not type(b):\n            return False\n        if isinstance(a, _Base):\n            return System.deep_equal(a.__dict__, b.__dict__)\n        if isinstance(a, dict):\n            if a.keys() != b.keys():\n                return False\n            return all(System.deep_equal(a[k], b[k]) for k in a.keys())\n        if isinstance(a, (list, tuple)):\n            if len(a) != len(b):\n                return False\n            return all(System.deep_equal(a[i], b[i]) for i in range(len(a)))\n        if isinstance(a, (np.ndarray, jnp.ndarray, jax.Array)):\n            return jnp.array_equal(a, b)\n        return a == b\n</code></pre>"},{"location":"api/system/#x_xy.base.System.idx_map","title":"<code>idx_map(type)</code>","text":"<p>type: is either <code>l</code> or <code>q</code> or <code>d</code></p> Source code in <code>x_xy/base.py</code> <pre><code>def idx_map(self, type: str) -&gt; dict:\n    \"type: is either `l` or `q` or `d`\"\n    from x_xy import scan_sys\n\n    dict_int_slices = {}\n\n    def f(_, idx_map, name: str, link_idx: int):\n        dict_int_slices[name] = idx_map[type](link_idx)\n\n    scan_sys(self, f, \"ll\", self.link_names, list(range(self.num_links())))\n\n    return dict_int_slices\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.from_xml.load_sys_from_str","title":"<code>load_sys_from_str(xml_str, prefix='')</code>","text":"<p>Load system from string input.</p> <p>Parameters:</p> Name Type Description Default <code>xml_str</code> <code>str</code> <p>XML Presentation of the system.</p> required <code>prefix</code> <code>str</code> <p>Prefix to add to all link names. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Type Description <code>System</code> <p>base.System: Loaded system.</p> Source code in <code>x_xy/io/xml/from_xml.py</code> <pre><code>def load_sys_from_str(xml_str: str, prefix: str = \"\") -&gt; base.System:\n\"\"\"Load system from string input.\n\n    Args:\n        xml_str (str): XML Presentation of the system.\n        prefix (str, optional): Prefix to add to all link names. Defaults to \"\".\n\n    Returns:\n        base.System: Loaded system.\n    \"\"\"\n    xml_tree = ElementTree.fromstring(xml_str)\n    worldbody = _initial_setup(xml_tree)\n\n    # check that &lt;x_xy model=\"...\"&gt; syntax is correct\n    assert xml_tree.tag == \"x_xy\", (\n        \"The root element in the xml of a x_xy model must be `x_xy`.\"\n        \" Look up the examples under  x_xy/io/examples/*.xml to get started\"\n    )\n    model_name = xml_tree.attrib.get(\"model\", None)\n\n    # default options\n    options = {\"gravity\": DEFAULT_GRAVITY, \"dt\": DEFAULT_DT}\n    options_xml = _find_assert_unique(xml_tree, \"options\")\n    options.update({} if options_xml is None else options_xml.attrib)\n\n    # convert scalar array to float\n    # if this is uncommented, it leads to `ConcretizationTypeError`s\n    # options[\"dt\"] = float(options[\"dt\"])\n\n    links = {}\n    link_parents = {}\n    link_names = {}\n    link_types = {}\n    geoms = {}\n    armatures = {}\n    dampings = {}\n    spring_stiffnesses = {}\n    spring_zeropoints = {}\n    global_link_idx = -1\n\n    def process_body(body: ElementTree, parent: int):\n        nonlocal global_link_idx\n        global_link_idx += 1\n        current_link_idx = global_link_idx\n        current_link_typ = body.attrib[\"joint\"]\n\n        link_parents[current_link_idx] = parent\n        link_types[current_link_idx] = current_link_typ\n        link_names[current_link_idx] = prefix + body.attrib[\"name\"]\n\n        transform = abstract.AbsTrans.from_xml(body.attrib)\n        pos_min, pos_max = abstract.AbsPosMinMax.from_xml(body.attrib, transform.pos)\n        links[current_link_idx] = base.Link(transform, pos_min, pos_max)\n\n        q_size = base.Q_WIDTHS[current_link_typ]\n        qd_size = base.QD_WIDTHS[current_link_typ]\n\n        (\n            damping,\n            armature,\n            stiffness,\n            zeropoint,\n        ) = abstract.AbsDampArmaStiffZero.from_xml(\n            body.attrib, q_size, qd_size, current_link_typ\n        )\n\n        armatures[current_link_idx] = armature\n        dampings[current_link_idx] = damping\n        spring_stiffnesses[current_link_idx] = stiffness\n        spring_zeropoints[current_link_idx] = zeropoint\n\n        geoms[current_link_idx] = _extract_geoms_from_body_xml(body, current_link_idx)\n\n        for subbodies in body.findall(\"body\"):\n            process_body(subbodies, current_link_idx)\n\n        return\n\n    for body in worldbody.findall(\"body\"):\n        process_body(body, -1)\n\n    def assert_order_then_to_list(d: dict) -&gt; list:\n        assert [i for i in d] == list(range(len(d)))\n        return [d[i] for i in d]\n\n    links = assert_order_then_to_list(links)\n    links = links[0].batch(*links[1:])\n    dampings = jnp.concatenate(assert_order_then_to_list(dampings))\n    armatures = jnp.concatenate(assert_order_then_to_list(armatures))\n    spring_stiffnesses = jnp.concatenate(assert_order_then_to_list(spring_stiffnesses))\n    spring_zeropoints = jnp.concatenate(assert_order_then_to_list(spring_zeropoints))\n\n    # add all geoms directly connected to worldbody\n    flat_geoms = [geom for geoms in assert_order_then_to_list(geoms) for geom in geoms]\n    flat_geoms += _extract_geoms_from_body_xml(worldbody, -1)\n\n    sys = base.System(\n        assert_order_then_to_list(link_parents),\n        links,\n        assert_order_then_to_list(link_types),\n        dampings,\n        armatures,\n        spring_stiffnesses,\n        spring_zeropoints,\n        options[\"dt\"],\n        False,\n        flat_geoms,\n        options[\"gravity\"],\n        link_names=assert_order_then_to_list(link_names),\n        model_name=model_name,\n    )\n\n    return parse_system(sys)\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.from_xml.load_sys_from_xml","title":"<code>load_sys_from_xml(xml_path, prefix='')</code>","text":"Source code in <code>x_xy/io/xml/from_xml.py</code> <pre><code>def load_sys_from_xml(xml_path: str, prefix: str = \"\"):\n    return load_sys_from_str(_load_xml(xml_path), prefix=prefix)\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.to_xml.save_sys_to_str","title":"<code>save_sys_to_str(sys)</code>","text":"Source code in <code>x_xy/io/xml/to_xml.py</code> <pre><code>def save_sys_to_str(sys: base.System) -&gt; str:\n    if not jnp.all(sys.links.joint_params == 0.0):\n        warnings.warn(\n            \"The system has `sys.links.joint_params` unequal to the default value (of\"\n            \" zeros). This will not be preserved in the xml.\"\n        )\n    global_index_map = {qd: sys.idx_map(qd) for qd in [\"q\", \"d\"]}\n\n    # Create root element\n    x_xy = Element(\"x_xy\")\n    x_xy.set(\"model\", sys.model_name)\n\n    options = SubElement(x_xy, \"options\")\n    options.set(\"dt\", str(sys.dt))\n    options.set(\"gravity\", _to_str(sys.gravity))\n\n    # Create worldbody\n    worldbody = SubElement(x_xy, \"worldbody\")\n\n    def process_link(link_idx: int, parent_elem: Element):\n        link = sys.links[link_idx]\n        link_typ = sys.link_types[link_idx]\n        link_name = sys.link_names[link_idx]\n\n        # Create body element\n        body = SubElement(parent_elem, \"body\")\n        body.set(\"joint\", link_typ)\n        body.set(\"name\", link_name)\n\n        # Set attributes\n        abstract.AbsTrans.to_xml(body, link.transform1)\n        abstract.AbsPosMinMax.to_xml(body, link.pos_min, link.pos_max)\n        abstract.AbsDampArmaStiffZero.to_xml(\n            body,\n            sys.link_damping[global_index_map[\"d\"][link_name]],\n            sys.link_armature[global_index_map[\"d\"][link_name]],\n            sys.link_spring_stiffness[global_index_map[\"d\"][link_name]],\n            sys.link_spring_zeropoint[global_index_map[\"q\"][link_name]],\n            base.Q_WIDTHS[link_typ],\n            base.QD_WIDTHS[link_typ],\n            link_typ,\n        )\n\n        # Add geometry elements\n        geoms = sys.geoms\n        for geom in geoms:\n            if geom.link_idx == link_idx:\n                geom_elem = SubElement(body, \"geom\")\n                abstract_class = abstract.geometry_to_abstract[type(geom)]\n                abstract_class.to_xml(geom_elem, geom)\n\n        # Recursively process child links\n        for child_idx, parent_idx in enumerate(sys.link_parents):\n            if parent_idx == link_idx:\n                process_link(child_idx, body)\n\n    for root_link_idx, parent_idx in enumerate(sys.link_parents):\n        if parent_idx == -1:\n            process_link(root_link_idx, worldbody)\n\n    # Pretty print xml\n    xml_str = parseString(tostring(x_xy)).toprettyxml(indent=\"  \")\n    return xml_str\n</code></pre>"},{"location":"api/system/#x_xy.io.xml.to_xml.save_sys_to_xml","title":"<code>save_sys_to_xml(sys, xml_path)</code>","text":"Source code in <code>x_xy/io/xml/to_xml.py</code> <pre><code>def save_sys_to_xml(sys: base.System, xml_path: str) -&gt; None:\n    xml_str = save_sys_to_str(sys)\n    with open(xml_path, \"w\") as f:\n        f.write(xml_str)\n</code></pre>"},{"location":"api/transform/","title":"The <code>transform</code> object","text":""},{"location":"api/transform/#how-to-work-with-transforms","title":"How to work with transforms","text":""},{"location":"notebooks/getting_started/","title":"Getting started","text":"<pre><code>import x_xy\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport mediapy as media\nimport vispy\nvispy.use(\"pyqt6\")\n</code></pre> <p>Systems are defined with the following xml syntax.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"double_pendulum\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"upper\" euler=\"0 90 0\" joint=\"ry\" damping=\"2\"&gt;\n            &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"lower\" pos=\"1 0 0\" joint=\"ry\" damping=\"2\"&gt;\n                &lt;geom type=\"box\" mass=\"10\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n</code></pre> <p>With this xml description of the system, we are ready to load the system using <code>load_sys_from_str</code>. We can also save this to a text-file <code>double_pendulum.xml</code> and load with <code>load_sys_from_xml</code>.</p> <pre><code>sys = x_xy.load_sys_from_str(xml_str)\n</code></pre> <pre><code>sys.model_name\n</code></pre> <pre>\n<code>'double_pendulum'</code>\n</pre> <p>System objects have many attributes. You may refer to the API documentation for more details.</p> <pre><code>sys.link_names\n</code></pre> <pre>\n<code>['upper', 'lower']</code>\n</pre> <p>Let's start with the most obvious. A physical simulation. We refer to it as \"dynamical simulation\", in contrast to what we do a little later which is a purely kinematic simulation.</p> <p>First, we have to create the dynamical state of the system. It is defined by the all degrees of freedom in the system and their velocities. Here, we have two revolute joints (one degree of freedom). Thus, the minimal coordinates vector \\(q\\) and minimal velocity vector \\(q'\\) has two dimensions.</p> <pre><code>state = x_xy.State.create(sys)\n</code></pre> <pre><code>state.q\n</code></pre> <pre>\n<code>Array([0., 0.], dtype=float32)</code>\n</pre> <pre><code>state.qd\n</code></pre> <pre>\n<code>Array([0., 0.], dtype=float32)</code>\n</pre> <pre><code>next_state = x_xy.step(sys, state)\n</code></pre> <p>Massive speedups if we use <code>jax.jit</code> to jit-compile the function.</p> <pre><code>%timeit x_xy.step(sys, state)\n</code></pre> <pre>\n<code>340 ms \u00b1 11.3 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code>\n</pre> <pre><code>%timeit jax.jit(x_xy.step)(sys, state)\n</code></pre> <pre>\n<code>89.2 \u00b5s \u00b1 41.9 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code>\n</pre> <p>Let's unroll the dynamics for multiple timesteps.</p> <pre><code>T = 10.0\nxs = []\nfor _ in range(int(T / sys.dt)):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n</code></pre> <p>Next, let's render the frames and create an animation.</p> <pre><code>frames = x_xy.render_frames(sys, xs)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03&lt;00:00, 272.26it/s]\n</code>\n</pre> <pre><code>def show_video(frames: list[np.ndarray], dt: float):\n    assert dt == 0.01\n    # frames are at 100 Hz, but let's create an animation at 25Hz\n    media.show_video([frames[i][..., :3] for i in range(0, len(frames), 4)], fps=25)\n\nshow_video(frames, sys.dt)\n</code></pre>        This browser does not support the video tag.        <p>Hmm, pretty boring. Let's get the pendulum into an configuration with some potential energy.</p> <p>All we have to change is the initial state <code>state.q</code>.</p> <pre><code>state = x_xy.State.create(sys, q=jnp.array([jnp.pi / 2, 0]))\n</code></pre> <pre><code>T = 10.0\nxs = []\nfor _ in range(int(T / sys.dt)):\n    state = jax.jit(x_xy.step)(sys, state)\n    xs.append(state.x)\n\nframes = x_xy.render_frames(sys, xs)\nshow_video(frames, sys.dt)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03&lt;00:00, 276.10it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>That's more like it!</p> <p>Next, we will take a look at \"kinematic simulation\".</p> <p>Let's start with why you would want this. </p> <p>Imagine we want to learn a filter that estimates some quantity of interest from some sensor input. </p> <p>Then, we could try to create many random motions, record the measured sensor input, and the ground truth quantity of interest target values. </p> <p>This is then used as training data for a Machine Learning model.</p> <p>The general interface to kinematic simulation is via <code>x_xy.build_generator</code>.</p> <p>This function creates a function (of type <code>Generator</code>) that maps a PRNG seed to, e.g., <code>X, y</code> data.</p> <pre><code>gen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nseed = 1\n_, xs = gen(jax.random.PRNGKey(seed))\n</code></pre> <pre><code># right now `xs` is a batched `Transform` object\n# so convert to a list of unbatched `Transform` object which is what `render_frames` expects.\nxs_list = [xs[i] for i in range(xs.shape())]\n</code></pre> <pre><code>frames = x_xy.render_frames(sys, xs_list)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03&lt;00:00, 286.03it/s]\n</code>\n</pre> <p>This is now completely random, but unphysical motion. It's only kinematics, but that is okay for creating training data.</p> <pre><code>show_video(frames, sys.dt)\n</code></pre>        This browser does not support the video tag.        <p>We are interested in simulating IMU data as input <code>X</code>, and estimating quaternions as target <code>y</code>.</p> <p>We can easily simulate an IMU with only the trajectory of maximal coordinates <code>xs</code>.</p> <p>Suppose, we want to simulate an IMU right that is placed on the <code>lower</code> segment and right at the revolute joint.</p> <p>This is exactly where the coordinate system of the <code>lower</code> segment is placed.</p> <p>Right now the <code>xs</code> trajectory contains both coordinate sytems of <code>upper</code> and <code>lower</code>.</p> <pre><code># (n_timesteps, n_links, 3)\nxs.pos.shape\n</code></pre> <pre>\n<code>(1000, 2, 3)</code>\n</pre> <pre><code># (n_timesteps, n_links, 4)\nxs.rot.shape\n</code></pre> <pre>\n<code>(1000, 2, 4)</code>\n</pre> <p>From the axis with length two, the 0th entry is for <code>upper</code> and the 1st entry is for <code>lower</code>.</p> <pre><code>sys.name_to_idx(\"upper\")\n</code></pre> <pre>\n<code>0</code>\n</pre> <pre><code>sys.name_to_idx(\"lower\")\n</code></pre> <pre>\n<code>1</code>\n</pre> <pre><code>xs_lower = xs.take(1, axis=1)\n</code></pre> <pre><code>imu_lower = x_xy.imu(xs_lower, sys.gravity, sys.dt)\n</code></pre> <pre><code>imu_lower.keys()\n</code></pre> <pre>\n<code>dict_keys(['acc', 'gyr'])</code>\n</pre> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), imu_lower[\"gyr\"], label=[\"x\", \"y\", \"z\"])\nplt.ylabel(\"gyro [rad / s]\")\nplt.xlabel(\"time [s]\")\nplt.legend()\nplt.show()\n</code></pre> <pre>\n<code>&lt;matplotlib.legend.Legend at 0x2c33ccca0&gt;</code>\n</pre> <p>As you can see it's a two-dimensional problem, which is why only one (<code>y</code>) is non-zero.</p> <p>Let's consider a larger kinematic chain in free 3D space.</p> <pre><code>xml_str = \"\"\"\n&lt;x_xy model=\"three_segment_kinematic_chain\"&gt;\n    &lt;options gravity=\"0 0 9.81\" dt=\"0.01\"/&gt;\n    &lt;worldbody&gt;\n        &lt;body name=\"seg2\" joint=\"free\"&gt;\n            &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n            &lt;body name=\"seg1\" joint=\"ry\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"-0.5 0 0\" dim=\"-1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu1\" joint=\"frozen\" pos=\"-0.5 0 0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n            &lt;body name=\"seg3\" joint=\"rz\" pos=\"1 0 0\"&gt;\n                &lt;geom type=\"box\" mass=\"0.1\" pos=\"0.5 0 0\" dim=\"1 0.25 0.2\"/&gt;\n                &lt;body name=\"imu2\" joint=\"frozen\" pos=\"0.5 0 -0.125\"&gt;\n                    &lt;geom type=\"box\" mass=\"0.05\" dim=\"0.2 0.2 0.05\" color=\"orange\"/&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;/x_xy&gt;\n\"\"\"\n\nsys = x_xy.load_sys_from_str(xml_str)\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5))\nseed = 1\n_, xs = gen(jax.random.PRNGKey(seed))\nxs_list = [xs[i] for i in range(xs.shape())]\nframes = x_xy.render_frames(sys, xs_list)\nshow_video(frames, sys.dt)\n</code></pre> <pre>\n<code>Rendering frames..: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:04&lt;00:00, 223.44it/s]\n</code>\n</pre>        This browser does not support the video tag.        <p>We can modify the <code>build_generator</code> with a custom <code>finalize_fn</code> which determines what output the generator generates.</p> <p>The two orange boxes on segment 1 and segment 3 are modelling our two IMUs. This will be the network's input <code>X</code> data.</p> <p>As target we will try to estimate both relative orientations as <code>y</code> data.</p> <pre><code>def finalize_fn(key: jax.Array, q: jax.Array, xs: x_xy.Transform, sys: x_xy.System):\n    xs_by_name = lambda name: xs.take(sys.name_to_idx(name), axis=1)\n    X = {\n        \"seg1\": x_xy.imu(xs_by_name(\"imu1\"), sys.gravity, sys.dt),\n        \"seg3\": x_xy.imu(xs_by_name(\"imu2\"), sys.gravity, sys.dt),\n    }\n\n    xs_seg1 = xs_by_name(\"seg1\")\n    xs_seg2 = xs_by_name(\"seg2\")\n    xs_seg3 = xs_by_name(\"seg3\")\n\n    # all `xs` transforms are to be interpreted as \"from epsilon to segment\"\n    xs_from_seg2_to_seg1 = x_xy.transform_mul(xs_seg1, x_xy.transform_inv(xs_seg2))\n    xs_from_seg3_to_seg2 = x_xy.transform_mul(xs_seg2, x_xy.transform_inv(xs_seg3))\n\n    y = {\n        # we only estimate the orientation, so extract the quaternion from the transform (transform.rot)\n        \"seg2\": xs_from_seg2_to_seg1.rot,\n        \"seg3\": xs_from_seg3_to_seg2.rot\n    }\n    return X, y\n\n\ngen = x_xy.build_generator(sys, x_xy.RCMG_Config(T=10.0, t_max=1.5), finalize_fn=finalize_fn)\nseed = 1\nX, y = gen(jax.random.PRNGKey(seed))\n</code></pre> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), X[\"seg1\"][\"gyr\"], label=[\"x\", \"y\", \"z\"])\nplt.ylabel(\"gyro [rad / s]\")\nplt.xlabel(\"time [s]\")\nplt.title(\"IMU 1 Gyroscope\")\nplt.legend()\nplt.show()\n</code></pre> <p>Now, the IMU is non-zero in all three <code>x/y/z</code> components.</p> <pre><code>plt.grid()\nplt.plot(np.arange(0, 10.0, step=sys.dt), y[\"seg2\"], label=[\"w\", \"x\", \"y\", \"z\"])\nplt.xlabel(\"time [s]\")\nplt.title(\"Relative quaternion from seg2 to seg1\")\nplt.legend()\nplt.show()\n</code></pre> <p>Note how the relative quaternion is only around the y-axis. Can you see why? (Hint: Check the defining <code>xml_str</code>.)</p> <pre><code>\n</code></pre>"},{"location":"notebooks/getting_started/#dynamical-simulation","title":"Dynamical Simulation","text":""},{"location":"notebooks/getting_started/#kinematic-simulation","title":"Kinematic Simulation","text":""},{"location":"notebooks/getting_started/#x-y-training-data-attaching-sensors","title":"<code>X, y</code> Training data / Attaching sensors","text":""}]}